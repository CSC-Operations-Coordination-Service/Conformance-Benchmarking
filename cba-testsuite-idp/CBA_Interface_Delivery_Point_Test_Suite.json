{
	"info": {
		"_postman_id": "c3b64a04-6e90-4c52-a3d0-281171a96c0a",
		"name": "CBA Interface Delivery Point Test Suite.json",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "LTA Minimum Compliance",
			"item": [
				{
					"name": "LTA Products (Minimum Compliance)",
					"item": [
						{
							"name": "LTA Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    \r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"   console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"\r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Products Listing Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"",
											"function addZero(x, n) {",
											"    while (x.toString().length < n) {",
											"        x = \"0\" + x;",
											"    }",
											"    return x;",
											"}",
											"",
											"function GetCurrentDate() {",
											"    // Online Javascript Editor for free",
											"    // Write, Edit and Run your Javascript code using JS Online Compiler",
											"    var today = new Date();",
											"    var dd = String(today.getDate()).padStart(2, '0');",
											"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
											"    var yyyy = today.getFullYear();",
											"    var h = addZero(today.getHours(), 2);",
											"    var m = addZero(today.getMinutes(), 2);",
											"    var s = addZero(today.getSeconds(), 2);",
											"    var ms = addZero(today.getMilliseconds(), 6);",
											"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
											"    var time = \"00:00:00.000000\"",
											"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';",
											"    //console.log(today)",
											"    return today; // The function returns the product of p1 and p2",
											"}",
											"",
											"try {",
											"",
											"    pm.test(\"Test Response Status Code\", function () {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonData = pm.response.json();",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"    const sizeLimit = 80000000;",
											"",
											"    for (let i = 0; i < jsonDataElements.length; i++) {",
											"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);",
											"        if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && randomItems[\"Online\"] == false && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {",
											"            randomItems = jsonDataElements[i];",
											"            console.log(\"Id product found: \" + jsonDataElements[i][\"Id\"]);",
											"            //pm.globals.set(\"ProductId\", jsonDataElements[i][\"Id\"]);",
											"            break;",
											"        }",
											"    }",
											"",
											"    //console.log(randomItems);",
											"",
											"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
											"    pm.test(\"Products Name: \" + randomItems[\"Name\"], function () {",
											"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ProductName\", randomItems[\"Name\"]);",
											"    });",
											"",
											"    pm.test(\"Products Id: \" + randomItems[\"Id\"], function () {",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        pm.globals.set(\"ProductId\", randomItems[\"Id\"])",
											"    });",
											"",
											"    pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function () {",
											"        pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ContentType\", randomItems[\"ContentType\"])",
											"    });",
											"",
											"    pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function () {",
											"        pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"        pm.globals.set(\"ContentLength\", randomItems[\"ContentLength\"])",
											"    });",
											"",
											"    pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function () {",
											"        ///\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d\\d\\d(\\d*)Z/",
											"        pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"OriginDate\", randomItems[\"OriginDate\"])",
											"    });",
											"",
											"    pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function () {",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"PublicationDate\", randomItems[\"PublicationDate\"])",
											"    });",
											"",
											"    pm.test(\"Modification date: \" + randomItems[\"ModificationDate\"], function () {",
											"        pm.expect(randomItems[\"ModificationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"ModificationDate\", randomItems[\"ModificationDate\"])",
											"        //console.log(\"ModificationDate of the last product: \" + jsonDataElements[n][\"ModificationDate\"]);",
											"    });",
											"",
											"    pm.test(\"Online: \" + randomItems[\"Online\"], function () {",
											"        pm.expect(randomItems[\"Online\"]).to.be.a(\"boolean\");",
											"        pm.globals.set(\"OnlineStatus\", randomItems[\"Online\"].toString());",
											"    });",
											"",
											"    if (randomItems[\"Online\"] == true) {",
											"        pm.test(\"Test Eviction date property: \" + randomItems[\"EvictionDate\"], function () {",
											"            pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.globals.set(\"EvictionDate\", randomItems[\"EvictionDate\"])",
											"        });",
											"    }",
											"",
											"    pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function () {",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumAlgorithm\", randomItems[\"Checksum\"][0][\"Algorithm\"])",
											"    });",
											"",
											"    pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function () {",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumValue\", randomItems[\"Checksum\"][0][\"Value\"])",
											"        //console.log(\"Checksum value of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"Value\"]);",
											"    });",
											"",
											"    pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function () {",
											"        pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumDate\", randomItems[\"Checksum\"][0][\"ChecksumDate\"])",
											"        //console.log(\"ChecksumDate of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"ChecksumDate\"]);",
											"    });",
											"",
											"    pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function () {",
											"        pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"Start\", randomItems[\"ContentDate\"][\"Start\"]);",
											"    });",
											"",
											"    pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function () {",
											"        pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"End\", randomItems[\"ContentDate\"][\"End\"]);",
											"    });",
											"",
											"    if (randomItems[\"Footprint\"]) {",
											"        pm.test(\"Test Footprint property: \" + randomItems[\"Footprint\"], function () {",
											"            pm.expect(randomItems[\"Footprint\"]).to.be.a(\"string\");",
											"            pm.globals.set(\"Footprint\", randomItems[\"Footprint\"]);",
											"        });",
											"    } else {",
											"        console.warn(\"Not found Footprint: \" + randomItems.Name);",
											"        pm.globals.set(\"Footprint\", undefined);",
											"    }",
											"    ",
											"    if (randomItems[\"GeoFootprint\"]) {",
											"        let geofoot_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"        let geofoot_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"        pm.test(\"GeoFootprint: type '\" + geofoot_type + \"', coordinates [\" + geofoot_coordinates + \"]\", function (){",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"           pm.globals.set(\"GeoFootprintCoordinates\",geofoot_coordinates);",
											"           pm.globals.set(\"GeoFootprintType\",geofoot_type);",
											"        }); ",
											"    }",
											"    else {",
											"        console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"        pm.globals.set(\"GeoFootprint\", undefined);",
											"    }   ",
											"",
											"    var len_array = randomItems[\"Name\"].split('.').length",
											"    pm.globals.set(\"StartStringName\", randomItems[\"Name\"].split('_')[0] + '_' + randomItems[\"Name\"].split('_')[1])",
											"    pm.globals.set(\"EndStringName\", randomItems[\"Name\"].split('.')[len_array - 1])",
											"    pm.globals.set(\"StringName\", randomItems[\"Name\"].split('_')[2])",
											"    pm.globals.set(\"StringName2\", randomItems[\"Name\"].split('_')[3])",
											"",
											"    if (randomItems[\"Name\"].split('_')[0].includes('2')) {",
											"        pm.globals.set(\"StringNameNot\", (randomItems[\"Name\"].split('_')[0]).replace('2', '1'))",
											"        //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('2','1'));",
											"    }",
											"",
											"    if (randomItems[\"Name\"].split('_')[0].includes('1')) {",
											"        pm.globals.set(\"StringNameNot\", (randomItems[\"Name\"].split('_')[0]).replace('1', '2'))",
											"        //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('1','2'));",
											"    }",
											"",
											"    if (randomItems[\"Name\"].split('_')[0].includes('3')) {",
											"        pm.globals.set(\"StringNameNot\", (randomItems[\"Name\"].split('_')[0]).replace('3', '1'))",
											"            //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('3','1'));",
											"    }",
											"",
											"    if (randomItems[\"Name\"].split('_')[0].includes('5')) {",
											"        pm.globals.set(\"StringNameNot\", (randomItems[\"Name\"].split('_')[0]).replace('5', '1'))",
											"        //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('5','1'));",
											"   }",
											"",
											"    var randomItems1 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"    var randomItems2 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"    var randomItems3 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"",
											"    pm.globals.set(\"product1\", randomItems1[\"Name\"])",
											"    pm.globals.set(\"product2\", randomItems2[\"Name\"])",
											"    pm.globals.set(\"product3\", randomItems3[\"Name\"])",
											"",
											"} catch (err) {",
											"    pm.test(\"Test Product Listing\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										},
										{
											"key": "$top",
											"value": "10",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Name",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    pm.test(\"Test Response Status Code\", function () {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const product_name = pm.globals.get(\"ProductName\");\r",
											"const name = \"Name eq '\" + product_name + \"'\";\r",
											"const contains_string = \"contains(Name,'_\" + product_name.split('_')[1] + '_' +product_name.split('_')[2] + \"_\" + product_name.split('_')[3] + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + product_name.split('_')[0] + \"_\" + product_name.split('_')[1] + \"')\";\r",
											"    \r",
											"var len_array = product_name.split('.').length;\r",
											"const end_string = \"endswith(Name,'\" + product_name.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"let StringObjects = [name,contains_string,start_string,end_string];\r",
											"var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",itemStringObjects);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{QueryByNameString}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Sensing Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function () {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"Start\");",
											"    var prop_name = \"ContentDate\";",
											"    pm.test(\"Sensing Date: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name][\"Start\"])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test product filter sensing date\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json();",
											"    var id = pm.globals.get(\"ProductId\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Test product id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"        //check the product status",
											"        console.log(\"Product: \" + jsonDataElements.Name + \" Online=\" + jsonDataElements.Online);",
											"    });",
											"    ",
											"}",
											"catch (err) {",
											"    pm.test(\"Test Product Details\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "LTA Create Order (Minimum Compliance)",
					"item": [
						{
							"name": "LTA Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"\r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Get Offline Products",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function addZero(x, n) {\r",
											"    while (x.toString().length < n) {\r",
											"        x = \"0\" + x;\r",
											"    }\r",
											"    return x;\r",
											"}\r",
											"\r",
											"function GetCurrentDate() {\r",
											"    // Online Javascript Editor for free\r",
											"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
											"    var today = new Date();\r",
											"    var dd = String(today.getDate()).padStart(2, '0');\r",
											"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
											"    var yyyy = today.getFullYear();\r",
											"    var h = addZero(today.getHours(), 2);\r",
											"    var m = addZero(today.getMinutes(), 2);\r",
											"    var s = addZero(today.getSeconds(), 2);\r",
											"    var ms = addZero(today.getMilliseconds(), 6);\r",
											"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
											"    var time = \"00:00:00.000000\"\r",
											"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';\r",
											"    //console.log(today)\r",
											"    return today; // The function returns the product of p1 and p2\r",
											"}\r",
											"\r",
											"try {\r",
											"    // verify status code\r",
											"    pm.test(\"Test Response Status Code\", function () {\r",
											"        if(pm.response.code !== 200){\r",
											"            //Not found offline products and array is empty.\r",
											"            postman.setNextRequest(\"LTA Get Online Products\");\r",
											"            console.log(\"Set next request to: 'LTA Get Online Products' .\");\r",
											"        }\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"    \r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"    // find online product\r",
											"    const online_product = jsonDataElements.find(m => m.Online === true);\r",
											"    \r",
											"    if (!jsonDataElements.length || online_product) {\r",
											"        //Not found offline products and array is empty.\r",
											"        postman.setNextRequest(\"LTA Get Online Products\");\r",
											"        console.log(\"Set next request to: 'LTA Get Online Products' .\");\r",
											"\t} else {\r",
											"        //MIN number of Records Test\r",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"        pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"        });\r",
											"\r",
											"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
											"        const sizeLimit = 80000000;\r",
											"\r",
											"        for (let i = 0; i < jsonDataElements.length; i++) {\r",
											"            //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
											"            if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {\r",
											"                randomItems = jsonDataElements[i];\r",
											"                console.log(\"Product found! \");\r",
											"                break;\r",
											"            }\r",
											"        }\r",
											"\r",
											"        console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
											"        //console.log(randomItems);\r",
											"\r",
											"        pm.test(\"Test Properties for product: \" + randomItems['Id'], function () {\r",
											"            pm.expect(randomItems).to.have.property(\"Id\");\r",
											"            pm.expect(randomItems.Id).to.be.a(\"string\");\r",
											"            pm.expect(randomItems).to.have.property(\"Name\");\r",
											"            pm.expect(randomItems.Name).to.be.a(\"string\");\r",
											"            pm.expect(randomItems).to.have.property(\"ContentType\");\r",
											"            pm.expect(randomItems.ContentType).to.be.a(\"string\");\r",
											"            pm.expect(randomItems).to.have.property(\"ContentLength\");\r",
											"            pm.expect(randomItems.ContentLength).to.be.a(\"number\");\r",
											"            pm.expect(randomItems).to.have.property(\"OriginDate\");\r",
											"            pm.expect(randomItems.OriginDate).to.be.a(\"string\");\r",
											"            pm.expect(randomItems).to.have.property(\"PublicationDate\");\r",
											"            pm.expect(randomItems.PublicationDate).to.be.a(\"string\");\r",
											"            pm.expect(randomItems).to.have.property(\"ModificationDate\");\r",
											"            pm.expect(randomItems.ModificationDate).to.be.a(\"string\");\r",
											"            pm.expect(randomItems).to.have.property(\"Online\");\r",
											"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
											"            pm.expect(randomItems).to.have.property(\"Checksum\");\r",
											"            pm.expect(randomItems.Checksum).to.be.an(\"array\");\r",
											"            pm.expect(randomItems).to.have.property(\"ContentDate\");\r",
											"            pm.expect(randomItems.ContentDate).to.be.an(\"object\");\r",
											"        });\r",
											"\r",
											"        // verify online status\r",
											"        pm.test(\"Test Online status: \" + randomItems.Online , function () {\r",
											"            pm.expect(randomItems).to.have.property(\"Online\");\r",
											"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
											"            pm.expect(randomItems.Online).to.eq(false);\r",
											"        });\r",
											"\r",
											"        console.log(\"Product online status is: \" + randomItems.Online);\r",
											"        pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
											"        pm.globals.set('ProductId', randomItems.Id);\r",
											"        pm.globals.set('ProductName', randomItems.Name);\r",
											"        pm.globals.set('ContentLength', randomItems.ContentLength);\r",
											"    }\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"//pm.globals.unset(\"download_counter\");"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										},
										{
											"key": "$filter",
											"value": "(Online eq false) and {{ProductTypeCode}}"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Order",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
											"    console.warn(\"Sending request as administrator!\");\r",
											"    postman.setNextRequest(null);       \r",
											"}   "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"properties_map = {};\r",
											"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
											"properties_map.Status = function (element) {\r",
											"    pm.expect(element.Status).to.be.a(\"string\");\r",
											"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
											"};\r",
											"properties_map.StatusMessage=function (element) {\r",
											"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
											"};\r",
											"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
											"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
											"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
											"\r",
											"function propertySpecific(key, order){\r",
											"    if (properties_map[key]) {\r",
											"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
											"            properties_map[key](order);\r",
											"            pm.expect(pm.response.text()).to.include(key);});\r",
											"    }\r",
											"    else {\r",
											"        console.warn(\"Skipped Test Property \"+key+\" for Order: \" + order[key]);\r",
											"    }\r",
											"}\r",
											"\r",
											"try {\r",
											"\r",
											"    pm.test(\"Test Response Status Code\", function () {\r",
											"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json();\r",
											"    //test property for order\r",
											"    var order = jsonDataElements;\r",
											"\r",
											"    for (const [key, value] of Object.entries(properties_map)) {\r",
											"        propertySpecific(key, order);\r",
											"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
											"    }\r",
											"    \r",
											"    postman.setNextRequest(null);\r",
											"\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"Priority\": {{OrderPriority}}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/OData.CSC.Order",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})",
										"OData.CSC.Order"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Get Online Products",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function addZero(x, n) {\r",
											"    while (x.toString().length < n) {\r",
											"        x = \"0\" + x;\r",
											"    }\r",
											"    return x;\r",
											"}\r",
											"\r",
											"function GetCurrentDate() {\r",
											"    // Online Javascript Editor for free\r",
											"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
											"    var today = new Date();\r",
											"    var dd = String(today.getDate()).padStart(2, '0');\r",
											"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
											"    var yyyy = today.getFullYear();\r",
											"    var h = addZero(today.getHours(), 2);\r",
											"    var m = addZero(today.getMinutes(), 2);\r",
											"    var s = addZero(today.getSeconds(), 2);\r",
											"    var ms = addZero(today.getMilliseconds(), 6);\r",
											"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
											"    var time = \"00:00:00.000000\"\r",
											"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';\r",
											"    //console.log(today)\r",
											"    return today; // The function returns the product of p1 and p2\r",
											"}\r",
											"\r",
											"try {\r",
											"\r",
											"    pm.test(\"Test Response Status Code\", function () {\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"\r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"\r",
											"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
											"    const sizeLimit = 80000000;\r",
											"\r",
											"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
											"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
											"        if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {\r",
											"            randomItems = jsonDataElements[i];\r",
											"            console.log(\"Product found! \");\r",
											"            break;\r",
											"        }\r",
											"    }\r",
											"\r",
											"    pm.test(\"Test Id for product: \" + randomItems.Id, function () {\r",
											"        pm.expect(randomItems).to.have.property(\"Id\");\r",
											"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
											"    });\r",
											"\r",
											"    pm.test(\"Test Online status: \" + randomItems.Online, function () {\r",
											"        pm.expect(randomItems).to.have.property(\"Online\");\r",
											"        pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
											"        pm.expect(randomItems.Online).to.eq(true);\r",
											"    });\r",
											"\r",
											"    console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
											"    //console.log(randomItems);\r",
											"    console.log(\"Product online status is: \" + randomItems.Online);\r",
											"    pm.globals.set('ProductId', randomItems.Id);\r",
											"    pm.globals.set('ProductName', randomItems.Name);\r",
											"    pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
											"\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"//pm.globals.unset(\"download_counter\");"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq true) and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										},
										{
											"key": "$filter",
											"value": "(Online eq true) and {{ProductTypeCode}}"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if(pm.environment.get('execute_admin_requests') == \"true\"){",
									"    console.warn(\"Unable to send request as administrator!\")",
									"    postman.setNextRequest(null);       ",
									"}   "
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "LTA Product Download (Minimum Compliance)",
					"item": [
						{
							"name": "LTA Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"\r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json();",
											"    var id = pm.globals.get(\"ProductId\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Test product id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"    });",
											"",
											"    pm.test(\"Test online status: \" + jsonDataElements.Online, function(){",
											"        pm.expect(jsonDataElements).to.have.property(\"Online\");",
											"        pm.expect(jsonDataElements.Online).to.be.a(\"boolean\");",
											"        //check the product status",
											"        console.log(\"Product: \" + jsonDataElements.Name + \" Online=\" + jsonDataElements.Online);",
											"    });",
											"    ",
											"    // Check the product status",
											"    // If product is online (online status = true) than it is available for download.",
											"    // If product is offline the request is sent again.",
											"    console.log(\"Product: \" + jsonDataElements.Name + \" Online=\" + jsonDataElements.Online);",
											"    pm.globals.set(\"OnlineStatus\",jsonDataElements.Online.toString());",
											"",
											"    if(jsonDataElements.Online !== true){",
											"            //Not found offline products and array is empty.",
											"            postman.setNextRequest(null);",
											"            console.log(\"Product is offline!\");",
											"            pm.globals.set(\"DownloadStatus\", \"not_completed\");",
											"    }",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test Product Details\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Download",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"try {\r",
											"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    \r",
											"    //console.log(pm.response);\r",
											"\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200,202,206]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Downloaded Size\", function(){\r",
											"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
											"    });\r",
											"    pm.globals.set(\"DownloadStatus\", \"completed\");\r",
											"\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"protocolProfileBehavior": {
								"followAuthorizationHeader": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/$value",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})",
										"$value"
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if(!pm.globals.get('OnlineStatus')){",
									"       postman.setNextRequest(null); ",
									"   }  "
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				}
			],
			"description": "The purpose of \"**Long Term Archive ICD_v1.9\"** is to specify the interfaces of the Long Term Archive (LTA) and describe the test suite which may be performed using the Postman collection.",
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });",
							"",
							"",
							"",
							"",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "LTA Extended Compliance",
			"item": [
				{
					"name": "LTA Products",
					"item": [
						{
							"name": "LTA Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"\r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Products Listing Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonData = pm.response.json();",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test ",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    //console.log(randomItems);",
											"",
											"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
											"    pm.test(\"Products Name: \" + randomItems[\"Name\"], function (){",
											"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ProductName\",randomItems[\"Name\"]);",
											"    });",
											"",
											"    pm.test(\"Products Id: \" + randomItems[\"Id\"], function (){",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); ",
											"        pm.globals.set(\"ProductId\",randomItems[\"Id\"])",
											"    });",
											"",
											"    pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function (){",
											"        pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ContentType\",randomItems[\"ContentType\"])",
											"    });",
											"",
											"    pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function (){",
											"        pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"           pm.globals.set(\"ContentLength\",randomItems[\"ContentLength\"])",
											"    });",
											"",
											"    pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function (){",
											"        pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"OriginDate\",randomItems[\"OriginDate\"])",
											"    });",
											"",
											"    pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function (){",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"PublicationDate\",randomItems[\"PublicationDate\"])",
											"    });",
											"",
											"    pm.test(\"Modification date: \" + randomItems[\"ModificationDate\"], function (){",
											"        pm.expect(randomItems[\"ModificationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"ModificationDate\",randomItems[\"ModificationDate\"])",
											"           //console.log(\"ModificationDate of the last product: \" + jsonDataElements[n][\"ModificationDate\"]);",
											"    });",
											"    ",
											"    pm.test(\"Online: \" + randomItems[\"Online\"], function (){",
											"        pm.expect(randomItems[\"Online\"]).to.be.a(\"boolean\");",
											"        pm.globals.set(\"OnlineStatus\",randomItems[\"Online\"].toString());",
											"        ",
											"    });",
											"",
											"    if(randomItems[\"Online\"] == true){",
											"        pm.test(\"Eviction date: \" + randomItems[\"EvictionDate\"], function (){",
											"        pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"EvictionDate\",randomItems[\"EvictionDate\"])",
											"        });",
											"    }",
											"",
											"    pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function (){",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumAlgorithm\",randomItems[\"Checksum\"][0][\"Algorithm\"])",
											"    });",
											"    ",
											"    pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function (){",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumValue\",randomItems[\"Checksum\"][0][\"Value\"])",
											"           //console.log(\"Checksum value of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"Value\"]);",
											"    });",
											"    ",
											"    pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function (){",
											"           pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"           pm.globals.set(\"ChecksumDate\",randomItems[\"Checksum\"][0][\"ChecksumDate\"])",
											"           //console.log(\"ChecksumDate of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"ChecksumDate\"]);",
											"    });",
											"    ",
											"    pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function (){",
											"        pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"Start\",randomItems[\"ContentDate\"][\"Start\"]);",
											"    });",
											"",
											"    pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function (){",
											"        pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"End\",randomItems[\"ContentDate\"][\"End\"]);",
											"    });",
											"",
											"    if (randomItems[\"Footprint\"]) {",
											"        pm.test(\"Footprint: \" + randomItems[\"Footprint\"], function (){",
											"        pm.expect(randomItems[\"Footprint\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"Footprint\",randomItems[\"Footprint\"]);",
											"        }); ",
											"    }",
											"    else {",
											"        console.warn(\"Not found Footprint: \" + randomItems.Name);",
											"        pm.globals.set(\"Footprint\", undefined);",
											"    }",
											"",
											"    if (randomItems[\"GeoFootprint\"]) {",
											"        let geofootprint_coordinates_array = randomItems[\"GeoFootprint\"][\"coordinates\"];",
											"        let geofootprint_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"        let geofootprint_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"        pm.test('GeoFootprint:{\"type\": ' + geofootprint_type + ', \"coordinates\": [' + geofootprint_coordinates_array + ']}', function (){",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"           pm.globals.set(\"GeoFootprintCoordinates\",geofootprint_coordinates);",
											"           pm.globals.set(\"GeoFootprintType\",geofootprint_type);",
											"        }); ",
											"    }",
											"    else {",
											"        console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"        pm.globals.set(\"GeoFootprint\", undefined);",
											"    }   ",
											"",
											"    var len_array = randomItems[\"Name\"].split('.').length",
											"    pm.globals.set(\"StartStringName\",randomItems[\"Name\"].split('_')[0] + '_' + randomItems[\"Name\"].split('_')[1])",
											"    pm.globals.set(\"EndStringName\",randomItems[\"Name\"].split('.')[len_array-1])",
											"    pm.globals.set(\"StringName\",randomItems[\"Name\"].split('_')[2])",
											"    pm.globals.set(\"StringName2\",randomItems[\"Name\"].split('_')[3])",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('2')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('2','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('2','1'));",
											"        }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('1')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('1','2'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('1','2'));",
											"        }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('3')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('3','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('3','1'));",
											"        }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('5')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('5','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('5','1'));",
											"",
											"        }",
											"",
											"    var randomItems1 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems2 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems3 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"",
											"    pm.globals.set(\"product1\",randomItems1[\"Name\"])",
											"    pm.globals.set(\"product2\",randomItems2[\"Name\"])",
											"    pm.globals.set(\"product3\",randomItems3[\"Name\"])",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test Product Listing\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Name",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        //var name = pm.globals.get(\"ProductName\");",
											"        //pm.expect(pm.response.text()).to.includes(name); ",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const product_name = pm.globals.get(\"ProductName\");\r",
											"const name = \"Name eq '\" + product_name + \"'\";\r",
											"const contains_string = \"contains(Name,'_\" + product_name.split('_')[1] + '_' +product_name.split('_')[2] + \"_\" + product_name.split('_')[3] + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + product_name.split('_')[0] + \"_\" + product_name.split('_')[1] + \"')\";\r",
											"    \r",
											"var len_array = product_name.split('.').length;\r",
											"const end_string = \"endswith(Name,'\" + product_name.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"let StringObjects = [name,contains_string,start_string,end_string];\r",
											"var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",itemStringObjects);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{QueryByNameString}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Publication Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"StartPublicationDate\");",
											"    var prop_name = \"PublicationDate\";",
											"    pm.test(\"PublicationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"  date.setDate(date.getDate() + days);\r",
											"\r",
											"  return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"\r",
											"const start_date = new Date(publication_date);\r",
											"const StartNewDate =  addDays(start_date, -5);\r",
											"const end_date = new Date(publication_date);\r",
											"const EndNewDate = addDays(end_date, 5);\r",
											"\r",
											"pm.globals.set(\"StartPublicationDate\",StartNewDate);\r",
											"pm.globals.set(\"EndPublicationDate\",EndNewDate);\r",
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=PublicationDate gt {{StartPublicationDate}} and PublicationDate lt {{EndPublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate gt {{StartPublicationDate}} and PublicationDate lt {{EndPublicationDate}}",
											"description": "Simple Property PublicationDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Sensing Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    }); ",
											"    //test property",
											"    var date = pm.globals.get(\"Start\");",
											"    var prop_name = \"ContentDate\";",
											"    pm.test(\"Sensing Date: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name][\"Start\"])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
											"description": "Complex Property ContentDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By OriginDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"OriginDate\");",
											"    var prop_name = \"OriginDate\";",
											"    pm.test(\"OriginDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OriginDate ge {{OriginDate}} and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OriginDate ge {{OriginDate}} and {{ProductTypeCode}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Modification",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"     ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"ModificationDate\");",
											"    var prop_name = \"ModificationDate\";",
											"    pm.test(\"ModificationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(!pm.globals.get(\"Footprint\") && !pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"LTA Product Query By Size\");\r",
											"    }\r",
											"\r",
											"if(!pm.globals.get(\"Footprint\") && pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"LTA Product Query By Geographic Criteria (GeoFootprint)\");\r",
											"    }"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ModificationDate ge {{ModificationDate}} and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ModificationDate ge {{ModificationDate}} and {{ProductTypeCode}}",
											"description": "Complex Property ContentDate"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Geographic Criteria (Footprint)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"    //test property",
											"    var id = pm.globals.get(\"ProductId\");",
											"    const result = jsonDataElements.find(m => m.Id === id);",
											"",
											"    pm.test(\"Footprint\", function(){",
											"        pm.expect(id).to.equal(result.Id);",
											"    });",
											"               ",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(!pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"LTA Product Query By Size\");\r",
											"    }"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OData.CSC.Intersects(area={{Footprint}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OData.CSC.Intersects(area={{Footprint}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$count",
											"value": "true",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Geographic Criteria (GeoFootprint)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    //test property",
											"    var id = pm.globals.get(\"ProductId\");",
											"    const result = jsonDataElements.find(m => m.Id === id);",
											"",
											"    pm.test(\"GeoFootprint\", function(){",
											"        pm.expect(id).to.equal(result.Id);",
											"    });",
											"",
											"               ",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"var geofoot_coordinates = pm.globals.get(\"GeoFootprintCoordinates\");\r",
											"// provide geofootprint string\r",
											"if (geofoot_coordinates) { \r",
											"    var geofoot_type = pm.globals.get(\"GeoFootprintType\");\r",
											"    let geofoot = '';\r",
											"    for (let i = 0; i < geofoot_coordinates.length; i++) {\r",
											"        if(i !== geofoot_coordinates.length-1){\r",
											"            geofoot += String(geofoot_coordinates[i]).replace(',', ' ') + ',';\r",
											"        }else{\r",
											"            geofoot += String(geofoot_coordinates[i]).replace(',', ' ');\r",
											"        }  \r",
											"    }\r",
											"    let geofoot_string = [\"geography'SRID=4326;\", String(geofoot_type), \"((\", String(geofoot), \"))'\"].join('');\r",
											"    pm.globals.set(\"GeoFootprintSearchString\",geofoot_string);\r",
											"    \r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OData.CSC.Intersects(area={{GeoFootprintSearchString}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "PublicationDate desc",
											"disabled": true
										},
										{
											"key": "$count",
											"value": "true",
											"disabled": true
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$filter",
											"value": "OData.CSC.Intersects(area={{GeoFootprintSearchString}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Size",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    // check status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    //test property",
											"    var prop_name = \"ContentLength\";",
											"    pm.test(\"ContentLength: \" + jsonDataElements[0][prop_name], function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(parseInt(pm.globals.get(prop_name))).to.equal(item[prop_name]);",
											"        }",
											"    });",
											"     ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name , function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "",
										"value": "",
										"type": "default",
										"disabled": true
									}
								],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentLength eq {{ContentLength}} and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentLength eq {{ContentLength}} and {{ProductTypeCode}}",
											"description": "Size property"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json();",
											"    var id = pm.globals.get(\"ProductId\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Test product id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"        //check the product status",
											"        console.log(\"Product: \" + jsonDataElements.Name + \" Online=\" + jsonDataElements.Online);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test Product Details\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
											"       postman.setNextRequest(\"LTA Product Attributes Expand Query\"); \r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Query by List",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											" ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\"FilterProducts\":[\r\n\t{\"Name\": \"{{product1}}\"},\r\n    {\"Name\": \"{{product2}}\"},\r\n    {\"Name\": \"{{product3}}\"}\r\n]}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products/OData.CSC.FilterList",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products",
										"OData.CSC.FilterList"
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Attributes Expand Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function propertySpecific(key, attr, items) {",
											"    const ProductObject = items.Attributes.find(m => m.Name === attr[key]);",
											"    //console.log(ProductObject);",
											"    if (ProductObject !== undefined) {",
											"        pm.test(\"Response body contains \" + attr[key], function() {",
											"            pm.expect(ProductObject).not.eq(undefined);",
											"            pm.expect(ProductObject.Name).to.be.a(\"string\");",
											"            pm.expect(ProductObject.ValueType).to.be.a(\"string\");",
											"            pm.expect(ProductObject.Value).not.eq(undefined)",
											"            pm.globals.set(ProductObject.Name, ProductObject.Value);",
											"            pm.globals.set(\"flag_\" + ProductObject.Name, \"true\");",
											"        });",
											"    } else {",
											"        console.warn(\"Skipped \" + attr[key] + \" attribute test\");",
											"    }",
											"}",
											"// attributes",
											"const elements_s1 = [\"beginningDateTime\", \"endingDateTime\", \"startTimeFromAscendingNode\", \"completionTimeFromAscendingNode\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"operationalMode\", \"polarisationChannels\", \"orbitNumber\", \"relativeOrbitNumber\", \"cycleNumber\", \"orbitDirection\", \"coordinates\", \"productType\", \"productClass\", \"productConsolidation\", \"instrumentConfigurationID\", \"datatakeID\", \"sliceProductFlag\"];",
											"",
											"const elements_s1_aux = [\"processingDate\", \"processingCenter\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"beginningDateTime\", \"productGeneration\", \"instrumentConfigurationID\"];",
											"",
											"const elements_s2 = [\"productGroupId\", \"processorVersion\", \"processingDate\", \"beginningDateTime\", \"endingDateTime\", \"orbitNumber\", \"coordinates\", \"qualityStatus\", \"productType\", \"instrumentShortName\", \"processingCenter\", \"platformSerialIdentifier\", \"platformShortName\", \"operationalMode\", \"relativeOrbitNumber\"]",
											"",
											"const elements_s2_aux = [\"platformShortName\", \"platformSerialIdentifier\", \"productType\", \"beginningDateTime\", \"endingDateTime\", \"processingCenter\", \"processorVersion\", \"processingDate\"];",
											"",
											"const elements_s3 = [\"beginningDateTime\", \"endingDateTime\", \"instrumentShortName\", \"productType\", \"timeliness\", \"orbitNumber\", \"lastOrbitNumber\", \"relativeOrbitNumber\", \"cycleNumber\", \"processorName\"];",
											"",
											"const elements_s3_aux = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"const elements_pod = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        if (pm.response.code !== 200) {",
											"            postman.setNextRequest(\"LTA Additional Options (orderby asc)\");",
											"        }",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    // check body response format",
											"    pm.globals.set('headers-format', pm.response.headers.get('Content-Type'));",
											"    const header_format = pm.globals.get('headers-format');",
											"    const format = \"application/json\"",
											"    const zip_format = \"application/zip\"",
											"",
											"    pm.test(\"Content-Type header is correct\", function() {",
											"        if (header_format.includes(zip_format)) {",
											"            pm.expect(header_format).to.includes(zip_format);",
											"            console.warn(\"The Content-Type header is \" + header_format);",
											"            console.warn(\"The Attributes requests are skipped. \");",
											"            postman.setNextRequest(\"LTA Additional Options (orderby asc)\");",
											"        } else {",
											"",
											"            if (!header_format.includes(format)) {",
											"                console.warn(\"The Content-Type header is \" + header_format);",
											"                console.warn(\"The Attributes requests are skipped. \");",
											"                postman.setNextRequest(\"LTA Additional Options (orderby asc)\")",
											"            }",
											"",
											"            pm.expect(header_format).to.includes(format);",
											"        }",
											"    });",
											"",
											"    if (header_format.includes(format)) {",
											"        var jsonDataElements = pm.response.json().value;",
											"",
											"        // extract the attributes for the next subsequent tests",
											"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems1 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems2 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"",
											"        let productTypeObject1 = randomItems1.Attributes.find(m => m.Name === \"productType\");",
											"        let productTypeObject2 = randomItems2.Attributes.find(m => m.Name === \"productType\");",
											"",
											"        if (productTypeObject1) {",
											"            pm.globals.set(\"productType2\", productTypeObject1[\"Value\"]);",
											"        }",
											"        if (productTypeObject2) {",
											"            pm.globals.set(\"productType3\", productTypeObject2[\"Value\"]);",
											"        }",
											"",
											"        var found_element;",
											"        var name = randomItems.Name",
											"",
											"        if (name.startsWith('S1') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s1;",
											"        } else if (name.startsWith('S1') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s1_aux;",
											"        } else if (name.startsWith('S2') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s2;",
											"        } else if (name.startsWith('S2') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s2_aux;",
											"        } else if (name.startsWith('S3') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s3;",
											"        } else if (name.startsWith('S3') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s3_aux;",
											"        } else {",
											"            found_element = elements_pod;",
											"        }",
											"",
											"        // check properties",
											"        pm.test(\"Products Name: \" + randomItems[\"Name\"], function() {",
											"            pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Products Id: \" + randomItems[\"Id\"], function() {",
											"            pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        });",
											"",
											"        pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function() {",
											"            pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function() {",
											"            pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"        });",
											"",
											"        pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function() {",
											"            pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function() {",
											"            pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Modification date: \" + randomItems[\"ModificationDate\"], function() {",
											"            pm.expect(randomItems[\"ModificationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            //console.log(\"ModificationDate of the last product: \" + jsonDataElements[n][\"ModificationDate\"]);",
											"        });",
											"",
											"        pm.test(\"Online: \" + randomItems[\"Online\"], function() {",
											"            pm.expect(randomItems[\"Online\"]).to.be.a(\"boolean\");",
											"        });",
											"",
											"        if (randomItems[\"Online\"] == true) {",
											"            pm.test(\"Eviction date: \" + randomItems[\"EvictionDate\"], function() {",
											"                pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            });",
											"        }",
											"",
											"        pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        if (randomItems[\"Footprint\"]) {",
											"            pm.test(\"Footprint: \" + randomItems[\"Footprint\"], function() {",
											"                pm.expect(randomItems[\"Footprint\"]).to.be.a(\"string\");",
											"            });",
											"        } else {",
											"            console.warn(\"Not provided Footprint for product: \" + randomItems.Name);",
											"        }",
											"",
											"        if (randomItems[\"GeoFootprint\"]) {",
											"            let geofootprint_coordinates_array = randomItems[\"GeoFootprint\"][\"coordinates\"];",
											"            let geofootprint_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"            let geofootprint_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"            pm.test('GeoFootprint:{\"type\": ' + geofootprint_type + ', \"coordinates\": [' + geofootprint_coordinates_array + ']}', function() {",
											"                pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"                pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"                pm.globals.set(\"GeoFootprintCoordinates\", geofootprint_coordinates);",
											"                pm.globals.set(\"GeoFootprintType\", geofootprint_type);",
											"            });",
											"        } else {",
											"            console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"            pm.globals.set(\"GeoFootprint\", undefined);",
											"        }",
											"",
											"        // Test that the correct odata context is returned",
											"        console.log(\"Test that the correct attributes are returned for product: \" + name);",
											"        for (var key in found_element) {",
											"            propertySpecific(key, found_element, randomItems);",
											"        }",
											"",
											"        const processor_version = randomItems.Attributes.find(m => m.Name === \"processorVersion\");",
											"        if (processor_version !== undefined) {",
											"            //console.log(processor_version);",
											"            pm.globals.set(processor_version.Name, processor_version.Value);",
											"            pm.globals.set(\"flag_processorVersion\", \"true\");",
											"        }",
											"    }",
											"",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"  date.setDate(date.getDate() + days);\r",
											"\r",
											"  return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"\r",
											"const start_date = new Date(publication_date);\r",
											"const StartNewDate =  addDays(start_date, -30);\r",
											"\r",
											"\r",
											"pm.globals.set(\"StartPublicationDate\",StartNewDate);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}&$expand=Attributes&$format=json&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}"
										},
										{
											"key": "$expand",
											"value": "Attributes"
										},
										{
											"key": "$format",
											"value": "json"
										},
										{
											"key": "$top",
											"value": "100"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (InstrumentShortName)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_instrumentShortName\") === \"true\") {",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (operationalMode)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_operationalMode\") === \"true\") {",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"   console.warn(\"Skipped \" + request.name);",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'operationalMode' and att/OData.CSC.StringAttribute/Value eq '{{operationalMode}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'operationalMode' and att/OData.CSC.StringAttribute/Value eq '{{operationalMode}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (orbitNumber)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_orbitNumber\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}}) and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}}) and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (processingDate)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_processingDate\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}}) and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}}) and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (productGroupId)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_productGroupId\") === \"true\") {",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productGroupId' and att/OData.CSC.StringAttribute/Value eq '{{productGroupId}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productGroupId' and att/OData.CSC.StringAttribute/Value eq '{{productGroupId}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (datastripId)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_datastripId\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'datastripId' and att/OData.CSC.StringAttribute/Value eq '{{datastripId}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'datastripId' and att/OData.CSC.StringAttribute/Value eq '{{datastripId}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (tileId)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_tileId\") === \"true\") {",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'tileId' and att/OData.CSC.StringAttribute/Value eq '{{tileId}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'tileId' and att/OData.CSC.StringAttribute/Value eq '{{tileId}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (qualityStatus)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_qualityStatus\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'qualityStatus' and att/OData.CSC.StringAttribute/Value eq '{{qualityStatus}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'qualityStatus' and att/OData.CSC.StringAttribute/Value eq '{{qualityStatus}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (cloudCover)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_cloudCover\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DoubleAttribute/any(att:att/Name eq 'cloudCover' and att/OData.CSC.DoubleAttribute/Value eq {{cloudCover}}) and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DoubleAttribute/any(att:att/Name eq 'cloudCover' and att/OData.CSC.DoubleAttribute/Value eq {{cloudCover}}) and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (productClass)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_productClass\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productClass' and att/OData.CSC.StringAttribute/Value eq '{{productClass}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productClass' and att/OData.CSC.StringAttribute/Value eq '{{productClass}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (timeliness)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_timeliness\") === \"true\") {",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											"",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (combining productType and processorVersion)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_productType\") === \"true\" && pm.globals.get(\"flag_processorVersion\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Product Query By Attributes (combining platformShortName & platformSerialIdentifier)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_platformShortName\") === \"true\" && pm.globals.get(\"flag_platformSerialIdentifier\") === \"true\") {",
											"    try {",
											"",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function () {",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function () {",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"    } catch (err) {",
											"        pm.test(request.name, function () {",
											"            pm.expect.fail(err.toString());",
											"        });",
											"    }",
											"} else {",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											"",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}') and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}') and {{ProductTypeCode}}",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Additional Options (orderby asc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"   ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyAsc}} asc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyAsc}} asc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Additional Options (orderby desc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyDesc}} desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}} desc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Additional Options (top)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$top={{top}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$top",
											"value": "{{top}}",
											"description": "Specify the maximum (non-negative integer) number of items returned"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Additional Options (skip)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"  ",
											"try {",
											" ",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$skip={{skip}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$skip",
											"value": "{{skip}}",
											"description": "Specify a (non-negative integer) number of items excluded from the start"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "LTA Additional Options (count)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"    // verify that the number of the matching resources is returned as result.",
											"    var data_counter = pm.response.json()[\"@odata.count\"];",
											"    pm.test(\"The number of the matching resources is returned: \" + data_counter, function(){",
											"        pm.expect(data_counter).to.be.a(\"number\");",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$count=true&$filter=startswith(Name,'{{StartStringName}}') and PublicationDate ge {{PublicationDate}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$count",
											"value": "true",
											"description": "Request a count of the matching resources"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}') and PublicationDate ge {{PublicationDate}}"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "LTA Orders (all cases)",
					"item": [
						{
							"name": "LTA Orders",
							"item": [
								{
									"name": "LTA Create Order",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Offline Products",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"    while (x.toString().length < n) {\r",
															"        x = \"0\" + x;\r",
															"    }\r",
															"    return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today; // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        if(pm.response.code !== 200){\r",
															"            //Not found offline products and array is empty.\r",
															"            postman.setNextRequest(\"LTA Get Online Products\");\r",
															"            console.log(\"Set next request to: 'LTA Get Online Products' .\");\r",
															"        } \r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]); \r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    // find online product\r",
															"    const online_product = jsonDataElements.find(m => m.Online === true);\r",
															"\r",
															"    if (!jsonDataElements.length || online_product) {\r",
															"        //Not found offline products and array is empty.\r",
															"        postman.setNextRequest(\"LTA Get Online Products\");\r",
															"        console.log(\"Set next request to: 'LTA Get Online Products' .\")\r",
															"    } else {\r",
															"        //MIN number of Records Test\r",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"        pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
															"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        });\r",
															"\r",
															"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
															"        const sizeLimit = 80000000;\r",
															"\r",
															"        for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"            //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"            if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {\r",
															"                randomItems = jsonDataElements[i];\r",
															"                console.log(\"Product found! \");\r",
															"                break;\r",
															"            }\r",
															"        }\r",
															"\r",
															"        console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
															"        console.log(randomItems);\r",
															"\r",
															"        pm.test(\"Test Properties for product: \" + randomItems['Id'], function () {\r",
															"            pm.expect(randomItems).to.have.property(\"Id\");\r",
															"            pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"Name\");\r",
															"            pm.expect(randomItems.Name).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"ContentType\");\r",
															"            pm.expect(randomItems.ContentType).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"ContentLength\");\r",
															"            pm.expect(randomItems.ContentLength).to.be.a(\"number\");\r",
															"            pm.expect(randomItems).to.have.property(\"OriginDate\");\r",
															"            pm.expect(randomItems.OriginDate).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"PublicationDate\");\r",
															"            pm.expect(randomItems.PublicationDate).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"ModificationDate\");\r",
															"            pm.expect(randomItems.ModificationDate).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"Online\");\r",
															"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(randomItems).to.have.property(\"Checksum\");\r",
															"            pm.expect(randomItems.Checksum).to.be.an(\"array\");\r",
															"            pm.expect(randomItems).to.have.property(\"ContentDate\");\r",
															"            pm.expect(randomItems.ContentDate).to.be.an(\"object\");\r",
															"        });\r",
															"        \r",
															"        // verify online status\r",
															"        pm.test(\"Test online status: \" + randomItems.Online, function () {\r",
															"            pm.expect(randomItems).to.have.property(\"Online\");\r",
															"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(randomItems.Online).to.eq(false);\r",
															"        });\r",
															"\r",
															"        console.log(\"Product online status is: \" + randomItems.Online);\r",
															"        pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
															"        pm.globals.set('ProductId', randomItems.Id);\r",
															"        pm.globals.set('ProductName', randomItems.Name);\r",
															"        pm.globals.set('ContentLength', randomItems.ContentLength);\r",
															"        \r",
															"    }\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{ProductTypeCode}}&$top=100",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq false) and {{ProductTypeCode}}"
														},
														{
															"key": "$top",
															"value": "100"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Order",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"\r",
															"    for (const [key, value] of Object.entries(properties_map)) {\r",
															"        propertySpecific(key, order);\r",
															"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{OrderPriority}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{ProductId}})",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    // check order properties\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test Properties for Order: \" + randomItems.Id, function(){\r",
															"        pm.expect(randomItems).to.have.property(\"Id\");\r",
															"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"Status\");\r",
															"        pm.expect(randomItems.Status).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"StatusMessage\");\r",
															"        pm.expect(randomItems.StatusMessage).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"SubmissionDate\");\r",
															"        pm.expect(randomItems.SubmissionDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"EstimatedDate\");\r",
															"        pm.expect(randomItems.EstimatedDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems.Priority).to.be.a(\"number\");\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$top",
															"value": "10",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order Id Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"    //test id order\r",
															"    var id = pm.globals.get(\"OrderId\");\r",
															"    console.log(\"Order Id is: \" + id);\r",
															"    pm.test(\"Order Id: \" + id, function(){\r",
															"        pm.expect(jsonDataElements.Id).to.be.eql(id);\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order SubmissionDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    //current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    //test property\r",
															"    var date = pm.globals.get(\"OrderSubmissionDate\");\r",
															"    var prop_name = \"SubmissionDate\";\r",
															"    pm.test(\"SubmissionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=SubmissionDate ge {{OrderSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate ge {{OrderSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order EstimatedDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){ \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test property\r",
															"    var date = pm.globals.get(\"OrderEstimatedDate\");\r",
															"    var prop_name = \"EstimatedDate\";\r",
															"    pm.test(\"EstimatedDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=EstimatedDate ge {{OrderEstimatedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EstimatedDate ge {{OrderEstimatedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order Priority Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var priority = pm.globals.get(\"OrderPriority\");\r",
															"    pm.test(\"Priority: \" + priority, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(item.Priority).to.equal(parseInt(priority)); \r",
															"        }\r",
															"    });\r",
															"    \r",
															"    postman.setNextRequest(null);\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Priority eq {{OrderPriority}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Priority eq {{OrderPriority}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Online Products",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"    while (x.toString().length < n) {\r",
															"        x = \"0\" + x;\r",
															"    }\r",
															"    return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today; // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
															"    const sizeLimit = 80000000;\r",
															"\r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"        if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found! \");\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"\r",
															"    pm.test(\"Test Id for product: \" + randomItems.Id, function () {\r",
															"        pm.expect(randomItems).to.have.property(\"Id\");\r",
															"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test Online status for product: \" + randomItems.Online, function () {\r",
															"        pm.expect(randomItems).to.have.property(\"Online\");\r",
															"        pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"        pm.expect(randomItems.Online).to.eq(true);\r",
															"    });\r",
															"\r",
															"    console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
															"    console.log(randomItems);\r",
															"\r",
															"    console.log(\"Product online status is: \" + randomItems.Online);\r",
															"    pm.globals.set('ProductId', randomItems.Id);\r",
															"    pm.globals.set('ProductName', randomItems.Name);\r",
															"    pm.globals.set('ContentLength', randomItems.ContentLength);\r",
															"    pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq true) and {{ProductTypeCode}}&$top=100",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq true) and {{ProductTypeCode}}"
														},
														{
															"key": "$top",
															"value": "100"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Product Retrieval",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															"\r",
															"\r",
															"if(pm.globals.get(\"OnlineStatus\") == \"true\"){\r",
															"       postman.setNextRequest(\"LTA Product Download By ProductId\"); \r",
															"   }   "
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Completed Order Properties",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"\r",
															"properties_map.Id = function (element) {\r",
															"    pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);\r",
															"};\r",
															"\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"\r",
															"properties_map.StatusMessage = function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority = function (element) {\r",
															"    pm.expect(element.Priority).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EstimatedDate = function (element) {\r",
															"    pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"\r",
															"properties_map.OrderSize = function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.CompletedDate = function (element) {\r",
															"    pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EvictionDate = function (element) {\r",
															"    if (element.EvictionDate) {\r",
															"        pm.expect(element.EvictionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    }\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order) {\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \" + key + \" for Order: \" + order[key], function () {\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);\r",
															"        });\r",
															"    } else {\r",
															"        console.warn(\"Test Property \" + key + \" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value[0];\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"    pm.globals.set(\"OrderStatus\", order.Status);\r",
															"    console.log(\"Order status is: \" + order.Status);\r",
															"    if (order.Status == \"completed\") {\r",
															"        for (const[key, value]of Object.entries(properties_map)) {\r",
															"            propertySpecific(key, order);\r",
															"            pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"        }\r",
															"        pm.globals.set('CompletedOrderId', order.Id);\r",
															"        console.log(\"The product download can be requested ...\");\r",
															"    } else {\r",
															"        postman.setNextRequest(null);\r",
															"        console.warn(\"Skipped Test Property for Order in status: \" + order.Status);\r",
															"    }\r",
															"    pm.globals.set(\"DownloadStatus\", order.Status);\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "basic",
													"basic": [
														{
															"key": "password",
															"value": "{{password}}",
															"type": "string"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Id eq {{OrderId}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Id eq {{OrderId}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Orders Listing Query (status Completed)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function() {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function() {\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var current_order = jsonDataElements.find(m => m.Id === pm.globals.get(\"OrderId\"));\r",
															"    \r",
															"    console.log(\"Processing Order: \" + current_order.Id);\r",
															"\r",
															"    pm.test(\"Test Properties for Order: \" + current_order.Id, function() {\r",
															"        pm.expect(current_order).to.have.property(\"Id\");\r",
															"        pm.expect(current_order.Id).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"Status\");\r",
															"        pm.expect(current_order.Status).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"StatusMessage\");\r",
															"        pm.expect(current_order.StatusMessage).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"SubmissionDate\");\r",
															"        pm.expect(current_order.SubmissionDate).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"EstimatedDate\");\r",
															"        pm.expect(current_order.EstimatedDate).to.be.a(\"string\");\r",
															"        pm.expect(current_order.Priority).to.be.a(\"number\");\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function() {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Status eq OData.CSC.JobStatus'completed' and CompletedDate ge {{OrderCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'completed' and CompletedDate ge {{OrderCompletedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order Status Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var status = pm.globals.get(\"OrderStatus\");\r",
															"    var prop_name = \"Status\";\r",
															"    pm.test(\"Status: \" + status, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            //console.log(item[prop_name])\r",
															"            pm.expect(status).to.equal(item[prop_name]);\r",
															"        }\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Status eq OData.CSC.JobStatus'{{OrderStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'{{OrderStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order StatusMessage Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var status_mess = pm.globals.get(\"OrderStatusMessage\");\r",
															"    var prop_name = \"StatusMessage\";\r",
															"    pm.test(\"StatusMessage: \" + status_mess, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(status_mess).to.equal(item[prop_name]);\r",
															"        }\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=StatusMessage eq '{{OrderStatusMessage}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "StatusMessage eq '{{OrderStatusMessage}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order OrderSize Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){ \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var size = pm.globals.get(\"OrderOrderSize\");\r",
															"    var prop_name = \"OrderSize\";\r",
															"    pm.test(\"OrderSize: \" + size, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(parseInt(size)).to.equal(item[prop_name]); \r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=OrderSize eq {{OrderOrderSize}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "OrderSize eq {{OrderOrderSize}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order CompletedDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var date = pm.globals.get(\"OrderCompletedDate\");\r",
															"    var prop_name = \"CompletedDate\";\r",
															"    pm.test(\"CompletedDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });  \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=CompletedDate ge {{OrderCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "CompletedDate ge {{OrderCompletedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order EvictionDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test property\r",
															"    var date = pm.globals.get(\"OrderEvictionDate\");\r",
															"    var prop_name = \"EvictionDate\";\r",
															"    pm.test(\"EvictionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=EvictionDate ge {{OrderEvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate ge {{OrderEvictionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Online Product By Order",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    console.log(jsonDataElements[\"Online\"]);\r",
															"\r",
															"    pm.test(\"Product Property Online\", function(){\r",
															"        pm.expect(jsonDataElements[\"Online\"]).be.equal(true);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Eviction date: \" + jsonDataElements[\"EvictionDate\"], function (){\r",
															"        pm.expect(jsonDataElements[\"EvictionDate\"])\r",
															"        pm.globals.set(\"EvictionDate\",jsonDataElements[\"EvictionDate\"])\r",
															"    });\r",
															"\r",
															"    pm.globals.set('ProductId', jsonDataElements.Id);\r",
															"    pm.globals.set('ProductName', jsonDataElements.Name);\r",
															"    pm.globals.set(\"OnlineStatus\",jsonDataElements.Online.toString());\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{CompletedOrderId}})/Product",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{CompletedOrderId}})",
														"Product"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Query By EvictionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"",
															"try {",
															"    // test status code",
															"    pm.test(\"Test Response Status Code\", function(){",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);",
															"    });",
															"",
															"    var jsonDataElements = pm.response.json().value;",
															"",
															"    //MIN number of Records Test",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"        console.log(jsonDataElements.length + \" products found: \");",
															"    });",
															"    var date = pm.globals.get(\"EvictionDate\");",
															"    var prop_name = \"EvictionDate\";",
															"    pm.test(\"EvictionDate: \" + date, function(){",
															"        for (let item of jsonDataElements) {",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
															"        }",
															"    });  ",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$filter=EvictionDate ge {{EvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate ge {{EvictionDate}}",
															"description": "Complex Property EvictionDate"
														},
														{
															"key": "$top",
															"value": "10",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Download By OrderId",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"try {\r",
															"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //console.log(pm.response);\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Downloaded Size\", function(){\r",
															"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"followAuthorizationHeader": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{CompletedOrderId}})/Product/$value",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{CompletedOrderId}})",
														"Product",
														"$value"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Download By ProductId",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"try {\r",
															"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //console.log(pm.response);\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Downloaded Size\", function(){\r",
															"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
															"    });\r",
															"\r",
															"    pm.globals.set(\"DownloadStatus\", \"completed\");\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"followAuthorizationHeader": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/$value",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{ProductId}})",
														"$value"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"if(!pm.globals.get('OnlineStatus')){",
													"       postman.setNextRequest(null); ",
													"   }  "
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "LTA Cancel Order by Id",
									"item": [
										{
											"name": "LTA Order Cancel",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"  "
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }  ",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						},
						{
							"name": "LTA Orders (Product Staging Notification)",
							"item": [
								{
									"name": "LTA Create Order (Product Staging Notification)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Offline Products (staging notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"    today = yyyy + '-' + mm + '-' + dd;//  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        if(pm.response.code !== 200){\r",
															"            //Not found offline products and array is empty.\r",
															"            postman.setNextRequest(null);\r",
															"            console.log(\"Set next request to: 'LTA Get Online Products' .\");\r",
															"        } \r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]); \r",
															"    }); \r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    const sizeLimit = 80000000;\r",
															"    \r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"        if(jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()){\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found! \");\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"    \r",
															"    console.log(\"Processing product: \"+randomItems['Name']+\" (\"+randomItems['Id'] + \")\");\r",
															"    console.log(randomItems);\r",
															"    console.log(\"Product online status is: \" + randomItems.Online);\r",
															"    pm.globals.set('ProductId', randomItems.Id);\r",
															"    pm.globals.set('ProductName', randomItems.Name);\r",
															"    pm.globals.set(\"OnlineStatus\",randomItems.Online.toString());\r",
															"\r",
															"    pm.test(\"Test Properties for product: \" + randomItems['Id'], function(){\r",
															"        pm.expect(randomItems).to.have.property(\"Id\");\r",
															"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"Name\");\r",
															"        pm.expect(randomItems.Name).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"ContentType\");\r",
															"        pm.expect(randomItems.ContentType).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"ContentLength\");\r",
															"        pm.expect(randomItems.ContentLength).to.be.a(\"number\");\r",
															"        pm.expect(randomItems).to.have.property(\"OriginDate\");\r",
															"        pm.expect(randomItems.OriginDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"PublicationDate\");\r",
															"        pm.expect(randomItems.PublicationDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"ModificationDate\");\r",
															"        pm.expect(randomItems.ModificationDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"Online\");\r",
															"        pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"        pm.expect(randomItems).to.have.property(\"Checksum\");\r",
															"        pm.expect(randomItems.Checksum).to.be.an(\"array\");\r",
															"        pm.expect(randomItems).to.have.property(\"ContentDate\");\r",
															"        pm.expect(randomItems.ContentDate).to.be.an(\"object\");\r",
															"        });\r",
															"\r",
															"        // verify online status\r",
															"        pm.test(\"Test online status: \" + randomItems.Online, function () {\r",
															"            pm.expect(randomItems).to.have.property(\"Online\");\r",
															"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(randomItems.Online).to.eq(false);\r",
															"        });\r",
															"        \r",
															"        const online_product = jsonDataElements.find(m => m.Online === true);\r",
															"        if (!jsonDataElements.length || online_product) {\r",
															"              //Not found offline products and array is empty.\r",
															"             postman.setNextRequest(null);\r",
															"             console.warn(\"Not found offline product!\")\r",
															"        }\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{ProductTypeCode}}&$top=100",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq false) and {{ProductTypeCode}}"
														},
														{
															"key": "$top",
															"value": "100"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Order (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    \r",
															"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':'+ m + ':' + s + '.000Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"\r",
															"//var date = GetCurrentDate()\r",
															"//console.log(\"Notification Date is: \" + date);\r",
															"//pm.globals.set(\"NotificationDate\", date);"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"\r",
															"    for (const [key, value] of Object.entries(properties_map)) {\r",
															"        propertySpecific(key, order);\r",
															"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{OrderPriority}},\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{ProductId}})",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "LTA Monitor Order Notification",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Product Id from Server logs for Order",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"// search product id\r",
															"let notification = []\r",
															"\r",
															"for (let i = 0; i < jsonDataElements.length-1; i++){\r",
															"    if(Object.keys(jsonDataElements[i].request.body).length !== 0){\r",
															"       if (JSON.parse(jsonDataElements[i].request.body.data).ProductId === product_id){\r",
															"           notification.push(JSON.parse(jsonDataElements[i].request.body.data));\r",
															"       }\r",
															"    }\r",
															"}\r",
															"console.log(notification);\r",
															"console.log(\"Found \" + notification.length + \" items\");\r",
															"\r",
															"pm.globals.set(\"NotificationProductId\",\"false\");\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code \r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification[0].ProductId).to.be.includes(product_id);\r",
															"            console.log(\"Found product id: \" + product_id);\r",
															"        });\r",
															"\r",
															"        var date = notification[0].NotificationDate\r",
															"        \r",
															"        console.log(\"Notification Date is: \" + date);\r",
															"        pm.globals.set(\"NotificationDate\", date);\r",
															"        pm.globals.set(\"NotificationProductId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Send Product Staging Notification",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Completed Order Properties (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\",\"queued\",\"failed\",\"completed\", \"cancelled\"]);\r",
															"};\r",
															"\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"}; \r",
															"properties_map.Priority=function (element) {pm.expect(element.Priority).to.be.a(\"number\");}; \r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"properties_map.EstimatedDate=function (element) {pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"properties_map.OrderSize=function (element) {pm.expect(element.OrderSize).to.be.a(\"number\");};\r",
															"properties_map.CompletedDate=function (element) {pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"properties_map.EvictionDate=function (element) {if(element.EvictionDate){ pm.expect(element.EvictionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); }};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test stattus code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value[0];\r",
															" \r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"    \r",
															"    console.log(\"Order status is: \" + order.Status);\r",
															"    if(order.Status == \"completed\"){\r",
															"       for (const[key, value] of Object.entries(properties_map)){\r",
															"         propertySpecific(key, order);\r",
															"         pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"       }\r",
															"       pm.globals.set('CompletedOrderId', order.Id);\r",
															"       console.log(\"The product download can be requested ...\");\r",
															"    } else{\r",
															"         console.warn(\"Skipped Test Property for Order in status: \" + order.Status);\r",
															"         postman.setNextRequest(null);\r",
															"    }\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "basic",
													"basic": [
														{
															"key": "password",
															"value": "{{password}}",
															"type": "string"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Id eq {{OrderId}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Id eq {{OrderId}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Order Notification (Product Staging)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"console.log(access_token)\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "{{subscription_auth_token}}",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"OrderId\": \"{{OrderId}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\" \r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order EvictionDate Query (Product Staging)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){ \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test property\r",
															"    var date = pm.globals.get(\"OrderEvictionDate\");\r",
															"    var prop_name = \"EvictionDate\";\r",
															"    pm.test(\"EvictionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=EvictionDate ge {{OrderEvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate ge {{OrderEvictionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Order NotificationEndpoint Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var endpoint = pm.iterationData.get(\"NotificationEndpoint\");\r",
															"    pm.test(\"NotificationEndpoint: \" + endpoint, function(){\r",
															"       pm.expect(current_order.NotificationEndpoint).to.eq(endpoint);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
														}
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"pm.globals.set(\"NotificationProductId\",\"false\");"
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "LTA Check Product Staging Notification",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Product Id from Server logs for Order",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"// search product id\r",
															"let notification = []\r",
															"\r",
															"for (let i = 0; i < jsonDataElements.length-1; i++){\r",
															"    if(Object.keys(jsonDataElements[i].request.body).length !== 0){\r",
															"       if (JSON.parse(jsonDataElements[i].request.body.data).ProductId === product_id){\r",
															"           notification.push(JSON.parse(jsonDataElements[i].request.body.data));\r",
															"       }\r",
															"    }\r",
															"}\r",
															"console.log(notification);\r",
															"console.log(\"Found \" + notification.length + \" items\");\r",
															"\r",
															"if (notification && notification.length >= 2) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification[1].ProductId).to.be.includes(product_id);\r",
															"            console.log(\"Found product id: \" + product_id);\r",
															"        });\r",
															"        \r",
															"        pm.globals.set(\"NotificationProductId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Cancel Order by Id (Product Staging Notification)",
									"item": [
										{
											"name": "LTA Order Cancel (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"  "
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }  ",
											"",
											"if(!pm.iterationData.get('NotificationEndpoint')){",
											"       postman.setNextRequest(null); ",
											"   }   ",
											"",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						}
					]
				},
				{
					"name": "LTA Bulks and BatchOrders (all cases)",
					"item": [
						{
							"name": "LTA Bulks and BatchOrders",
							"item": [
								{
									"name": "LTA Bulk Create",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															" if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Create Request",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"created\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.BatchsizeProducts=function (element) {\r",
															"    pm.expect(element.BatchsizeProducts).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.BatchsizeVolume=function (element) {\r",
															"    pm.expect(element.BatchsizeVolume).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Bulk: \" + order[key], function(){properties_map[key](order)});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Bulk: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"\r",
															"    //test property for bulk\r",
															"    console.log(pm.response.json())\r",
															"    //var jsonDataElements = pm.response.json().value[0];\r",
															"    var jsonDataElements = pm.response.json();\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, jsonDataElements);\r",
															"        pm.globals.set(\"Bulk\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"\r",
															"    today = yyyy + '-' + mm + '-' + dd  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"function GetLastDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0') ;\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours()-4, 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    \r",
															"    today = yyyy + '-' + mm + '-' + dd  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"var last_date = GetLastDate()\r",
															"var date = GetCurrentDate();\r",
															"var time_y = \"00:00:00.000Z\"\r",
															"\r",
															"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
															"\r",
															"var filter_string_completed = filter_string +  \" and PublicationDate gt \" + last_date + \" and \"  +  \"PublicationDate lt \" + date;\r",
															"console.log(\"FilterParam is: \" + filter_string_completed);\r",
															"\r",
															"pm.globals.set(\"BulkFilterParam\", filter_string_completed);\r",
															"console.log(pm.request.url)\r",
															"console.log(pm.request.body)\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Bulk/$entity\",\r\n    \"FilterParam\": \"{{BulkFilterParam}}\",\r\n    \"BatchsizeProducts\": {{BulkBatchsizeProducts}},\r\n    \"BatchsizeVolume\": {{BulkBatchsizeVolume}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Details",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
															"    console.warn(\"Sending request as administrator!\");\r",
															"    postman.setNextRequest(null);       \r",
															"}   "
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"created\",\"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage = function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.BatchsizeProducts=function (element) {\r",
															"    pm.expect(element.BatchsizeProducts).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.BatchsizeVolume=function (element) {\r",
															"    pm.expect(element.BatchsizeVolume).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"\r",
															"function propertySpecific(key, order) {\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \" + key + \" for Bulk: \" + order[key], function () { properties_map[key](order) });\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Bulk: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200, 201, 202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"    // Test bulk properties\r",
															"    var order_response = {};\r",
															"\r",
															"    for (const [key, value] of Object.entries(properties_map)) {\r",
															"        propertySpecific(key, jsonDataElements);\r",
															"        //filling the collection variable order array\r",
															"        order_response[key] = jsonDataElements[key];\r",
															"        pm.globals.set(\"Bulk\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks({{BulkId}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks({{BulkId}})"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By Status",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test bulk property   \r",
															"    var property = pm.globals.get(\"BulkStatus\");\r",
															"    pm.test(\"Bulk Status: \" + property, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item.Status).to.be.a(\"string\");\r",
															"            pm.expect(item.Status).to.equal(property); \r",
															"        }\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=Status eq OData.CSC.JobStatus'{{BulkStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'{{BulkStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By StatusMessage",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test bulk property   \r",
															"    var property = pm.globals.get(\"BulkStatusMessage\");\r",
															"    pm.test(\"Bulk StatusMessage: \" + property, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item.StatusMessage).to.be.a(\"string\");\r",
															"            pm.expect(item.StatusMessage).to.equal(property); \r",
															"        }\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=StatusMessage eq '{{BulkStatusMessage}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "StatusMessage eq '{{BulkStatusMessage}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By OrderParam",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															" try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$orderby={{BulkOrderbyParam}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "{{BulkOrderbyParam}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By BatchsizeProducts",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test statsuus code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test bulk property   \r",
															"    var property = pm.globals.get(\"BulkBatchsizeProducts\");\r",
															"    pm.test(\"BatchsizeProducts: \" + property, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item.BatchsizeProducts).to.be.a(\"number\");\r",
															"            pm.expect(item.BatchsizeProducts).to.equal(parseInt(property)); \r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=BatchsizeProducts eq {{BulkBatchsizeProducts}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "BatchsizeProducts eq {{BulkBatchsizeProducts}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By BatchsizeVolume",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test bulk property   \r",
															"    var property = pm.globals.get(\"BulkBatchsizeVolume\");\r",
															"    pm.test(\"BatchsizeVolume: \" + property, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item.BatchsizeVolume).to.be.a(\"number\");\r",
															"            pm.expect(item.BatchsizeVolume).to.equal(parseInt(property)); \r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=BatchsizeVolume eq {{BulkBatchsizeVolume}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "BatchsizeVolume eq {{BulkBatchsizeVolume}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By SubmissionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    }); \r",
															"    \r",
															"    //test property\r",
															"    var date = pm.globals.get(\"BulkSubmissionDate\")\r",
															"    var prop_name = \"SubmissionDate\";\r",
															"    pm.test(\"SubmissionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=SubmissionDate ge {{BulkSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate ge {{BulkSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA BatchOrder Triggering",
									"item": [
										{
											"name": "LTA BatchOrders within a Bulk Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"queued\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    switch(element.Status){\r",
															"        case \"queued\":\r",
															"            if(element.SubmissionDate){\r",
															"                pm.expect(element.SubmissionDate).to.be.oneOf([null]);\r",
															"            }\r",
															"            break;\r",
															"        case \"in_progress\", \"completed\":\r",
															"            pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"            pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        case \"cancelled\", \"failed\":\r",
															"            if(typeof(element.SubmissionDate)==\"string\"){\r",
															"                pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            } else pm.expect(element.SubmissionDate).to.be.oneOf([null]);\r",
															"            break;\r",
															"    }\r",
															"};\r",
															"properties_map.EstimatedDate=function (element) {\r",
															"    switch(element.Status){\r",
															"        case \"queued\":\r",
															"            if(element.EstimatedDate){\r",
															"                pm.expect(element.EstimatedDate).to.be.oneOf([null]);\r",
															"            }\r",
															"            break;\r",
															"        case \"in_progress\", \"completed\":\r",
															"            pm.expect(element.EstimatedDate).to.be.a(\"string\");\r",
															"            pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        case \"cancelled\", \"failed\":\r",
															"            if(typeof(element.EstimatedDate)==\"string\"){\r",
															"                pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            } else pm.expect(element.EstimatedDate).to.be.oneOf([null]);\r",
															"            break;\r",
															"    }\r",
															"};\r",
															"\r",
															"properties_map.Priority=function (element) {\r",
															"    if(element.Status != 'created' && element.Status != 'queued'){\r",
															"        pm.expect(element.Priority).to.be.a(\"number\");\r",
															"    }\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for BatchOrder: \" + order[key], function(){properties_map[key](order);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for BatchOrder: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of items Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Found Products: \" + jsonDataElements.length);\r",
															"    });\r",
															"    \r",
															"    const object_batch_orders = jsonDataElements.filter(m => m.Status === \"queued\");\r",
															"    console.log(\"Found BatchOrders: \" + object_batch_orders.length);\r",
															"    pm.globals.set(\"FoundBatchOrders\", object_batch_orders.length);\r",
															"    console.log('Selected randomly BatchOrder ...');\r",
															"    \r",
															"    const sizeLimit = 80000000;\r",
															"    var random_batch_order = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    //\r",
															"    console.log(random_batch_order);\r",
															"    if(object_batch_orders.length != 0){\r",
															"        for (let i = 0; i < object_batch_orders.length; i++) {\r",
															"            if(object_batch_orders[i][\"OrderSize\"] <= sizeLimit){\r",
															"                console.log(object_batch_orders[i]);\r",
															"                random_batch_order = object_batch_orders[i];\r",
															"                console.log(\"batch order size is!!: \" + object_batch_orders[i].OrderSize);\r",
															"                break;\r",
															"                }\r",
															"            }\r",
															"        }else{\r",
															"            for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"                if(jsonDataElements[i][\"OrderSize\"] <= sizeLimit){\r",
															"                    console.log(jsonDataElements[i]);\r",
															"                    random_batch_order = jsonDataElements[i];\r",
															"                    console.log(\"batch order size is: \" + jsonDataElements[i].OrderSize);\r",
															"                    break;\r",
															"                }\r",
															"            }\r",
															"        }\r",
															"    \r",
															"    console.log(random_batch_order);\r",
															"    //pm.globals.set(\"BatchOrderId\", random_batch_order[\"Id\"]);\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"            propertySpecific(key, random_batch_order);\r",
															"            pm.globals.set(\"BatchOrder\" + key, random_batch_order[key]);\r",
															"            //console.log(\"BatchOrder\" + key,random_batch_order[key]);\r",
															"        }\r",
															"     \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks({{BulkId}})/BatchOrders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks({{BulkId}})",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$top",
															"value": "1",
															"disabled": true
														},
														{
															"key": "$count",
															"value": "true",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query (Constituent Products)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"    today = yyyy + '-' + mm + '-' + dd;//  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    //MIN number of BatchOrder Products Test\r",
															"    var bulk_batchsize_products = pm.globals.get('BulkBatchsizeProducts');\r",
															"    pm.test(\"Expected BatchOrder number of BatchOrders Test: \" + bulk_batchsize_products, function(){\r",
															"        //pm.expect(jsonDataElements.length).to.be.lte(bulk_batchsize_products);\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(1);\r",
															"    });\r",
															"\r",
															"\r",
															"    for (var counter = 0;  counter  < jsonDataElements.length; counter++){\r",
															"        var product = jsonDataElements[counter];\r",
															"        console.log(\"Processing Product: \"+product.Name+\" - \"+product.Id);\r",
															"\r",
															"        pm.test(\"Test Properties for product: \" + product.Id, function(){\r",
															"            pm.expect(product).to.have.property(\"Id\");\r",
															"            pm.expect(product.Id).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"Name\");\r",
															"            pm.expect(product.Name).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"ContentType\");\r",
															"            pm.expect(product.ContentType).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"ContentLength\");\r",
															"            pm.expect(product.ContentLength).to.be.a(\"number\");\r",
															"            pm.expect(product).to.have.property(\"OriginDate\");\r",
															"            pm.expect(product.OriginDate).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"PublicationDate\");\r",
															"            pm.expect(product.PublicationDate).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"ModificationDate\");\r",
															"            pm.expect(product.ModificationDate).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"Online\");\r",
															"            pm.expect(product.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(product).to.have.property(\"Checksum\");\r",
															"            pm.expect(product.Checksum).to.be.an(\"array\");\r",
															"            pm.expect(product).to.have.property(\"ContentDate\");\r",
															"            pm.expect(product.ContentDate).to.be.an(\"object\");\r",
															"        }); \r",
															"    }\r",
															"    \r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    const sizeLimit = 8000000;\r",
															"    \r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //if(jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()){\r",
															"        if(jsonDataElements[i][\"ContentLength\"] <= sizeLimit){\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found: \" + randomItems.Name);\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"    pm.globals.set('ProductId', randomItems[\"Id\"]);\r",
															"    pm.globals.set('ProductName', randomItems['Name']);\r",
															"    pm.globals.set('ContentLength', randomItems['ContentLength']);\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})/Products",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})",
														"Products"
													],
													"query": [
														{
															"key": "",
															"value": "",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Triggering Request",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([204]);\r",
															"    });\r",
															"    \r",
															"    console.log(\"Status is: \" + pm.response.code);\r",
															"    pm.globals.set(\"TriggerStatusCode\", pm.response.code)\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{BatchOrderPriority}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})/OData.CSC.BatchOrder",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})",
														"OData.CSC.BatchOrder"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Retrieve Completed BatchOrder",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"queued\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.OrderSize=function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.a(\"number\");\r",
															"};\r",
															"\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    switch(element.Status){\r",
															"        case \"queued\":\r",
															"            if(element.SubmissionDate){\r",
															"                pm.expect(element.SubmissionDate).to.be.oneOf([null]);\r",
															"                \r",
															"            }\r",
															"            break;\r",
															"        case \"in_progress\", \"completed\":\r",
															"            pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"            pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        case \"cancelled\", \"failed\":\r",
															"            if(typeof(element.SubmissionDate)==\"string\"){\r",
															"                pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            } else pm.expect(element.SubmissionDate).to.be.oneOf([null]);\r",
															"            break;\r",
															"    }\r",
															"};\r",
															"properties_map.EstimatedDate=function (element) {\r",
															"    switch(element.Status){\r",
															"        case \"queued\":\r",
															"            if(element.EstimatedDate){\r",
															"                pm.expect(element.EstimatedDate).to.be.oneOf([null]);\r",
															"            }\r",
															"            break;\r",
															"        case \"in_progress\", \"completed\":\r",
															"            pm.expect(element.EstimatedDate).to.be.a(\"string\");\r",
															"            pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        case \"cancelled\", \"failed\":\r",
															"            if(typeof(element.EstimatedDate)==\"string\"){\r",
															"                pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            } else pm.expect(element.EstimatedDate).to.be.oneOf([null]);\r",
															"            break;\r",
															"    }\r",
															"};\r",
															"\r",
															"properties_map.Priority=function (element) {\r",
															"    if(element.Status != 'created' && element.Status != 'queued'){\r",
															"        pm.expect(element.Priority).to.be.a(\"number\");\r",
															"    }\r",
															"}\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for BatchOrder: \" + order[key], function(){properties_map[key](order)});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for BatchOrder: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"   \r",
															"    //test property for bulk\r",
															"    var batch_order = jsonDataElements;\r",
															"    pm.globals.set(\"BatchOrderStatus\",batch_order.Status);\r",
															"    if(batch_order.Status == \"completed\"){\r",
															"        for (const[key, value] of Object.entries(properties_map)){\r",
															"            propertySpecific(key, batch_order);\r",
															"            pm.globals.set(\"BatchOrder\" + key,batch_order[key]);\r",
															"        }\r",
															"        pm.globals.set(\"CompletedBatchOrderId\",batch_order.Id);\r",
															"        pm.globals.set(\"BatchOrderCompletedDate\",batch_order.CompletedDate);\r",
															"    }else {\r",
															"        console.warn(\"Test Property is skipped for BatchOrder in status: \" + batch_order.Status); \r",
															"        postman.setNextRequest(null);\r",
															"    }\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Completed BatchOrder",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(jsonDataElements.length + \" products found: \");\r",
															"    });\r",
															"\r",
															"    const object = pm.response.json().value.find(m => m.Id === pm.globals.get('BatchOrderId'));\r",
															"    console.log(object);\r",
															"    if(object){\r",
															"        console.log(\"BatchOrder \" + object.Id + \" is completed!\")\r",
															"    }\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=Status eq OData.CSC.JobStatus'completed'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'completed'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By Id",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //Test id batchorders\r",
															"    var id = pm.globals.get(\"BatchOrderId\");\r",
															"    pm.test(\"Id BatchOrder: \" + id, function(){\r",
															"        pm.expect(pm.response.text()).to.be.includes(id);\r",
															"    });\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By Status",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test batchorder property\r",
															"    property = \"Status\";\r",
															"    var expected_order_key_value = decodeURIComponent(pm.request.url.getQueryString()).split(\" eq \").pop().split(\"OData.CSC.JobStatus\").pop().replace(/'/g, \"\");\r",
															"\r",
															"    pm.test(\"BatchOrder \" + property + \": \" + expected_order_key_value, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item[property]).to.equal(expected_order_key_value);\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=Status eq OData.CSC.JobStatus'{{BatchOrderStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'{{BatchOrderStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By StatusMessage",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test batchorder propery\r",
															"    property = \"StatusMessage\";\r",
															"    var expected_order_key_value = decodeURIComponent(pm.request.url.getQueryString()).split(\" eq \").pop().replace(/'/g, \"\");\r",
															"    pm.test(\"BatchOrder \" + property + \": \" + expected_order_key_value, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item[property]).to.equal(expected_order_key_value);\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=StatusMessage eq '{{BatchOrderStatusMessage}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "StatusMessage eq '{{BatchOrderStatusMessage}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By OrderSize",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    //MIN number of Records Test\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    //console.log(jsonDataElements)\r",
															"\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test batchorder propery\r",
															"    property = \"OrderSize\";\r",
															"    var expected_order_key_value = parseInt(decodeURIComponent(pm.request.url.getQueryString()).split(\" eq \").pop().replace(/'/g, \"\"));\r",
															"\r",
															"    pm.test(\"BatchOrder \" + property + \": \" + expected_order_key_value, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(item[property]).to.equal(expected_order_key_value);\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=OrderSize eq {{BatchOrderOrderSize}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "OrderSize eq {{BatchOrderOrderSize}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By SubmissionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_tested_filter_key = \"SubmissionDate\";\r",
															"    current_batch_order = jsonDataElements[0];\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test property\r",
															"    var date = pm.globals.get(\"BatchOrderSubmissionDate\")\r",
															"    var prop_name = \"SubmissionDate\";\r",
															"    pm.test(\"SubmissionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=SubmissionDate ge {{BatchOrderSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate ge {{BatchOrderSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By EstimatedDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_tested_filter_key = \"EstimatedDate\";\r",
															"    current_batch_order = jsonDataElements[0];\r",
															"\r",
															"   //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var date = pm.globals.get(\"BatchOrderEstimatedDate\")\r",
															"    var prop_name = \"EstimatedDate\";\r",
															"    pm.test(\"EstimatedDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=EstimatedDate ge {{BatchOrderEstimatedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EstimatedDate ge {{BatchOrderEstimatedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query By Priority",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    //console.log(jsonDataElements);\r",
															"\r",
															"   //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    //test batchorder priority\r",
															"    current_tested_filter_key = \"Priority\";\r",
															"    current_batch_order = jsonDataElements[0];\r",
															"    //Test priority batchorder\r",
															"    var expected_order_key_value = decodeURIComponent(pm.request.url.getQueryString()).split(\" eq \").pop().replace(/'/g, \"\");\r",
															"\r",
															"    pm.test(\"BatchOrder \" + current_tested_filter_key + \": \" + expected_order_key_value, function(){\r",
															"        pm.expect(current_batch_order[current_tested_filter_key]).to.equal(parseInt(expected_order_key_value));\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=Priority eq {{BatchOrderPriority}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Priority eq {{BatchOrderPriority}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Completion Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"completed\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.OrderSize=function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.a(\"number\");\r",
															"};\r",
															"\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EstimatedDate=function (element) {\r",
															"    pm.expect(element.EstimatedDate).to.be.a(\"string\");\r",
															"    pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.CompletedDate=function (element) {\r",
															"    pm.expect(element.CompletedDate).to.be.a(\"string\");\r",
															"    pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"\r",
															"properties_map.Priority=function (element) {\r",
															"    pm.expect(element.Priority).to.be.a(\"number\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for BatchOrder: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);\r",
															"            });\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for BatchOrder: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_tested_filter_key = \"CompletedDate\";\r",
															"    current_batch_order = jsonDataElements[0];\r",
															" \r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of BatchOrders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var batch = jsonDataElements[0];\r",
															"\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, batch);\r",
															"        pm.globals.set(\"BatchOrder\" + key, batch[key]);\r",
															"    }\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders?$filter=CompletedDate ge {{BatchOrderCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "CompletedDate ge {{BatchOrderCompletedDate}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Retrieve Completed Bulk",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															" if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Details",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"created\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.BatchsizeProducts=function (element) {\r",
															"    pm.expect(element.BatchsizeProducts).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.BatchsizeVolume=function (element) {\r",
															"    pm.expect(element.BatchsizeVolume).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Bulk: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);\r",
															"            });\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Bulk: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    //test property for bulk\r",
															"    var bulk = jsonDataElements;\r",
															"\r",
															"    pm.globals.set('BulkStatus', bulk['Status']);\r",
															"    console.log(\"Bulk status is \" + bulk['Status']);\r",
															"    if(bulk.Status == \"completed\"){\r",
															"       for (const[key, value] of Object.entries(properties_map)){\r",
															"       propertySpecific(key, bulk);\r",
															"       }\r",
															"       pm.globals.set('CompletedBulkId', bulk['Id']);\r",
															"       pm.globals.set('CompletedBulkStatus', bulk['Status']);\r",
															"       pm.globals.set('CompletedBulkStatusMessage', bulk['StatusMessage']); \r",
															"    } else {\r",
															"        console.warn(\"Test Property is skipped for Bulk in status: \" + bulk.Status);\r",
															"    }\r",
															"    \r",
															"    \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks({{BulkId}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks({{BulkId}})"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Get Completed Bulk Details",
									"item": [
										{
											"name": "LTA Get Completed Bulk",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															" \r",
															"    current_tested_filter_key = \"Status\";\r",
															"    current_bulk_order = jsonDataElements[0];\r",
															"    var expected_bulk_key_value = decodeURIComponent(pm.request.url.getQueryString()).split(\" eq \").pop().replace(/'/g, \"\").replace('OData.CSC.JobStatus',\"\");\r",
															"\r",
															"    pm.test(\"Bulk \" + current_tested_filter_key + \": \" + expected_bulk_key_value, function(){\r",
															"        pm.expect(current_bulk_order[current_tested_filter_key]).to.equal(expected_bulk_key_value);\r",
															"    });\r",
															"\r",
															"    const object = pm.response.json().value.find(m => m.Id === pm.globals.get('BulkId'));\r",
															"    \r",
															"    if(object){\r",
															"        //save bulk properties\r",
															"        pm.globals.set('CompletedBulkId', object.Id);\r",
															"        pm.globals.set('BulkCompletedDate', object.CompletedDate);\r",
															"        console.log(\"Bulk Status is completed\");\r",
															"    }\r",
															"   \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=Status eq OData.CSC.JobStatus'completed'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'completed'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Query By CompletedDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var date = pm.globals.get(\"BulkCompletedDate\")\r",
															"    var prop_name = \"CompletedDate\";\r",
															"    pm.test(\"CompletedDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks?$filter=CompletedDate ge {{BulkCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													],
													"query": [
														{
															"key": "$filter",
															"value": "CompletedDate ge {{BulkCompletedDate}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Delete BatchOrder",
									"item": [
										{
											"name": "LTA BatchOrder Cancel",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.CompletedDate=function (element) {\r",
															"    pm.expect(element.CompletedDate).to.be.equal(null);\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EstimatedDate=function (element) {\r",
															"        pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.OrderSize=function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.equal(0);\r",
															"};\r",
															"properties_map.Priority=function (element) {\r",
															"    pm.expect(element.Priority).to.be.a(\"number\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for BatchOrder: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);\r",
															"            });\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for BatchOrder: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Delete Bulk",
									"item": [
										{
											"name": "LTA Bulk Cancel",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"created\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.BatchsizeProducts=function (element) {\r",
															"    pm.expect(element.BatchsizeProducts).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.BatchsizeVolume=function (element) {\r",
															"    pm.expect(element.BatchsizeVolume).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.NotificationEndpoint=function (element) {\r",
															"    if(element.NotificationEndpoint){\r",
															"        if(typeof(element.NotificationEndpoint)==\"string\"){\r",
															"            pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"        } else pm.expect(element.NotificationEndpoint).to.be.equal(null);\r",
															"    }\r",
															"};\r",
															"properties_map.OrderbyParam=function (element) {\r",
															"    if(element.OrderbyParam){\r",
															"        if(typeof(element.OrderbyParam)==\"string\"){\r",
															"            pm.expect(element.OrderbyParam).to.be.a(\"string\");\r",
															"        } else pm.expect(element.OrderbyParam).to.be.equal(null);\r",
															"    }\r",
															"\r",
															"};\r",
															"properties_map.CompletedDate=function (element) {\r",
															"    if(element.CompletedDate){\r",
															"        switch(element.Status){\r",
															"            case \"completed\":\r",
															"                pm.expect(element.CompletedDate).to.be.a(\"string\");\r",
															"                pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"                break;\r",
															"            default:\r",
															"                if(element.CompletedDate){\r",
															"                    pm.expect(element.CompletedDate).to.be.equal(null)\r",
															"                }     \r",
															"        }\r",
															"    }\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Bulk: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Bulk: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks({{BulkId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks({{BulkId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }   ",
											"",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						},
						{
							"name": "LTA Bulks and BatchOrders (Product Staging Notification)",
							"item": [
								{
									"name": "LTA Create Bulk and BatchOrder (Product Staging Notification)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Bulk Create (with Notification Endpoint)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"created\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.BatchsizeProducts=function (element) {\r",
															"    pm.expect(element.BatchsizeProducts).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.BatchsizeVolume=function (element) {\r",
															"    pm.expect(element.BatchsizeVolume).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"properties_map.NotificationEndpoint=function (element) {\r",
															"   pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Bulk: \" + order[key], function(){properties_map[key](order)});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Bulk: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"\r",
															"    //test property for bulk\r",
															"    console.log(pm.response.json())\r",
															"    //var jsonDataElements = pm.response.json().value[0];\r",
															"    var jsonDataElements = pm.response.json();\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, jsonDataElements);\r",
															"        pm.globals.set(\"Bulk\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"\r",
															"    today = yyyy + '-' + mm + '-' + dd  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"function GetLastDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0') ;\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours()-4, 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    \r",
															"    today = yyyy + '-' + mm + '-' + dd  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"var last_date = GetLastDate()\r",
															"var date = GetCurrentDate();\r",
															"var time_y = \"00:00:00.000Z\"\r",
															"\r",
															"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
															"\r",
															"var filter_string_completed = filter_string +  \" and PublicationDate gt \" + last_date + \" and \"  +  \"PublicationDate lt \" + date;\r",
															"console.log(\"FilterParam is: \" + filter_string_completed);\r",
															"\r",
															"pm.globals.set(\"BulkFilterParam\", filter_string_completed);\r",
															"console.log(pm.request.url)\r",
															"console.log(pm.request.body)\r",
															"\r",
															"//console.log(\"Notification Date is: \" + date);\r",
															"//pm.globals.set(\"NotificationDate\", date);\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Bulk/$entity\",\r\n    \"FilterParam\": \"{{BulkFilterParam}}\",\r\n    \"BatchsizeProducts\": {{BulkBatchsizeProducts}},\r\n    \"BatchsizeVolume\": {{BulkBatchsizeVolume}},\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrders within a Bulk Query (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"queued\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    switch(element.Status){\r",
															"        case \"queued\":\r",
															"            if(element.SubmissionDate){\r",
															"                pm.expect(element.SubmissionDate).to.be.oneOf([null]);\r",
															"            }\r",
															"            break;\r",
															"        case \"in_progress\", \"completed\":\r",
															"            pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"            pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        case \"cancelled\", \"failed\":\r",
															"            if(typeof(element.SubmissionDate)==\"string\"){\r",
															"                pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            } else pm.expect(element.SubmissionDate).to.be.oneOf([null]);\r",
															"            break;\r",
															"    }\r",
															"};\r",
															"properties_map.EstimatedDate=function (element) {\r",
															"    switch(element.Status){\r",
															"        case \"queued\":\r",
															"            if(element.EstimatedDate){\r",
															"                pm.expect(element.EstimatedDate).to.be.oneOf([null]);\r",
															"            }\r",
															"            break;\r",
															"        case \"in_progress\", \"completed\":\r",
															"            pm.expect(element.EstimatedDate).to.be.a(\"string\");\r",
															"            pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        case \"cancelled\", \"failed\":\r",
															"            if(typeof(element.EstimatedDate)==\"string\"){\r",
															"                pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            } else pm.expect(element.EstimatedDate).to.be.oneOf([null]);\r",
															"            break;\r",
															"    }\r",
															"};\r",
															" \r",
															"properties_map.Priority=function (element) {\r",
															"    if(element.Status != 'created' && element.Status != 'queued'){\r",
															"        pm.expect(element.Priority).to.be.a(\"number\");\r",
															"    }\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for BatchOrder: \" + order[key], function(){properties_map[key](order);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for BatchOrder: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of bulks Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Found Products: \" + jsonDataElements.length);\r",
															"    });\r",
															"    \r",
															"    const object_batch_orders = jsonDataElements.filter(m => m.Status === \"queued\")\r",
															"    console.log(\"Found BatchOrders: \" + object_batch_orders.length);\r",
															"    pm.globals.set(\"FoundBatchOrders\", object_batch_orders.length);\r",
															"    console.log('Selected randomly BatchOrder ...');\r",
															"    \r",
															"    if(object_batch_orders.length != 0){\r",
															"         var random_batch_order = object_batch_orders[Math.floor(Math.random()*object_batch_orders.length)];\r",
															"    }else{\r",
															"         var random_batch_order = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    }\r",
															"    console.log(random_batch_order);\r",
															"    //const sizeLimit = 80000000;\r",
															"    \r",
															"    //for (let i = 0; i < random_batch_order.length; i++) {\r",
															"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"    //    if(random_batch_order[i][\"size\"] <= sizeLimit){\r",
															"    //        randomItems = random_batch_order[i];\r",
															"    //        console.log(\"batch order size is: \" + random_batch_order[i][\"size\"] );\r",
															"    //        break;\r",
															"    //    }\r",
															"    //}\r",
															"\r",
															"    //pm.globals.set(\"BatchOrderId\", random_batch_order[\"Id\"]);\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"            propertySpecific(key, random_batch_order);\r",
															"            pm.globals.set(\"BatchOrder\" + key, random_batch_order[key]);\r",
															"            //console.log(\"BatchOrder\" + key,random_batch_order[key]);\r",
															"        }\r",
															"    \r",
															"    //for (var counter = 0;  counter  < jsonDataElements.length; counter++){\r",
															"    //    var batch = jsonDataElements[counter];\r",
															"        //console.log(\"Processing Batch: \"+batch.Id);\r",
															"    //    for (const[key, value] of Object.entries(properties_map)){\r",
															"    //        propertySpecific(key, batch);\r",
															"    //    }\r",
															"    //}\r",
															"     \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks({{BulkId}})/BatchOrders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks({{BulkId}})",
														"BatchOrders"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Query (Constituent Products for notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"    today = yyyy + '-' + mm + '-' + dd;//  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of BatchOrder Products Test\r",
															"    var bulk_batchsize_products = pm.globals.get('BulkBatchsizeProducts');\r",
															"    pm.test(\"Expected BatchOrder number of products Test: \" + bulk_batchsize_products, function(){\r",
															"        //pm.expect(jsonDataElements.length).to.be.lte(bulk_batchsize_products);\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(1);\r",
															"    });\r",
															"    \r",
															"\r",
															"    for (var counter = 0;  counter  < jsonDataElements.length; counter++){\r",
															"        var product = jsonDataElements[counter];\r",
															"        console.log(\"Processing Product: \"+product.Name+\" - \"+product.Id);\r",
															"\r",
															"        pm.test(\"Test Properties for product: \" + product.Id, function(){\r",
															"            pm.expect(product).to.have.property(\"Id\");\r",
															"            pm.expect(product.Id).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"Name\");\r",
															"            pm.expect(product.Name).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"ContentType\");\r",
															"            pm.expect(product.ContentType).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"ContentLength\");\r",
															"            pm.expect(product.ContentLength).to.be.a(\"number\");\r",
															"            pm.expect(product).to.have.property(\"OriginDate\");\r",
															"            pm.expect(product.OriginDate).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"PublicationDate\");\r",
															"            pm.expect(product.PublicationDate).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"ModificationDate\");\r",
															"            pm.expect(product.ModificationDate).to.be.a(\"string\");\r",
															"            pm.expect(product).to.have.property(\"Online\");\r",
															"            pm.expect(product.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(product).to.have.property(\"Checksum\");\r",
															"            pm.expect(product.Checksum).to.be.an(\"array\");\r",
															"            pm.expect(product).to.have.property(\"ContentDate\");\r",
															"            pm.expect(product.ContentDate).to.be.an(\"object\");\r",
															"        }); \r",
															"    }\r",
															"    \r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    const sizeLimit = 75000;\r",
															"    \r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"        if(jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()){\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found! \");\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"    pm.globals.set('ProductId', randomItems[\"Id\"]);\r",
															"    pm.globals.set('ProductName', randomItems['Name']);\r",
															"    pm.globals.set('ContentLength', randomItems['ContentLength']);\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"disableBodyPruning": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})/Products",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})",
														"Products"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA BatchOrder Triggering (for notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([204]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{BatchOrderPriority}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})/OData.CSC.BatchOrder",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})",
														"OData.CSC.BatchOrder"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Monitor Bulk Notification",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Product Id from Server logs for BatchOder",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(product_id));\r",
															"console.log(notification);\r",
															"pm.globals.set(\"NotificationProductId\",\"false\");\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(product_id);\r",
															"            console.log(\"Found product id: \" + product_id);\r",
															"        }); \r",
															"        \r",
															"        var date = JSON.parse(notification.request.body.data).NotificationDate\r",
															"        \r",
															"        console.log(\"Notification Date is: \" + date);\r",
															"        pm.globals.set(\"NotificationDate\", date);\r",
															"        pm.globals.set(\"NotificationProductId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"} else{\r",
															"    postman.setNextRequest(null)\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Download Readiness Notification",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.BatchOrderId=function (element) {pm.expect(element.BatchOrderId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.ProductId=function (element) {pm.expect(element.ProductId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Name=function (element) {\r",
															"    pm.expect(element.Name).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.NotificationDate=function (element) {\r",
															"    pm.expect(element.NotificationDate).to.be.a(\"string\");\r",
															"    pm.expect(element.NotificationDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/);\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Notification: \" + order[key], function(){properties_map[key](order)});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Notification: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"BatchOrderId\": \"{{BatchOrderId}}\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"Name\": \"{{ProductName}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\"\r\n}\r\n\r\n",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Check Product Download Readiness Notification for BatchOrder",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Product Id from Server logs for BatchOder",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"// search product id\r",
															"let notification = []\r",
															"\r",
															"for (let i = 0; i < jsonDataElements.length-1; i++){\r",
															"    if(Object.keys(jsonDataElements[i].request.body).length !== 0){\r",
															"       if (JSON.parse(jsonDataElements[i].request.body.data).ProductId === product_id){\r",
															"           notification.push(JSON.parse(jsonDataElements[i].request.body.data));\r",
															"       }\r",
															"    }\r",
															"}\r",
															"console.log(notification);\r",
															"console.log(\"Found \" + notification.length + \" items\");\r",
															"\r",
															"if (notification && notification.length >= 2) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification[1].ProductId).to.be.includes(product_id);\r",
															"            console.log(\"Found product id: \" + product_id);\r",
															"        });\r",
															"        \r",
															"        pm.globals.set(\"NotificationProductId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"pm.globals.set(\"NotificationProductId\",\"false\");"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Delete BatchOrder (with Staging)",
									"item": [
										{
											"name": "LTA BatchOrder Cancel",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.CompletedDate=function (element) {\r",
															"    pm.expect(element.CompletedDate).to.be.equal(null);\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EstimatedDate=function (element) {\r",
															"        pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.OrderSize=function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.equal(0);\r",
															"};\r",
															"properties_map.Priority=function (element) {\r",
															"    pm.expect(element.Priority).to.be.a(\"number\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for BatchOrder: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);\r",
															"            });\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for BatchOrder: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/BatchOrders({{BatchOrderId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"BatchOrders({{BatchOrderId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Delete Bulk (with Staging)",
									"item": [
										{
											"name": "LTA Bulk Cancel",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"created\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate=function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.be.a(\"string\");\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.BatchsizeProducts=function (element) {\r",
															"    pm.expect(element.BatchsizeProducts).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.BatchsizeVolume=function (element) {\r",
															"    pm.expect(element.BatchsizeVolume).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.NotificationEndpoint=function (element) {\r",
															"    if(element.NotificationEndpoint){\r",
															"        if(typeof(element.NotificationEndpoint)==\"string\"){\r",
															"            pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"        } else pm.expect(element.NotificationEndpoint).to.be.equal(null);\r",
															"    }\r",
															"};\r",
															"properties_map.OrderbyParam=function (element) {\r",
															"    if(element.OrderbyParam){\r",
															"        if(typeof(element.OrderbyParam)==\"string\"){\r",
															"            pm.expect(element.OrderbyParam).to.be.a(\"string\");\r",
															"        } else pm.expect(element.OrderbyParam).to.be.equal(null);\r",
															"    }\r",
															"\r",
															"};\r",
															"properties_map.CompletedDate=function (element) {\r",
															"    if(element.CompletedDate){\r",
															"        switch(element.Status){\r",
															"            case \"completed\":\r",
															"                pm.expect(element.CompletedDate).to.be.a(\"string\");\r",
															"                pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"                break;\r",
															"            default:\r",
															"                if(element.CompletedDate){\r",
															"                    pm.expect(element.CompletedDate).to.be.equal(null)\r",
															"                }     \r",
															"        }\r",
															"    }\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Bulk: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Bulk: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Bulks({{BulkId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Bulks({{BulkId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }   ",
											"",
											"",
											"if(!pm.iterationData.get('NotificationEndpoint')){",
											"       postman.setNextRequest(null); ",
											"   }   ",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						}
					]
				},
				{
					"name": "LTA Subscriptions (all cases)",
					"item": [
						{
							"name": "LTA Subscriptions",
							"item": [
								{
									"name": "LTA Create Subscriptions no Staging (StageOrder false)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Create Subscription (no Staging)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"running\"]);\r",
															"};\r",
															"\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"    pm.expect(element.FilterParam).to.be.not.equal(null);\r",
															"};\r",
															"\r",
															"properties_map.StageOrder=function (element) {\r",
															"    pm.expect(element.StageOrder).to.be.equal(false); \r",
															"};\r",
															"\r",
															"properties_map.Priority=function (element) {\r",
															"    //pm.expect(element.Priority).to.be.equal(\"number\");\r",
															"    pm.expect(element.Priority).to.be.equal(pm.iterationData.get(\"SubscriptionPriority\"));\r",
															"};\r",
															"\r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"properties_map.NotificationEndpoint=function (element) {\r",
															"    pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Subscription: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Subscription: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"    \r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, jsonDataElements);\r",
															"        pm.globals.set('Subscription' + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"    pm.globals.set('SubscriptionEvent', \"created\");\r",
															"    \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"    while (x.toString().length < n) {\r",
															"      x = \"0\" + x;\r",
															"    }\r",
															"    return x;\r",
															"};\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 3);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    \r",
															"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"};\r",
															"\r",
															"function ConvertDate(today) {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    \r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth()).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 3);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"};\r",
															"\r",
															"Date.prototype.addDays = function (days) {\r",
															"    const date = new Date(this.valueOf());\r",
															"    date.setDate(date.getDate() + days);\r",
															"    return date;\r",
															"};\r",
															"  \r",
															"\r",
															"var current_date = GetCurrentDate();\r",
															"const date = new Date(current_date);\r",
															"    \r",
															"// add days to current date\r",
															"const new_date_formatYmd = new_date_Object => date.addDays(2).toISOString();\r",
															"new_date = new_date_formatYmd(new Date());\r",
															"console.log(new_date_formatYmd(new Date()));\r",
															"\r",
															"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
															"var filter_string_completed = filter_string +  \" and PublicationDate gt \" + current_date + \" and \"  +  \"PublicationDate lt \" + new_date;\r",
															"  \r",
															"console.log(\"FilterParam is: \" + filter_string_completed);\r",
															"//pm.globals.set(\"FilterParam\", pm.iterationData.get(\"FilterParamString\") + \" PublicationDate gt \" + yesterday_converted + time + \" and \"  +  \"PublicationDate lt \" + date + time)\r",
															"pm.globals.set(\"SubscriptionFilterParam\", filter_string_completed);\r",
															"//pm.globals.set(\"FilterString\", filter_string_completed.replace('Products?$filter=',''));\r",
															"\r",
															"console.log(\"Notification Date is: \" + date);\r",
															"pm.globals.set(\"NotificationDate\", date);"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Subscription/entity\",\r\n    \"FilterParam\": \"{{SubscriptionFilterParam}}\",\r\n    \"SubscriptionEvent\": \"created\",\r\n    \"StageOrder\": false,\r\n    \"Priority\": {{SubscriptionPriority}},\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Offline Products (staging notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"    today = yyyy + '-' + mm + '-' + dd;//  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    const sizeLimit = 80000000;\r",
															"    \r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"        if(jsonDataElements[i][\"ContentLength\"] <= sizeLimit){\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found! \");\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"    \r",
															"    console.log(\"Processing product: \"+randomItems['Name']+\" (\"+randomItems['Id'] + \")\");\r",
															"    console.log(randomItems);\r",
															"    console.log(\"Product online status is: \" + randomItems.Online);\r",
															"    pm.globals.set('SubscriptionProductId', randomItems.Id);\r",
															"    pm.globals.set('SubscriptionProductName', randomItems.Name);\r",
															"    pm.globals.set(\"OnlineStatus\",randomItems.Online.toString());\r",
															"\r",
															"    if(pm.globals.get('OnlineStatus') === \"true\"){\r",
															"        postman.setNextRequest(null);\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{FilterParam}}&$top=100",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq false) and {{FilterParam}}"
														},
														{
															"key": "$top",
															"value": "100"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Product Order (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"\r",
															"    for (const [key, value] of Object.entries(properties_map)) {\r",
															"        propertySpecific(key, order);\r",
															"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{OrderPriority}},\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{SubscriptionProductId}})/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{SubscriptionProductId}})",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscriptions Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Test product filter name\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Id Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json();\r",
															" \r",
															"    //Test subscription id property\r",
															"    var id = pm.globals.get('SubscriptionId');\r",
															"    pm.test(\"Subscription Id: \" + id, function(){\r",
															"        pm.expect(pm.response.text()).to.be.includes(id);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions('{{SubscriptionId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions('{{SubscriptionId}}')"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Status Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    }); \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    var property = pm.globals.get(\"SubscriptionStatus\");\r",
															"    var key = \"Status\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription SubscriptionEvent Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    var property = pm.globals.get(\"SubscriptionEvent\");\r",
															"    var key = \"SubscriptionEvent\"\r",
															"    pm.test(\"subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=SubscriptionEvent eq OData.CSC.SubscriptionEvent'{{SubscriptionEvent}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubscriptionEvent eq OData.CSC.SubscriptionEvent'{{SubscriptionEvent}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription FilterParam Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"       console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"    \r",
															"    //var property = pm.globals.get(\"FilterParam\");\r",
															"    //var key = \"FilterParam\"\r",
															"    //pm.test(\"Test \" + key + \" property for subscription: \" + jsonDataElements[0][key], function(){\r",
															"    //    pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"    //    console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    //});\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
															"pm.globals.set(\"FilterString\", filter_string.replaceAll('Products?$filter=','').replaceAll('Name','FilterParam'));"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter={{FilterString}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "{{FilterString}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription SubmissionDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"    //test property\r",
															"    var date = pm.globals.get(\"SubscriptionSubmissionDate\");\r",
															"    var prop_name = \"SubmissionDate\";\r",
															"    pm.test(\"SubmissionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    }); \r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=SubmissionDate ge {{SubscriptionSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate ge {{SubscriptionSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Priority Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(jsonDataElements.length + \" subscription found: \");\r",
															"    });\r",
															"\r",
															"    var property = pm.globals.get(\"SubscriptionPriority\");\r",
															"    var key = \"Priority\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property.toString);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=Priority eq {{SubscriptionPriority}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Priority eq {{SubscriptionPriority}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Filter Subscription by StageOrder Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(jsonDataElements.length + \" subscription found: \");\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=StageOrder eq false",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "StageOrder eq false"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Notification Endpoint Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(jsonDataElements.length + \" products found: \");\r",
															"    });\r",
															"\r",
															"    var property = pm.iterationData.get(\"NotificationEndpoint\");\r",
															"    var key = \"NotificationEndpoint\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Monitor Order Notification for Subscriptions",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Order Id from Server logs",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var order_id = pm.globals.get(\"OrderId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(order_id));\r",
															"console.log(notification);\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Order id: \" + order_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(order_id);\r",
															"            console.log(\"Found order id: \" + order_id);\r",
															"        });\r",
															"        \r",
															"        pm.globals.set(\"NotificationOrderId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}else{\r",
															"    postman.setNextRequest(null)\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Product Availability Notifications",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"console.log(access_token)\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"SubscriptionEvent\": \"created\",\r\n    \"ProductId\": \"{{SubscriptionProductId}}\",\r\n    \"ProductName\": \"{{SubscriptionProductName}}\",\r\n    \"SubscriptionId\": \"{{SubscriptionId}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Check Subscriptions Notification (StageOrder false)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Subscription Id from Server logs",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var subscription_id = pm.globals.get(\"SubscriptionId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(subscription_id));\r",
															"console.log(notification);\r",
															"pm.globals.set(\"NotificationSubscriptionId\", \"false\");\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Subscription Id: \" + subscription_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(subscription_id);\r",
															"            console.log(\"Found Subscription id: \" + subscription_id);\r",
															"        });\r",
															"        pm.globals.set(\"NotificationSubscriptionId\", \"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Cancel Subscriptions no Staging (StageOrder false)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription pause",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Pause",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions({{SubscriptionId}})",
														"OData.CSC.Pause"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription resume",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Resume",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions({{SubscriptionId}})",
														"OData.CSC.Resume"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription cancel",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions({{SubscriptionId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						},
						{
							"name": "LTA Subscriptions (with Staging)",
							"item": [
								{
									"name": "LTA Create Subscriptions with Staging (StageOrder true)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Products Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {",
															"    while (x.toString().length < n) {",
															"      x = \"0\" + x;",
															"    }",
															"    return x;",
															"};",
															"",
															"function GetCurrentDate() {",
															"    // Online Javascript Editor for free",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler",
															"    var today = new Date();",
															"    var dd = String(today.getDate()).padStart(2, '0');",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
															"    var yyyy = today.getFullYear();",
															"    var h = addZero(today.getHours(), 2);",
															"    var m = addZero(today.getMinutes(), 2);",
															"    var s = addZero(today.getSeconds(), 2);",
															"    var ms = addZero(today.getMilliseconds(), 3);",
															"    ",
															"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;",
															"    //console.log(today)",
															"    return today;   // The function returns the product of p1 and p2",
															"};",
															"",
															"function ConvertDate(today) {",
															"    // Online Javascript Editor for free",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler",
															"    ",
															"    var dd = String(today.getDate()).padStart(2, '0');",
															"    var mm = String(today.getMonth()).padStart(2, '0'); //January is 0!",
															"    var yyyy = today.getFullYear();",
															"    var h = addZero(today.getHours(), 2);",
															"    var m = addZero(today.getMinutes(), 2);",
															"    var s = addZero(today.getSeconds(), 2);",
															"    var ms = addZero(today.getMilliseconds(), 3);",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
															"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;",
															"    //console.log(today)",
															"    return today;   // The function returns the product of p1 and p2",
															"};",
															"",
															"Date.prototype.addDays = function (days) {",
															"    const date = new Date(this.valueOf());",
															"    date.setDate(date.getDate() + days);",
															"    return date;",
															"}; ",
															"",
															"try {",
															"    // test status code",
															"    pm.test(\"Test Response Status Code\", function(){",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);",
															"    });",
															"",
															"    var jsonData = pm.response.json();",
															"    var jsonDataElements = pm.response.json().value;",
															"",
															"    //MIN number of Records Test",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"    });",
															"    ",
															"    var found_element = jsonDataElements[0];",
															"",
															"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
															"    pm.test(\"Products Name: \" + found_element[\"Name\"], function (){",
															"        pm.expect(found_element[\"Name\"]).to.be.a(\"string\");",
															"        ",
															"    }); ",
															"",
															"    var current_date = jsonDataElements[0][\"PublicationDate\"];",
															"    console.log(\"Publication date for first element is: \" + current_date);",
															"    ",
															"    const date = new Date(current_date);",
															"    ",
															"    // add days to current date",
															"    const new_date_formatYmd = new_date_Object => date.addDays(2).toISOString();",
															"    new_date = new_date_formatYmd(new Date());",
															"    console.log(new_date_formatYmd(new Date()));",
															"",
															"    var filter_string = pm.iterationData.get(\"FilterParam\");",
															"    var StageOrder_string = pm.iterationData.get(\"StageOrderSearchString\");",
															"    //var filter_string_completed = filter_string +  \" and PublicationDate gt \" + current_date + \" and \"  +  \"PublicationDate lt \" + new_date_formatYmd;",
															"    var filter_string_completed = filter_string + \" and \" + StageOrder_string + \" and PublicationDate gt \" + current_date + \" and \"  +  \"PublicationDate lt \" + new_date;",
															"    ",
															"    console.log(\"FilterParam is: \" + filter_string_completed);",
															"    pm.globals.set(\"SubscriptionFilterParam\", filter_string_completed);",
															"}",
															"",
															"catch (err) {",
															"    pm.test(\"Test Product Listing\", function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter={{FilterParam}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$top",
															"value": "100",
															"disabled": true
														},
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "{{FilterParam}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Create Subscription (with Staging)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"running\"]);\r",
															"};\r",
															"\r",
															"properties_map.FilterParam=function (element) {\r",
															"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
															"    pm.expect(element.FilterParam).to.be.not.equal(null);\r",
															"};\r",
															"\r",
															"properties_map.StageOrder=function (element) {\r",
															"    pm.expect(element.StageOrder).to.be.equal(true);\r",
															"};\r",
															"\r",
															"properties_map.Priority=function (element) {\r",
															"    //pm.expect(element.Priority).to.be.equal(\"number\");\r",
															"    pm.expect(element.Priority).to.be.equal(pm.iterationData.get(\"SubscriptionPriority\"));\r",
															"};\r",
															"\r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"properties_map.NotificationEndpoint=function (element) {\r",
															"    pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Subscription: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Subscription: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, jsonDataElements);\r",
															"    }\r",
															"\r",
															"    pm.globals.set('SubscriptionId', jsonDataElements['Id']);\r",
															"    pm.globals.set('SubscriptionEvent', jsonDataElements['SubscriptionEvent']);\r",
															"    pm.globals.set('SubscriptionStatus', jsonDataElements['Status']);\r",
															"    pm.globals.set('SubscriptionPriority', jsonDataElements['Priority']);\r",
															"    pm.globals.set('SubscriptionSubmissionDate', jsonDataElements['SubmissionDate']);\r",
															"    //pm.globals.set('NotificationEndpoint', jsonDataElements['NotificationEndpoint']);\r",
															"    \r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Subscription/entity\",\r\n    \"FilterParam\": \"{{SubscriptionFilterParam}}\",\r\n    \"SubscriptionEvent\": \"created\",\r\n    \"StageOrder\": true,\r\n    \"Priority\": {{SubscriptionPriority}},\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscriptions Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Test product filter name\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Id Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"        \r",
															"    var jsonDataElements = pm.response.json();\r",
															" \r",
															"    //Test subscription id property\r",
															"    var id = pm.globals.get('SubscriptionId');\r",
															"    pm.test(\"Subscription Id: \" + id, function(){\r",
															"        pm.expect(pm.response.text()).to.be.includes(id);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions('{{SubscriptionId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions('{{SubscriptionId}}')"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Status Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    var property = pm.globals.get(\"SubscriptionStatus\");\r",
															"    var key = \"Status\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription SubscriptionEvent Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    var property = pm.globals.get(\"SubscriptionEvent\");\r",
															"    var key = \"SubscriptionEvent\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=SubscriptionEvent eq OData.CSC.SubscriptionEvent'{{SubscriptionEvent}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubscriptionEvent eq OData.CSC.SubscriptionEvent'{{SubscriptionEvent}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription FilterParam Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    //pm.test(\"Test FilterParam \", function(){\r",
															"    //    var filterparam_string = pm.globals.get('FilterString').replaceAll('contains(FilterParam,','').replaceAll(')','')\r",
															"    //    pm.expect(jsonDataElements[0].FilterParam).to.includes(filterparam_string);\r",
															"    //});\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
															"pm.globals.set(\"FilterString\", filter_string.replaceAll('Products?$filter=','').replaceAll('Name','FilterParam'));"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter={{FilterString}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "{{FilterString}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription  SubmissionDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"    //test property\r",
															"    var date = pm.globals.get(\"SubscriptionSubmissionDate\");\r",
															"    var prop_name = \"SubmissionDate\";\r",
															"    pm.test(\"SubmissionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    }); \r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=SubmissionDate ge {{SubscriptionSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate ge {{SubscriptionSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Priority Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    var property = pm.globals.get(\"SubscriptionPriority\");\r",
															"    var key = \"Priority\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property.toString);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=Priority eq {{SubscriptionPriority}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Priority eq {{SubscriptionPriority}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Filter Subscription by StageOrder Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=StageOrder eq true",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "StageOrder eq true"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription Notification Endpoint Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        console.log(\"Subscription found: \" + jsonDataElements.length);\r",
															"    });\r",
															"\r",
															"    var property = pm.iterationData.get(\"NotificationEndpoint\");\r",
															"    var key = \"NotificationEndpoint\"\r",
															"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
															"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
															"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
															"    });\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions"
													],
													"query": [
														{
															"key": "$filter",
															"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
														}
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "LTA Identify products (StageOrder true)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription StageOrder Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) {\r",
															"    pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);\r",
															"};\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"queued\", \"in_progress\", \"completed\", \"failed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage = function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.OrderSize = function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EstimatedDate = function (element) {\r",
															"    pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.CompletedDate = function (element) {\r",
															"    if (element.CompletedDate) {\r",
															"        switch (element.Status) {\r",
															"        case \"completed\":\r",
															"            pm.expect(element.CompletedDate).to.be.a(\"string\");\r",
															"            pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        default:\r",
															"            pm.expect(element.CompletedDate).to.be.equal(null)\r",
															"        }\r",
															"    }\r",
															"}\r",
															"properties_map.EvictionDate = function (element) {\r",
															"    if (element.EvictionDate) {\r",
															"        switch (element.Status) {\r",
															"        case \"completed\":\r",
															"            pm.expect(element.EvictionDate).to.be.a(\"string\");\r",
															"            pm.expect(element.EvictionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"            break;\r",
															"        default:\r",
															"            pm.expect(element.EvictionDate).to.be.equal(null)\r",
															"        }\r",
															"    }\r",
															"}\r",
															"properties_map.Priority = function (element) {\r",
															"    pm.expect(element.Priority).to.be.a(\"number\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order) {\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \" + key + \" for Order: \" + order[key], function () {\r",
															"            properties_map[key](order)\r",
															"        });\r",
															"    } else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Subscription: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    // choose randomly a order\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
															"\r",
															"    pm.globals.set(\"counter_products\", jsonDataElements.length);\r",
															"    console.log(\"Found order: \" + pm.globals.get(\"counter_products\"));\r",
															"    if (jsonDataElements.length !== 0) {\r",
															"        //MIN number of Records Test\r",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"        pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function () {\r",
															"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        });\r",
															"        // extract the order id name, id sensing date for the last result in the array  for the next subsequent tests\r",
															"        pm.test(\"Order Id: \" + randomItems.Id, function () {\r",
															"            pm.expect(randomItems.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);\r",
															"            pm.globals.set(\"OrderId\", randomItems.Id);\r",
															"        });\r",
															"    } else {\r",
															"        console.warn(\"Test Id is skipped for Subscription\");\r",
															"    }\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions('{{SubscriptionId}}')/Orders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions('{{SubscriptionId}}')",
														"Orders"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Send a product download readiness notification to the endpoint (StageOrder true)",
									"item": [
										{
											"name": "LTA Get Product By Order",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    console.log(jsonDataElements[\"Online\"]);\r",
															"\r",
															"    pm.globals.set('ProductId', jsonDataElements.Id);\r",
															"    pm.globals.set(\"ProductName\",jsonDataElements.Name);\r",
															"    pm.test(\"Product Property Online: \" + jsonDataElements.Online, function(){\r",
															"       //pm.expect(jsonDataElements.Online).be.equal(true);\r",
															"       pm.expect(jsonDataElements.Online).to.be.a(\"boolean\");\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})/Product",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})",
														"Product"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Product Download Readiness Notifications",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"console.log(access_token)\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"SubscriptionEvent\": \"created\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"OrderId\": \"{{OrderId}}\",\r\n    \"SubscriptionId\": \"{{SubscriptionId}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\" \r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"function addZero(x, n) {",
													"    while (x.toString().length < n) {",
													"      x = \"0\" + x;",
													"    }",
													"    return x;",
													"}",
													"  ",
													"function GetCurrentDate() {",
													"      // Online Javascript Editor for free",
													"      // Write, Edit and Run your Javascript code using JS Online Compiler",
													"      var today = new Date();",
													"      var dd = String(today.getDate()).padStart(2, '0');",
													"      var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
													"      var yyyy = today.getFullYear();",
													"      var h = addZero(today.getHours() - 2, 2);",
													"      var m = addZero(today.getMinutes(), 2);",
													"      var s = addZero(today.getSeconds(), 2);",
													"      var ms = addZero(today.getMilliseconds(), 3);",
													"      //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
													"      ",
													"      today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':00.000Z';//':00:00.000Z';",
													"      //console.log(today)",
													"      return today;   // The function returns the product of p1 and p2",
													"}",
													"",
													"var date = GetCurrentDate();",
													"",
													"console.log(\"Notification Date is: \" + date);",
													"pm.globals.set(\"NotificationDate\", date);"
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "LTA Check Subscriptions Notification (StageOrder true)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Order Id from Server logs",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var order_id = pm.globals.get(\"OrderId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(order_id));\r",
															"console.log(notification);\r",
															"pm.globals.set(\"NotificationOrderId\",\"false\");\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Order id: \" + order_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(order_id);\r",
															"            console.log(\"Found order id: \" + order_id);\r",
															"        });\r",
															"        \r",
															"        pm.globals.set(\"NotificationOrderId\",\"true\");\r",
															"\r",
															"        //for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //    Object.keys(jsonDataElements[i].request.body).forEach(function (key) {\r",
															"        //        if (jsonDataElements[i].request.body[key].includes(order_id)) {\r",
															"        //            pm.test(\"Test Order id: \" + order_id, function () {\r",
															"        //                pm.expect(jsonDataElements[i].request.body[key]).to.be.includes(order_id);\r",
															"        //                console.log(\"Found Order id: \" + order_id);\r",
															"        //            });\r",
															"\r",
															"        //        }\r",
															"        //    });\r",
															"        //}\r",
															"\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Get Subscription Id from Server logs",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var subscription_id = pm.globals.get(\"SubscriptionId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(subscription_id));\r",
															"pm.globals.set(\"NotificationSubscriptionId\", \"false\");\r",
															"console.log(notification);\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Subscription id: \" + subscription_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(subscription_id);\r",
															"            console.log(\"Found Subscription id: \" + subscription_id);\r",
															"        });\r",
															"        pm.globals.set(\"NotificationSubscriptionId\", \"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "LTA Cancel Subscriptions with Staging (StageOrder true)",
									"item": [
										{
											"name": "LTA Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription pause",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Pause",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions({{SubscriptionId}})",
														"OData.CSC.Pause"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription resume",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Resume",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions({{SubscriptionId}})",
														"OData.CSC.Resume"
													]
												}
											},
											"response": []
										},
										{
											"name": "LTA Subscription cancel",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
															"    });\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Subscriptions({{SubscriptionId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"function addZero(x, n) {",
													"    while (x.toString().length < n) {",
													"      x = \"0\" + x;",
													"    }",
													"    return x;",
													"}",
													"  ",
													"function GetCurrentDate() {",
													"      // Online Javascript Editor for free",
													"      // Write, Edit and Run your Javascript code using JS Online Compiler",
													"      var today = new Date();",
													"      var dd = String(today.getDate()).padStart(2, '0');",
													"      var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
													"      var yyyy = today.getFullYear();",
													"      var h = addZero(today.getHours() - 2, 2);",
													"      var m = addZero(today.getMinutes(), 2);",
													"      var s = addZero(today.getSeconds(), 2);",
													"      var ms = addZero(today.getMilliseconds(), 3);",
													"      //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
													"      ",
													"      today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':00.000Z';//':00:00.000Z';",
													"      //console.log(today)",
													"      return today;   // The function returns the product of p1 and p2",
													"}",
													"",
													"var date = GetCurrentDate();",
													"",
													"console.log(\"Notification Date is: \" + date);",
													"pm.globals.set(\"NotificationDate\", date);"
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"if(pm.environment.get('execute_admin_requests') == \"true\"){",
									"       console.warn(\"Unable to send request as administrator!\");",
									"       postman.setNextRequest(null); ",
									"   }   ",
									"",
									"",
									"if(!pm.iterationData.get('NotificationEndpoint')){",
									"       postman.setNextRequest(null); ",
									"   }   ",
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				}
			],
			"description": "The purpose of **\"Long Term Archive ICD_v1.9\"** is to specify the interfaces of the Long Term Archive (LTA) and describe the test suite which may be performed using the Postman collection.",
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "PRIP Extended Compliance",
			"item": [
				{
					"name": "PRIP Products",
					"item": [
						{
							"name": "PRIP Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"\r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Products Listing Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonData = pm.response.json();",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"   //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
											"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    pm.test(\"Product name : \" + randomItems[\"Name\"], function (){",
											"        pm.globals.set(\"ProductName\",randomItems[\"Name\"])",
											"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"Product Id : \" + randomItems[\"Id\"], function (){",
											"        pm.globals.set(\"ProductId\",randomItems[\"Id\"])",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); ",
											"    });",
											"",
											"    pm.test(\"ContentType : \" + randomItems[\"ContentType\"], function (){",
											"        pm.globals.set(\"ContentType\",randomItems[\"ContentType\"])",
											"        pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"ContentLength : \" + randomItems[\"ContentLength\"], function (){",
											"        pm.globals.set(\"ContentLength\",randomItems[\"ContentLength\"])",
											"        pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"    });",
											"    ",
											"    pm.test(\"Origin date : \" + randomItems[\"OriginDate\"], function (){",
											"        pm.globals.set(\"OriginDate\",randomItems[\"OriginDate\"])",
											"        pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"    });",
											"",
											"    pm.test(\"Publication date : \" + randomItems[\"PublicationDate\"], function (){",
											"        pm.globals.set(\"PublicationDate\",randomItems[\"PublicationDate\"])",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"    });",
											"",
											"    pm.test(\"Eviction date : \" + randomItems[\"EvictionDate\"], function (){",
											"        pm.globals.set(\"EvictionDate\",randomItems[\"EvictionDate\"])",
											"        pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"    });",
											"",
											"    pm.test(\"Checksum algorithm : \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function (){",
											"        pm.globals.set(\"ChecksumAlgorithm\",randomItems[\"Checksum\"][0][\"Algorithm\"])",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"    });",
											"    ",
											"    pm.test(\"Checksum value : \" + randomItems[\"Checksum\"][0][\"Value\"], function (){",
											"        pm.globals.set(\"ChecksumValue\",randomItems[\"Checksum\"][0][\"Value\"])",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"           //console.log(\"Checksum value of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"Value\"]);",
											"    });",
											"    ",
											"    pm.test(\"Checksum date : \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function (){",
											"        pm.globals.set(\"ChecksumDate\",randomItems[\"Checksum\"][0][\"ChecksumDate\"])",
											"        pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"        //console.log(\"ChecksumDate of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"ChecksumDate\"]);",
											"    });",
											"",
											"    pm.test(\"Start sensing date : \" + randomItems[\"ContentDate\"][\"Start\"], function (){",
											"        pm.globals.set(\"Start\",randomItems[\"ContentDate\"][\"Start\"])",
											"        pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"    });",
											"",
											"    pm.test(\"End sensing date : \" + randomItems[\"ContentDate\"][\"End\"], function (){",
											"        pm.globals.set(\"End\",randomItems[\"ContentDate\"][\"End\"])",
											"        pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"    });",
											"    ",
											"    pm.test(\"Production type : \" + randomItems[\"ProductionType\"], function (){",
											"        pm.expect(randomItems[\"ProductionType\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ProductionType\",randomItems[\"ProductionType\"])",
											"    });",
											"    ",
											"    if (randomItems[\"Footprint\"]) {",
											"        pm.test(\"Footprint: \" + randomItems[\"Footprint\"], function (){",
											"        pm.expect(randomItems[\"Footprint\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"Footprint\",randomItems[\"Footprint\"]);",
											"        }); ",
											"    }",
											"    else {",
											"        console.warn(\"Not found Footprint: \" + randomItems.Name);",
											"        pm.globals.set(\"Footprint\", undefined);",
											"    }",
											"",
											"    if (randomItems[\"GeoFootprint\"]) {",
											"        let geofootprint_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"        let geofootprint_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"        pm.test('GeoFootprint:{\"type\": ' + geofootprint_type + ', \"coordinates\": [' + geofootprint_coordinates + ']}', function (){",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"           pm.globals.set(\"GeoFootprintCoordinates\",geofootprint_coordinates);",
											"           pm.globals.set(\"GeoFootprintType\",geofootprint_type);",
											"        }); ",
											"    }",
											"    else {",
											"        console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"        pm.globals.set(\"GeoFootprint\", undefined);",
											"    }",
											"     ",
											"    var len_array = randomItems[\"Name\"].split('.').length",
											"    pm.globals.set(\"StartStringName\",randomItems[\"Name\"].split('_')[0] + '_' + randomItems[\"Name\"].split('_')[1])",
											"    pm.globals.set(\"EndStringName\",randomItems[\"Name\"].split('.')[len_array-1])",
											"    pm.globals.set(\"StringName\",randomItems[\"Name\"].split('_')[2])",
											"    pm.globals.set(\"StringName2\",randomItems[\"Name\"].split('_')[3])",
											"           ",
											"    if(randomItems[\"Name\"].split('_')[0].includes('2')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('2','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('2','1'));",
											"    }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('1')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('1','2'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('1','2'));",
											"    }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('3')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('3','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('3','1'));",
											"    }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('5')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('5','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('5','1'));",
											"",
											"    }",
											"    ",
											"    var randomItems1 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems2 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems3 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"",
											"    pm.globals.set(\"product1\",randomItems1[\"Name\"])",
											"    pm.globals.set(\"product2\",randomItems2[\"Name\"])",
											"    pm.globals.set(\"product3\",randomItems3[\"Name\"])",
											"",
											"       ",
											"    //}",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test Product Listing\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Name",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											" ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        //var name = pm.globals.get(\"ProductName\");",
											"        //pm.expect(pm.response.text()).to.includes(name); ",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const product_name = pm.globals.get(\"ProductName\");\r",
											"\r",
											"const name = \"Name eq '\" + product_name + \"'\";\r",
											"const contains_string = \"contains(Name,'_\" + product_name.split('_')[1] + '_' +product_name.split('_')[2] + \"_\" + product_name.split('_')[3] + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + product_name.split('_')[0] + \"_\" + product_name.split('_')[1] + \"')\";\r",
											"\r",
											"var len_array = product_name.split('.').length;\r",
											"const end_string = \"endswith(Name,'\" + product_name.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"let StringObjects = [name,contains_string,start_string,end_string];\r",
											"var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",itemStringObjects);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{QueryByNameString}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By OriginDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"OriginDate\");",
											"    var prop_name = \"OriginDate\";",
											"    pm.test(\"OriginDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OriginDate ge {{OriginDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OriginDate ge {{OriginDate}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Publication Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"StartPublicationDate\");",
											"    var prop_name = \"PublicationDate\";",
											"    pm.test(\"PublicationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });    ",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"  date.setDate(date.getDate() + days);\r",
											"\r",
											"  return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"\r",
											"const start_date = new Date(publication_date);\r",
											"const StartNewDate =  addDays(start_date, -5);\r",
											"\r",
											"\r",
											"pm.globals.set(\"StartPublicationDate\",StartNewDate);;"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=PublicationDate gt {{StartPublicationDate}} and ProductionType eq OData.CSC.ProductionType'systematic_production'",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate gt {{StartPublicationDate}} and ProductionType eq OData.CSC.ProductionType'systematic_production'",
											"description": "Simple Property PublicationDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Sensing Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"   ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"Start\");",
											"    var prop_name = \"ContentDate\";",
											"    pm.test(\"Sensing Date: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name][\"Start\"])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
											"description": "Complex Property ContentDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By EvictionDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"EvictionDate\");",
											"    var prop_name = \"EvictionDate\";",
											"    pm.test(\"EvictionDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(!pm.globals.get(\"Footprint\") && !pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"PRIP Product Query By Size\");\r",
											"    }\r",
											"\r",
											"if(!pm.globals.get(\"Footprint\") && pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"PRIP Product Query By Geographic Criteria (GeoFootprint)\");\r",
											"    }"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=EvictionDate ge {{EvictionDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "EvictionDate ge {{EvictionDate}}",
											"description": "Complex Property EvictionDate"
										},
										{
											"key": "$top",
											"value": "10",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Geographic Criteria (Footprint)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    //test property",
											"    var id = pm.globals.get(\"ProductId\");",
											"    const result = jsonDataElements.find(m => m.Id === id);",
											"",
											"    pm.test(\"Footprint\", function(){",
											"        pm.expect(id).to.equal(result.Id);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(!pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"PRIP Product Query By Size\");\r",
											"    }"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OData.CSC.Intersects(area={{Footprint}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OData.CSC.Intersects(area={{Footprint}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Geographic Criteria (GeoFootprint)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    //test property",
											"    var id = pm.globals.get(\"ProductId\");",
											"    const result = jsonDataElements.find(m => m.Id === id);",
											"",
											"    pm.test(\"GeoFootprint\", function(){",
											"        pm.expect(id).to.equal(result.Id);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"var geofoot_coordinates = pm.globals.get(\"GeoFootprintCoordinates\");\r",
											"// provide geofootprint string\r",
											"if (geofoot_coordinates) {\r",
											"    var geofoot_type = pm.globals.get(\"GeoFootprintType\");\r",
											"    let geofoot = '';\r",
											"    for (let i = 0; i < geofoot_coordinates.length; i++) {\r",
											"        if(i !== geofoot_coordinates.length-1){\r",
											"            geofoot += String(geofoot_coordinates[i]).replace(',', ' ') + ',';\r",
											"        }else{\r",
											"            geofoot += String(geofoot_coordinates[i]).replace(',', ' ');\r",
											"        }  \r",
											"    } \r",
											"    let geofoot_string = [\"geography'SRID=4326;\", String(geofoot_type), \"((\", String(geofoot), \"))'\"].join('');\r",
											"    pm.globals.set(\"GeoFootprintSearchString\",geofoot_string);\r",
											"    \r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OData.CSC.Intersects(area={{GeoFootprintSearchString}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$filter",
											"value": "OData.CSC.Intersects(area={{GeoFootprintSearchString}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Size",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    //test property",
											"    var prop_name = \"ContentLength\";",
											"    pm.test(\"ContentLength: \" + jsonDataElements[0][prop_name], function(){",
											"        for (let item of jsonDataElements) {",
											"            pm.expect(parseInt(pm.globals.get(prop_name))).to.equal(item[prop_name]);",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentLength eq {{ContentLength}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentLength eq {{ContentLength}}",
											"description": "Size property"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By ProductionType",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    //test property",
											"    var prop_name = \"ProductionType\";",
											"    pm.test(\"ProductionType: \" + jsonDataElements[0][prop_name], function(){",
											"        for (let item of jsonDataElements) {",
											"            pm.expect(pm.globals.get(prop_name)).to.equal(item[prop_name]);",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ProductionType eq OData.CSC.ProductionType'{{ProductionType}}'",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ProductionType eq OData.CSC.ProductionType'{{ProductionType}}'",
											"description": "Complex Property ContentDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json();",
											" ",
											"    // test correct odata context is returned",
											"   var jsonDataElements = pm.response.json();",
											"    var id = pm.globals.get(\"ProductId\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Test product id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"        //check the product status",
											"        console.log(\"Product: \" + jsonDataElements.Name);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
											"       postman.setNextRequest(\"PRIP Product Attributes Expand Query\"); \r",
											"   }   "
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Download By ProductId",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"try {\r",
											"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    \r",
											"    //console.log(pm.response);\r",
											"\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200,202,206]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Downloaded Size\", function(){\r",
											"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
											"    });\r",
											"\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"protocolProfileBehavior": {
								"followAuthorizationHeader": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/$value",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})",
										"$value"
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Attributes Expand Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function propertySpecific(key, attr, items) {",
											"    const ProductObject = items.Attributes.find(m => m.Name === attr[key]);",
											"    //console.log(ProductObject);",
											"    if (ProductObject !== undefined) {",
											"        pm.test(\"Response body contains \" + attr[key], function() {",
											"            pm.expect(ProductObject).not.eq(undefined);",
											"            pm.expect(ProductObject.Name).to.be.a(\"string\");",
											"            pm.expect(ProductObject.ValueType).to.be.a(\"string\");",
											"            pm.expect(ProductObject.Value).not.eq(undefined)",
											"            pm.globals.set(ProductObject.Name, ProductObject.Value);",
											"            pm.globals.set(\"flag_\" + ProductObject.Name, \"true\");",
											"        });",
											"    } else {",
											"        console.warn(\"Skipped \" + attr[key] + \" attribute test\");",
											"    }",
											"}",
											"",
											"// attributes",
											"const elements_s1 = [\"beginningDateTime\", \"endingDateTime\", \"startTimeFromAscendingNode\", \"completionTimeFromAscendingNode\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"operationalMode\", \"polarisationChannels\", \"orbitNumber\", \"relativeOrbitNumber\", \"cycleNumber\", \"orbitDirection\", \"coordinates\", \"productType\", \"productClass\", \"productConsolidation\", \"instrumentConfigurationID\", \"datatakeID\", \"sliceProductFlag\"];",
											"",
											"const elements_s1_aux = [\"processingDate\", \"processingCenter\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"beginningDateTime\", \"productGeneration\", \"instrumentConfigurationID\"];",
											"",
											"const elements_s2 = [\"productGroupId\", \"processorVersion\", \"processingDate\", \"beginningDateTime\", \"endingDateTime\", \"orbitNumber\", \"coordinates\", \"qualityStatus\", \"productType\", \"instrumentShortName\", \"processingCenter\", \"platformSerialIdentifier\", \"platformShortName\", \"operationalMode\", \"relativeOrbitNumber\"]",
											"",
											"const elements_s2_aux = [\"platformShortName\", \"platformSerialIdentifier\", \"productType\", \"beginningDateTime\", \"endingDateTime\", \"processingCenter\", \"processorVersion\", \"processingDate\"];",
											"",
											"const elements_s3 = [\"beginningDateTime\", \"endingDateTime\", \"instrumentShortName\", \"productType\", \"timeliness\", \"orbitNumber\", \"lastOrbitNumber\", \"relativeOrbitNumber\", \"cycleNumber\", \"processorName\"];",
											"",
											"const elements_s3_aux = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"const elements_pod = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        if (pm.response.code !== 200) {",
											"            postman.setNextRequest(\"PRIP Additional Options (orderby asc)\");",
											"        }",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    pm.globals.set('headers-format', pm.response.headers.get('Content-Type'));",
											"    const header_format = pm.globals.get('headers-format');",
											"    const format = \"application/json\"",
											"    const zip_format = \"application/zip\"",
											"",
											"    pm.test(\"Content-Type header is correct\", function() {",
											"        if (header_format.includes(zip_format)) {",
											"            pm.expect(header_format).to.includes(zip_format);",
											"            console.warn(\"The Content-Type header is \" + header_format);",
											"            console.warn(\"The Attributes requests are skipped. \");",
											"            postman.setNextRequest(\"PRIP Additional Options (orderby asc)\");",
											"        } else {",
											"",
											"            if (!header_format.includes(format)) {",
											"                console.warn(\"The Content-Type header is \" + header_format);",
											"                console.warn(\"The Attributes requests are skipped. \");",
											"                postman.setNextRequest(\"PRIP Additional Options (orderby asc)\")",
											"            }",
											"",
											"            pm.expect(header_format).to.includes(format);",
											"        }",
											"    });",
											"",
											"    if (header_format.includes(format)) {",
											"        var jsonDataElements = pm.response.json().value;",
											"",
											"        // extract the attributes for the next subsequent tests",
											"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems1 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems2 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        let productTypeObject1 = randomItems1.Attributes.find(m => m.Name === \"productType\");",
											"        let productTypeObject2 = randomItems2.Attributes.find(m => m.Name === \"productType\");",
											"",
											"        if (productTypeObject1) {",
											"            pm.globals.set(\"productType2\", productTypeObject1[\"Value\"]);",
											"        }",
											"        if (productTypeObject2) {",
											"            pm.globals.set(\"productType3\", productTypeObject2[\"Value\"]);",
											"        }",
											"",
											"        var found_element;",
											"        var name = randomItems.Name",
											"        if (name.startsWith('S1') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s1;",
											"        } else if (name.startsWith('S1') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s1_aux;",
											"        } else if (name.startsWith('S2') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s2;",
											"        } else if (name.startsWith('S2') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s2_aux;",
											"        } else if (name.startsWith('S3') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s3;",
											"        } else if (name.startsWith('S3') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s3_aux;",
											"        } else {",
											"            found_element = elements_pod;",
											"        }",
											"",
											"        // check properties",
											"        pm.test(\"Product name : \" + randomItems[\"Name\"], function() {",
											"            pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Product Id : \" + randomItems[\"Id\"], function() {",
											"            pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        });",
											"",
											"        pm.test(\"ContentType : \" + randomItems[\"ContentType\"], function() {",
											"            pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"ContentLength : \" + randomItems[\"ContentLength\"], function() {",
											"            pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"        });",
											"",
											"        pm.test(\"Origin date : \" + randomItems[\"OriginDate\"], function() {",
											"            pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Publication date : \" + randomItems[\"PublicationDate\"], function() {",
											"            pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Eviction date : \" + randomItems[\"EvictionDate\"], function() {",
											"            pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Checksum algorithm : \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum value : \" + randomItems[\"Checksum\"][0][\"Value\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum date : \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Start sensing date : \" + randomItems[\"ContentDate\"][\"Start\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"End sensing date : \" + randomItems[\"ContentDate\"][\"End\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Production type : \" + randomItems[\"ProductionType\"], function() {",
											"            pm.expect(randomItems[\"ProductionType\"]).to.be.a(\"string\");",
											"        });",
											"",
											"",
											"        if (randomItems[\"Footprint\"]) {",
											"            pm.test(\"Footprint: \" + randomItems[\"Footprint\"], function() {",
											"                pm.expect(randomItems[\"Footprint\"]).to.be.a(\"string\");",
											"            });",
											"        } else {",
											"            console.warn(\"Not found Footprint: \" + randomItems.Name);",
											"        }",
											"",
											"        if (randomItems[\"GeoFootprint\"]) {",
											"            let geofootprint_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"            let geofootprint_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"            pm.test('GeoFootprint:{\"type\": ' + geofootprint_type + ', \"coordinates\": [' + geofootprint_coordinates + ']}', function() {",
											"                pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"                pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"            });",
											"        } else {",
											"            console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"        }",
											"",
											"        // Test that the correct odata context is returned",
											"        console.log(\"Test that the correct attributes are returned for product: \" + name);",
											"        for (var key in found_element) {",
											"            propertySpecific(key, found_element, randomItems);",
											"        }",
											"",
											"        const processor_version = randomItems.Attributes.find(m => m.Name === \"processorVersion\");",
											"        if (processor_version !== undefined) {",
											"            //console.log(processor_version);",
											"            pm.globals.set(processor_version.Name, processor_version.Value);",
											"            pm.globals.set(\"flag_processorVersion\", \"true\");",
											"        }",
											"    }",
											"",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}&$top=100&$expand=Attributes&$format=json",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}"
										},
										{
											"key": "$top",
											"value": "100"
										},
										{
											"key": "$expand",
											"value": "Attributes"
										},
										{
											"key": "$format",
											"value": "json"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (InstrumentShortName)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_InstrumentShortName\") === \"true\"){",
											"    try {",
											"      // test status code",
											"      pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"      });",
											"",
											"      var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (beginningDateTime)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_beginningDateTime\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'beginningDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{beginningDateTime}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'beginningDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{beginningDateTime}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (endingDateTime)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_endingDateTime\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        ",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'endingDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{endingDateTime}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'endingDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{endingDateTime}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (operationalMode)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_operationalMode\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"   console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'operationalMode' and att/OData.CSC.StringAttribute/Value eq '{{operationalMode}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'operationalMode' and att/OData.CSC.StringAttribute/Value eq '{{operationalMode}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (orbitNumber)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_orbitNumber\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (processingDate)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_processingDate\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (productGroupId)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productGroupId\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"   console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productGroupId' and att/OData.CSC.StringAttribute/Value eq '{{productGroupId}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productGroupId' and att/OData.CSC.StringAttribute/Value eq '{{productGroupId}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (qualityStatus)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_qualityStatus\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'qualityStatus' and att/OData.CSC.StringAttribute/Value eq '{{qualityStatus}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'qualityStatus' and att/OData.CSC.StringAttribute/Value eq '{{qualityStatus}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (productClass)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productClass\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"   console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productClass' and att/OData.CSC.StringAttribute/Value eq '{{productClass}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productClass' and att/OData.CSC.StringAttribute/Value eq '{{productClass}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (timeliness)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_timeliness\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (combining productType and processorVersion)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productType\") === \"true\" && pm.globals.get(\"flag_processorVersion\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Product Query By Attributes (combining platformShortName & platformSerialIdentifier)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_platformShortName\") === \"true\" && pm.globals.get(\"flag_platformSerialIdentifier\") === \"true\"){",
											"    try {",
											"        // test status code",
											"        pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        var jsonDataElements = pm.response.json().value;",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"   console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (orderby asc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyAsc}} asc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyAsc}} asc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (orderby desc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyDesc}} desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}} desc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (top)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$top={{top}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$top",
											"value": "{{top}}",
											"description": "Specify the maximum (non-negative integer) number of items returned"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (skip)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$skip={{skip}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$skip",
											"value": "{{skip}}",
											"description": "Specify a (non-negative integer) number of items excluded from the start"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (count)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    // verify that the number of the matching resources is returned as result.",
											"    var data_counter = pm.response.json()[\"@odata.count\"];",
											"    pm.test(\"The number of the matching resources is returned: \" + data_counter, function(){",
											"        pm.expect(data_counter).to.be.a(\"number\");",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$count=true&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$count",
											"value": "true",
											"description": "Request a count of the matching resources"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (Operator \"not\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"    \r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator NOT returns at least the expected minimum number of products: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=startswith(Name,'{{StartStringName}}')  and not contains(Name,'{{StringNameNot}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')  and not contains(Name,'{{StringNameNot}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (Operator \"in\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_productType\") === \"true\") {\r",
											"    try {\r",
											"\r",
											"        // test status code\r",
											"        pm.test(\"Test Response Status Code\", function () {\r",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"        });\r",
											"\r",
											"        var jsonDataElements = pm.response.json().value;\r",
											"\r",
											"        //MIN number of Records Test\r",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"        pm.test(\"Test operator IN returns at least the expected minimum number of products: \" + minimumExpRecords, function () {\r",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"        });\r",
											"    } catch (err) {\r",
											"        pm.test(request.name, function () {\r",
											"            pm.expect.fail(err.toString());\r",
											"        });\r",
											"    }\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value in ('{{productType}}','{{productType2}}','{{productType3}}'))",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value in ('{{productType}}','{{productType2}}','{{productType3}}'))"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (Operator \"or\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator OR returns at least the expected minimum number of products: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=contains(Name,'{{StringName}}') or contains(Name,'{{StringName2}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "contains(Name,'{{StringName}}') or contains(Name,'{{StringName2}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "PRIP Additional Options (Operator \"and\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"\r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator AND returns at least the expected minimum number of products: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=startswith(Name,'{{StartStringName}}') and endswith(Name,'{{EndStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}') and endswith(Name,'{{EndStringName}}')"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "PRIP Subscriptions",
					"item": [
						{
							"name": "PRIP Create Subscriptions",
							"item": [
								{
									"name": "PRIP Get Token",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const jsonData = pm.response.json();\r",
													"    const access_token = jsonData.access_token;\r",
													"    pm.test(\"A token is returned\", function() {\r",
													"    pm.expect(pm.response.text()).to.include('access_token');\r",
													"   });\r",
													"   pm.globals.set(\"access_token\", access_token);\r",
													"}else{\r",
													"    console.log('Skip token verification');\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
													"    \r",
													"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"username\");\r",
													"        pm.request.body.urlencoded.remove(\"password\"); \r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"\r",
													"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
													"    }\r",
													"\r",
													"    pm.request.headers.upsert({\r",
													"        'key': \"Authorization\",\r",
													"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
													"    });\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [
											{
												"key": "Authorization",
												"value": "Basic {{encoded_credential}}"
											},
											{
												"key": "Content-Type",
												"value": "application/x-www-form-urlencoded"
											}
										],
										"body": {
											"mode": "urlencoded",
											"urlencoded": [
												{
													"key": "grant_type",
													"value": "{{grant_type}}",
													"type": "text"
												},
												{
													"key": "username",
													"value": "{{username}}",
													"type": "text"
												},
												{
													"key": "password",
													"value": "{{password}}",
													"type": "text"
												},
												{
													"key": "scope",
													"value": "{{scope}}",
													"type": "text"
												},
												{
													"key": "client_id",
													"value": "{{client_id}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												}
											]
										},
										"url": {
											"raw": "{{access_token_url}}",
											"host": [
												"{{access_token_url}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription Create",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"properties_map = {};\r",
													"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
													"\r",
													"properties_map.Status=function (element) {\r",
													"    pm.expect(element.Status).to.be.a(\"string\");\r",
													"    pm.expect(element.Status).to.be.oneOf([\"running\"]);\r",
													"};\r",
													"\r",
													"properties_map.FilterParam=function (element) {\r",
													"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
													"    pm.expect(element.FilterParam).to.be.not.equal(null);\r",
													"};\r",
													"\r",
													"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
													"\r",
													"properties_map.NotificationEndpoint=function (element) {\r",
													"    pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
													"};\r",
													"\r",
													"\r",
													"function propertySpecific(key, order){\r",
													"    if (properties_map[key]) {\r",
													"        pm.test(\"Test Property \"+key+\" for Subscription: \" + order[key], function(){\r",
													"            properties_map[key](order);\r",
													"            pm.expect(pm.response.text()).to.include(key);});\r",
													"    }\r",
													"    else {\r",
													"        console.warn(\"Test Property \"+key+\" is skipped for Subscription: \" + order[key]);\r",
													"    }\r",
													"};\r",
													"\r",
													"try {\r",
													"    \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
													"    });\r",
													"    \r",
													"    var jsonDataElements = pm.response.json();\r",
													"\r",
													"    for (const[key, value] of Object.entries(properties_map)){\r",
													"        propertySpecific(key, jsonDataElements);\r",
													"    }\r",
													"    \r",
													"    pm.globals.set('SubscriptionId', jsonDataElements['Id']);\r",
													"    pm.globals.set('SubscriptionStatus', jsonDataElements['Status']);\r",
													"    //pm.globals.set('FilterParam', jsonDataElements['FilterParam']);\r",
													"    pm.globals.set('SubmissionDate', jsonDataElements['SubmissionDate']);\r",
													"    //pm.globals.set('NotificationEndpoint', jsonDataElements['NotificationEndpoint']);\r",
													"\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"@odata.context\": \"$metadata#Subscription/entity\",\r\n    \"FilterParam\": \"{{SubscriptionFilterParam}}\",\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Products Listing Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {",
													"",
													"    // test status code",
													"    pm.test(\"Test Response Status Code\", function(){",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);",
													"    });",
													"",
													"    var jsonData = pm.response.json();",
													"    var jsonDataElements = pm.response.json().value;",
													"",
													"   //MIN number of Records Test",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
													"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
													"    });",
													"    ",
													"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
													"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
													"    pm.test(\"Product name : \" + randomItems[\"Name\"], function (){",
													"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
													"        pm.globals.set(\"ProductName\",randomItems[\"Name\"])",
													"    });",
													"",
													"    pm.test(\"Product Id : \" + randomItems[\"Id\"], function (){",
													"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); ",
													"        pm.globals.set(\"ProductId\",randomItems[\"Id\"])",
													"    });",
													"",
													"}",
													"",
													"catch (err) {",
													"    pm.test(\"Test Product Listing\", function () {",
													"        pm.expect.fail(err.toString());",
													"    });",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"var filter_string = pm.globals.get(\"SubscriptionFilterParam\");\r",
													"pm.globals.set(\"FilterProductString\", filter_string.replace('Products?$filter=',''));\r",
													"console.log(filter_string.replaceAll('Products?$filter=','').replaceAll('Name','FilterParam'))"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Products"
											],
											"query": [
												{
													"key": "$filter",
													"value": "{{ProductTypeCode}}"
												},
												{
													"key": "$orderby",
													"value": "PublicationDate desc"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Product Availability Notification",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"    \r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"// Define token access\r",
													"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
													"console.log(access_token)\r",
													"let auth_string\r",
													"if(access_token){\r",
													"   console.log('Use Token Authentication for notification');\r",
													"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
													"}else{\r",
													"   console.log('Not use Token Authentication for notification');\r",
													"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
													"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
													"   if(username){\r",
													"      console.log('Use username and password for notification');\r",
													"      var decoded_string = username + \":\" + password;\r",
													"      // Encode the String\r",
													"      var encoded_string = btoa(decoded_string);\r",
													"      auth_string = \"Basic \" + encoded_string;\r",
													"   }\r",
													"   \r",
													"}\r",
													"\r",
													"// added header\r",
													"pm.request.headers.upsert({\r",
													" 'key': \"Authorization\",\r",
													" 'value': auth_string\r",
													" });"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"SubscriptionId\": \"{{SubscriptionId}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{NotificationEndpoint}}",
											"host": [
												"{{NotificationEndpoint}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscriptions Listing Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"    });\r",
													"    \r",
													"}\r",
													"\r",
													"catch (err) {\r",
													"    pm.test(\"Test product filter name\", function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription Id Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json();\r",
													" \r",
													"    //Test subscription id property\r",
													"    var id = pm.globals.get('SubscriptionId');\r",
													"    pm.test(\"Subscription Id: \" + id, function(){\r",
													"        pm.expect(pm.response.text()).to.be.includes(id);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription Status Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													" \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"    });\r",
													"\r",
													"    var property = pm.globals.get(\"SubscriptionStatus\");\r",
													"    var key = \"Status\"\r",
													"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
													"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
													"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription FilterParam Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													" \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
													"pm.globals.set(\"FilterString\", filter_string.replaceAll('Products?$filter=','').replaceAll('Name','FilterParam'));"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter={{FilterString}}",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "{{FilterString}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription  SubmissionDate Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"    //test property\r",
													"    var date = pm.globals.get(\"SubmissionDate\");\r",
													"    var prop_name = \"SubmissionDate\";\r",
													"    pm.test(\"SubmissionDate: \" + date, function(){\r",
													"        for (let item of jsonDataElements) {\r",
													"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
													"        }\r",
													"    }); \r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=SubmissionDate ge {{SubmissionDate}}",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "SubmissionDate ge {{SubmissionDate}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription NotificationEndpoint Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"\r",
													"    var property = pm.iterationData.get(\"NotificationEndpoint\");\r",
													"    var key = \"NotificationEndpoint\"\r",
													"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
													"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
													"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "PRIP Check Subscriptions Notification",
							"item": [
								{
									"name": "PRIP Get Token",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const jsonData = pm.response.json();\r",
													"    const access_token = jsonData.access_token;\r",
													"    pm.test(\"A token is returned\", function() {\r",
													"    pm.expect(pm.response.text()).to.include('access_token');\r",
													"   });\r",
													"   pm.globals.set(\"access_token\", access_token);\r",
													"}else{\r",
													"    console.log('Skip token verification');\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
													"    \r",
													"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"username\");\r",
													"        pm.request.body.urlencoded.remove(\"password\"); \r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"\r",
													"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
													"    }\r",
													"\r",
													"    pm.request.headers.upsert({\r",
													"        'key': \"Authorization\",\r",
													"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
													"    });\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [
											{
												"key": "Authorization",
												"value": "Basic {{encoded_credential}}"
											},
											{
												"key": "Content-Type",
												"value": "application/x-www-form-urlencoded"
											}
										],
										"body": {
											"mode": "urlencoded",
											"urlencoded": [
												{
													"key": "grant_type",
													"value": "{{grant_type}}",
													"type": "text"
												},
												{
													"key": "username",
													"value": "{{username}}",
													"type": "text"
												},
												{
													"key": "password",
													"value": "{{password}}",
													"type": "text"
												},
												{
													"key": "scope",
													"value": "{{scope}}",
													"type": "text"
												},
												{
													"key": "client_id",
													"value": "{{client_id}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												}
											]
										},
										"url": {
											"raw": "{{access_token_url}}",
											"host": [
												"{{access_token_url}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Get Subscription Id from Server logs",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
													"var subscription_id = pm.globals.get(\"SubscriptionId\");\r",
													"var notification = jsonDataElements.find(m => m.request.body.data.includes(subscription_id));\r",
													"pm.globals.set(\"NotificationSubscriptionId\", \"false\");\r",
													"console.log(notification);\r",
													"if (notification) {\r",
													"    try {\r",
													"        // test status code\r",
													"        pm.test(\"Test Response Status Code\", function () {\r",
													"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Subscription id: \" + subscription_id, function () {\r",
													"            pm.expect(notification.request.body.data).to.be.includes(subscription_id);\r",
													"            console.log(\"Found Subscription id: \" + subscription_id);\r",
													"        });\r",
													"        pm.globals.set(\"NotificationSubscriptionId\", \"true\");\r",
													"\r",
													"    } catch (err) {\r",
													"        pm.test(request.name, function () {\r",
													"            pm.expect.fail(err.toString());\r",
													"        });\r",
													"    }\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "apikey",
											"apikey": [
												{
													"key": "value",
													"value": "{{api_key}}",
													"type": "string"
												},
												{
													"key": "key",
													"value": "X-API-Key",
													"type": "string"
												},
												{
													"key": "in",
													"value": "header",
													"type": "string"
												}
											]
										},
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{ServerLogsUrl}}",
											"host": [
												"{{ServerLogsUrl}}"
											],
											"query": [
												{
													"key": "count",
													"value": "1",
													"disabled": true
												},
												{
													"key": "path",
													"value": "/login",
													"disabled": true
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "PRIP Cancel Subscriptions",
							"item": [
								{
									"name": "PRIP Get Token",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const jsonData = pm.response.json();\r",
													"    const access_token = jsonData.access_token;\r",
													"    pm.test(\"A token is returned\", function() {\r",
													"    pm.expect(pm.response.text()).to.include('access_token');\r",
													"   });\r",
													"   pm.globals.set(\"access_token\", access_token);\r",
													"}else{\r",
													"    console.log('Skip token verification');\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
													"    \r",
													"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"username\");\r",
													"        pm.request.body.urlencoded.remove(\"password\"); \r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"\r",
													"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
													"    }\r",
													"\r",
													"    pm.request.headers.upsert({\r",
													"        'key': \"Authorization\",\r",
													"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
													"    });\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [
											{
												"key": "Authorization",
												"value": "Basic {{encoded_credential}}"
											},
											{
												"key": "Content-Type",
												"value": "application/x-www-form-urlencoded"
											}
										],
										"body": {
											"mode": "urlencoded",
											"urlencoded": [
												{
													"key": "grant_type",
													"value": "{{grant_type}}",
													"type": "text"
												},
												{
													"key": "username",
													"value": "{{username}}",
													"type": "text"
												},
												{
													"key": "password",
													"value": "{{password}}",
													"type": "text"
												},
												{
													"key": "scope",
													"value": "{{scope}}",
													"type": "text"
												},
												{
													"key": "client_id",
													"value": "{{client_id}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												}
											]
										},
										"url": {
											"raw": "{{access_token_url}}",
											"host": [
												"{{access_token_url}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription pause",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
													"    });\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [
											{
												"key": "Content-Type",
												"value": "application/json",
												"type": "text"
											}
										],
										"body": {
											"mode": "raw",
											"raw": "",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Pause",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})",
												"OData.CSC.Pause"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription resume",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
													"    });\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [
											{
												"key": "Content-Type",
												"value": "application/json",
												"type": "text"
											}
										],
										"body": {
											"mode": "raw",
											"raw": "",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Resume",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})",
												"OData.CSC.Resume"
											]
										}
									},
									"response": []
								},
								{
									"name": "PRIP Subscription cancel",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200,204,202]);\r",
													"    });\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [
											{
												"key": "Content-Type",
												"value": "application/json",
												"type": "text"
											}
										],
										"body": {
											"mode": "raw",
											"raw": "",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Cancel",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})",
												"OData.CSC.Cancel"
											]
										}
									},
									"response": []
								}
							]
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"function addZero(x, n) {",
									"    while (x.toString().length < n) {",
									"      x = \"0\" + x;",
									"    }",
									"    return x;",
									"};",
									"",
									"function GetCurrentDate() {",
									"    // Online Javascript Editor for free",
									"    // Write, Edit and Run your Javascript code using JS Online Compiler",
									"    var today = new Date();",
									"    var dd = String(today.getDate()).padStart(2, '0');",
									"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
									"    var yyyy = today.getFullYear();",
									"    var h = addZero(today.getHours(), 2);",
									"    var m = addZero(today.getMinutes(), 2);",
									"    var s = addZero(today.getSeconds(), 2);",
									"    var ms = addZero(today.getMilliseconds(), 3);",
									"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
									"    ",
									"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;",
									"    //console.log(today)",
									"    return today;   // The function returns the product of p1 and p2",
									"};",
									"",
									"function ConvertDate(today) {",
									"    // Online Javascript Editor for free",
									"    // Write, Edit and Run your Javascript code using JS Online Compiler",
									"    ",
									"    var dd = String(today.getDate()).padStart(2, '0');",
									"    var mm = String(today.getMonth()).padStart(2, '0'); //January is 0!",
									"    var yyyy = today.getFullYear();",
									"    var h = addZero(today.getHours(), 2);",
									"    var m = addZero(today.getMinutes(), 2);",
									"    var s = addZero(today.getSeconds(), 2);",
									"    var ms = addZero(today.getMilliseconds(), 3);",
									"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
									"    var time = \"00:00:00.000000\"",
									"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;",
									"    //console.log(today)",
									"    return today;   // The function returns the product of p1 and p2",
									"};",
									"",
									"Date.prototype.addDays = function (days) {",
									"    const date = new Date(this.valueOf());",
									"    date.setDate(date.getDate() + days);",
									"    return date;",
									"};",
									"  ",
									"",
									"var current_date = GetCurrentDate();",
									"const date = new Date(current_date);",
									"    ",
									"// add days to current date",
									"const new_date_formatYmd = new_date_Object => date.addDays(2).toISOString();",
									"new_date = new_date_formatYmd(new Date());",
									"console.log(new_date_formatYmd(new Date()));",
									"",
									"var filter_string = pm.iterationData.get(\"FilterParam\");",
									"var filter_string_completed = filter_string +  \" and PublicationDate gt \" + current_date + \" and \"  +  \"PublicationDate lt \" + new_date;",
									"  ",
									"console.log(\"FilterParam is: \" + filter_string_completed);",
									"//pm.globals.set(\"FilterParam\", pm.iterationData.get(\"FilterParamString\") + \" PublicationDate gt \" + yesterday_converted + time + \" and \"  +  \"PublicationDate lt \" + date + time)",
									"pm.globals.set(\"SubscriptionFilterParam\", filter_string_completed);",
									"//pm.globals.set(\"FilterString\", filter_string_completed.replace('Products?$filter=',''));",
									"",
									"console.log(\"Notification Date is: \" + current_date);",
									"pm.globals.set(\"NotificationDate\", current_date);",
									"",
									"if(pm.environment.get('execute_admin_requests') == \"true\"){",
									"       console.warn(\"Unable to send request as administrator!\");",
									"       postman.setNextRequest(null); ",
									"   }   ",
									"",
									"if(!pm.iterationData.get('NotificationEndpoint')){",
									"       postman.setNextRequest(null); ",
									"   }   "
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "PRIP Workflow and ProductionOrder (all cases)",
					"item": [
						{
							"name": "PRIP Workflow and ProductionOrder",
							"item": [
								{
									"name": "PRIP Workflow Query",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test workflows Id: \" + randomItems[\"Id\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Id\"]);\r",
															"           pm.globals.set(\"WorkflowId\",randomItems[\"Id\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Name: \" + randomItems[\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Name\"])\r",
															"           pm.globals.set(\"WorkflowName\",randomItems[\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Description: \" + randomItems[\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Description\"])\r",
															"           pm.globals.set(\"WorkflowDescription\",randomItems[\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows InputProductType: \" + randomItems[\"InputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"InputProductType\"])\r",
															"           pm.globals.set(\"InputProductType\",randomItems[\"InputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows OutputProductType: \" + randomItems[\"OutputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"OutputProductType\"])\r",
															"           pm.globals.set(\"OutputProductType\",randomItems[\"OutputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows WorkflowVersion: \" + randomItems[\"WorkflowVersion\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowVersion\"])\r",
															"           pm.globals.set(\"WorkflowVersion\",randomItems[\"WorkflowVersion\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflow Options Name: \" + randomItems[\"WorkflowOptions\"][0][\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Description: \" + randomItems[\"WorkflowOptions\"][0][\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Description\",randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Type: \" + randomItems[\"WorkflowOptions\"][0][\"Type\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Type\",randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options value: \" + randomItems[\"WorkflowOptions\"][0][\"Value\"][0], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"           pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?expand=WorkflowOptions&$filter={{ProductTypeCodeForWorkflow}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "expand",
															"value": "WorkflowOptions"
														},
														{
															"key": "$filter",
															"value": "{{ProductTypeCodeForWorkflow}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow Id Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowId\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=Id eq '{{WorkflowId}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "Id eq '{{WorkflowId}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow Name Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowName\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=Name eq '{{WorkflowName}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "Name eq '{{WorkflowName}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow Description Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowDescription\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=Description eq '{{WorkflowDescription}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "Description eq '{{WorkflowDescription}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow InputProductType Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"InputProductType\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=InputProductType eq '{{InputProductType}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "InputProductType eq '{{InputProductType}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow OutputProductType Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"OutputProductType\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=OutputProductType eq '{{OutputProductType}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "OutputProductType eq '{{OutputProductType}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow Version Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowVersion\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=WorkflowVersion eq '{{WorkflowVersion}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "WorkflowVersion eq '{{WorkflowVersion}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP ProductionOrder Submission (no notification)",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Product Query By Attributes (productType)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.globals.get(\"flag_productType\") == \"true\"){",
															"    try {",
															"        // test status code",
															"        pm.test(\"Test Response Status Code\", function(){",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);",
															"        }); ",
															"        ",
															"        var jsonDataElements = pm.response.json().value;",
															"        //MIN number of Records Test",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
															"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"        });",
															"        //extract prodiuct properties (product name, id, sensing date)",
															"        const sizeLimit = 150000000;",
															"        var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
															"        ",
															"        let i = 0;",
															"        console.log(jsonDataElements[i].ContentLength)",
															"        while(i < jsonDataElements.length){",
															"           if(jsonDataElements[i].ContentLength < sizeLimit){",
															"               randomItems = jsonDataElements[i];",
															"               ",
															"               console.log(randomItems)",
															"               break;",
															"           }",
															"           i++;",
															"           //console.log(i)",
															"        }",
															"      ",
															"        pm.globals.set(\"ProductName\", randomItems.Name);",
															"        pm.globals.set(\"ProductId\", randomItems.Id);",
															"        pm.globals.set(\"Start\", randomItems.ContentDate.Start);",
															"        pm.globals.set(\"End\", randomItems.ContentDate.End);",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}",
															"}",
															" "
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')&$orderby=PublicationDate desc",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')",
															"description": "Query by Attributes"
														},
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Request",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    //checki if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, randomItems);\r",
															"    }\r",
															"\r",
															"    pm.globals.set(\"ProductionOrdersId\",randomItems[\"Id\"]);\r",
															"    pm.globals.set(\"ProductionOrdersStatus\",randomItems[\"Status\"])\r",
															"    pm.globals.set(\"ProductionOrdersStatusMessage\",randomItems[\"StatusMessage\"])\r",
															"    pm.globals.set(\"ProductionOrdersSubmissionDate\",randomItems[\"SubmissionDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersEstimatedDate\",randomItems[\"EstimatedDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersPriority\",randomItems[\"Priority\"])\r",
															"    pm.globals.set(\"ProductName\",randomItems[\"InputProductReference\"][0][\"Reference\"])\r",
															"    pm.globals.set(\"Start\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"Start\"])\r",
															"    pm.globals.set(\"End\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"End\"])\r",
															"    pm.globals.set(\"WorkflowId\",randomItems[\"WorkflowId\"])\r",
															"    pm.globals.set(\"WorkflowName\",randomItems[\"WorkflowName\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0])\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"//pm.globals.unset(\"download_counter\");"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"InputProductReference\": {\r\n        \"Reference\": \"{{ProductName}}\",\r\n        \"ContentDate\": {\r\n            \"Start\": \"{{Start}}\",\r\n            \"End\": \"{{End}}\"\r\n        }\r\n    }, \r\n    \"Priority\": {{ProductionOrderPriority}},\r\n    \"WorkflowId\": \"{{WorkflowId}}\",\r\n    \"WorkflowName\": \"{{WorkflowName}}\",\r\n    \"WorkflowOptions\": [\r\n        {\r\n            \"Name\": \"{{WorkflowOptions_Name}}\",\r\n            \"Value\": \"{{WorkflowOptions_Value}}\"\r\n        }\r\n    ]\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder List",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By Id",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersId\");\r",
															"        //pm.expect(pm.response.text()).to.includes(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var production_order = jsonDataElements;\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, production_order);\r",
															"        pm.globals.set(\"ProductionOrder\" + key, production_order[key])\r",
															"    }\r",
															"    \r",
															"    if(production_order.Status == \"completed\"){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\", production_order.Id);\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\", production_order.CompletedDate);\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",production_order.EvictionDate);\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",production_order.OrderOutputSize);\r",
															"    }\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders('{{ProductionOrdersId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders('{{ProductionOrdersId}}')"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By Status",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersStatus\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Status eq '{{ProductionOrdersStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq '{{ProductionOrdersStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By StatusMessage",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersStatusMessage\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Status eq '{{ProductionOrdersStatusMessage}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq '{{ProductionOrdersStatusMessage}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By SubmissionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersSubmissionDate\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=SubmissionDate eq {{ProductionOrdersSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate eq {{ProductionOrdersSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By EstimatedDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersEstimatedDate\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=EstimatedDate eq {{ProductionOrdersEstimatedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EstimatedDate eq {{ProductionOrdersEstimatedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By Priority",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersPriority\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Priority eq {{ProductionOrdersPriority}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Priority eq {{ProductionOrdersPriority}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By InputProductReference (Name)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=InputProductReference/any(att:att/Reference eq '{{ProductName}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "InputProductReference/any(att:att/Reference eq '{{ProductName}}')"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By InputProductReference (ContentDate)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=InputProductReference/any(att:att/ContentDate gt {{Start}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "InputProductReference/any(att:att/ContentDate gt {{Start}})"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By WorkflowId",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=WorkflowId eq '{{WorkflowId}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "WorkflowId eq '{{WorkflowId}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By WorkflowName",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=WorkflowName eq '{{WorkflowName}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "WorkflowName eq '{{WorkflowName}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By WorkflowOptions",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															" try {",
															"    ",
															"    //check if the response code is 200",
															"    pm.test(\"Test Response Status Code\", function(){",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);",
															"    });",
															"    ",
															"    var jsonDataElements = pm.response.json().value;",
															"",
															"    //MIN number of Records Test",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"    pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"    });",
															"",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=WorkflowOptions/any(att:att/Name eq '{{WorkflowOptions_Name}}' and att/OData.CSC.StringAttribute/Value eq '{{WorkflowOptions_Value}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "WorkflowOptions/any(att:att/Name eq '{{WorkflowOptions_Name}}' and att/OData.CSC.StringAttribute/Value eq '{{WorkflowOptions_Value}}')",
															"description": "Query by Attributes"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP Retrieve Completed ProductionOrder",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By Id",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersId\");\r",
															"        //pm.expect(pm.response.text()).to.includes(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var production_order = jsonDataElements;\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, production_order);\r",
															"        pm.globals.set(\"ProductionOrder\" + key, production_order[key])\r",
															"    }\r",
															"    \r",
															"    if(production_order.Status == \"completed\"){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\", production_order.Id);\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\", production_order.CompletedDate);\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",production_order.EvictionDate);\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",production_order.OrderOutputSize);\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders('{{ProductionOrdersId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders('{{ProductionOrdersId}}')"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP ProductionOrder Retrieval Request for Download Product",
									"item": [
										{
											"name": "PRIP ProductionOrder Retrieval Request By CompletedDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=CompletedDate eq {{ProductionOrdersCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "CompletedDate eq {{ProductionOrdersCompletedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By Completed Status",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test odata products context\", function (){\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"CompletedDate\"])\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"EvictionDate\"])\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"Id\"])\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"OrderOutputSize\"])\r",
															"    });\r",
															"    \r",
															"    \r",
															"    const object = jsonDataElements.find(m => m.Id === pm.globals.get(\"ProductionOrdersId\"))\r",
															"    if(object){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\",object[\"Id\"])\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\",object[\"CompletedDate\"])\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",object[\"EvictionDate\"])\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",object[\"OrderOutputSize\"])\r",
															"    }\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Status eq OData.CSC.JobStatus'completed'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'completed'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By OrderOutputSize",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=OrderOutputSize eq '{{ProductionOrdersOrderOutputSize}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "OrderOutputSize eq '{{ProductionOrdersOrderOutputSize}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By EvictionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=EvictionDate eq {{ProductionOrdersEvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate eq {{ProductionOrdersEvictionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Triggered Download",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    console.log(pm.response);\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Downloaded Size\", function(){\r",
															"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"try {\r",
															"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{CompletedProductionOrdersId}})/Product/$value",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{CompletedProductionOrdersId}})",
														"Product",
														"$value"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Product Details",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{CompletedProductionOrdersId}})/Product",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{CompletedProductionOrdersId}})",
														"Product"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP Remove ProductionOrder",
									"item": [
										{
											"name": "PRIP ProductionOrder Cancel",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{ProductionOrdersId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{ProductionOrdersId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }   "
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						},
						{
							"name": "PRIP Workflow and ProductionOrder (with notification)",
							"item": [
								{
									"name": "PRIP Workflow Query (with notification)",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Workflow Listing Query (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"     \r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test workflows Id: \" + randomItems[\"Id\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Id\"]);\r",
															"           pm.globals.set(\"WorkflowId\",randomItems[\"Id\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Name: \" + randomItems[\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Name\"])\r",
															"           pm.globals.set(\"WorkflowName\",randomItems[\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Description: \" + randomItems[\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Description\"])\r",
															"           pm.globals.set(\"WorkflowDescription\",randomItems[\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows InputProductType: \" + randomItems[\"InputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"InputProductType\"])\r",
															"           pm.globals.set(\"InputProductType\",randomItems[\"InputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows OutputProductType: \" + randomItems[\"OutputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"OutputProductType\"])\r",
															"           pm.globals.set(\"OutputProductType\",randomItems[\"OutputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows WorkflowVersion: \" + randomItems[\"WorkflowVersion\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowVersion\"])\r",
															"           pm.globals.set(\"WorkflowVersion\",randomItems[\"WorkflowVersion\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflow Options Name: \" + randomItems[\"WorkflowOptions\"][0][\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Description: \" + randomItems[\"WorkflowOptions\"][0][\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Description\",randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Type: \" + randomItems[\"WorkflowOptions\"][0][\"Type\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Type\",randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options value: \" + randomItems[\"WorkflowOptions\"][0][\"Value\"][0], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"           pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?expand=WorkflowOptions&$filter={{ProductTypeCodeForWorkflow}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "expand",
															"value": "WorkflowOptions"
														},
														{
															"key": "$filter",
															"value": "{{ProductTypeCodeForWorkflow}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP ProductionOrder Submission (with notification)",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Product Query By Attributes (productType - with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.globals.get(\"flag_productType\") == \"true\"){",
															"    try {",
															"       // test status code",
															"        pm.test(\"Test Response Status Code\", function(){",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);",
															"        });",
															"        ",
															"        var jsonDataElements = pm.response.json().value;",
															"        //MIN number of Records Test",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
															"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"        });",
															"        //extract prodiuct properties (product name, id, sensing date)",
															"        const sizeLimit = 150000000;",
															"        var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
															"      ",
															"        let i = 0;",
															"        console.log(jsonDataElements[i].ContentLength)",
															"        while(i < jsonDataElements.length){",
															"           if(jsonDataElements[i].ContentLength < sizeLimit){",
															"               randomItems = jsonDataElements[i];",
															"               ",
															"               console.log(randomItems)",
															"               break;",
															"           }",
															"           i++;",
															"           //console.log(i)",
															"        }",
															"      ",
															"        pm.globals.set(\"ProductName\", randomItems.Name);",
															"        pm.globals.set(\"ProductId\", randomItems.Id);",
															"        pm.globals.set(\"Start\", randomItems.ContentDate.Start);",
															"        pm.globals.set(\"End\", randomItems.ContentDate.End);",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}",
															"}",
															" "
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')&$orderby=PublicationDate desc",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')",
															"description": "Query by Attributes"
														},
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Request (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.NotificationEndpoint = function (element) {\r",
															"    pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    \r",
															"    //checki if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															" \r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, randomItems);\r",
															"    }\r",
															"\r",
															"    pm.globals.set(\"ProductionOrdersId_withNotification\",randomItems[\"Id\"]);\r",
															"    pm.globals.set(\"ProductionOrdersStatus\",randomItems[\"Status\"])\r",
															"    pm.globals.set(\"ProductionOrdersStatusMessage\",randomItems[\"StatusMessage\"])\r",
															"    pm.globals.set(\"ProductionOrdersSubmissionDate\",randomItems[\"SubmissionDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersEstimatedDate\",randomItems[\"EstimatedDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersPriority\",randomItems[\"Priority\"])\r",
															"    pm.globals.set(\"ProductName\",randomItems[\"InputProductReference\"][0][\"Reference\"])\r",
															"    pm.globals.set(\"Start\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"Start\"])\r",
															"    pm.globals.set(\"End\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"End\"])\r",
															"    pm.globals.set(\"WorkflowId\",randomItems[\"WorkflowId\"])\r",
															"    pm.globals.set(\"WorkflowName\",randomItems[\"WorkflowName\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0])\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"InputProductReference\": {\r\n        \"Reference\": \"{{ProductName}}\",\r\n        \"ContentDate\": {\r\n            \"Start\": \"{{Start}}\",\r\n            \"End\": \"{{End}}\"\r\n        }\r\n    }, \r\n    \"Priority\": {{ProductionOrderPriority}},\r\n    \"WorkflowId\": \"{{WorkflowId}}\",\r\n    \"WorkflowName\": \"{{WorkflowName}}\",\r\n    \"WorkflowOptions\": [\r\n        {\r\n            \"Name\": \"{{WorkflowOptions_Name}}\",\r\n            \"Value\": \"{{WorkflowOptions_Value}}\"\r\n        }\r\n    ],\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP Retrieve Completed ProductionOrder (with notification)",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By Id (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"try {\r",
															"\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersId\");\r",
															"        //pm.expect(pm.response.text()).to.includes(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var production_order = jsonDataElements;\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, production_order);\r",
															"        pm.globals.set(\"ProductionOrder\" + key, production_order[key])\r",
															"    }\r",
															"    \r",
															"    if(production_order.Status == \"completed\"){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\", production_order.Id);\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\", production_order.CompletedDate);\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",production_order.EvictionDate);\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",production_order.OrderOutputSize);\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders('{{ProductionOrdersId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders('{{ProductionOrdersId}}')"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP ProductionOrder Retrieval Request for Download Product (with notification)",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Output Product Notification",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"console.log(access_token)\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"ProductionOrderId\": \"{{ProductionOrdersId_withNotification}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP ProductionOrder Retrieval Request By NotificationEndpoint",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
														}
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"function addZero(x, n) {",
													"  while (x.toString().length < n) {",
													"    x = \"0\" + x;",
													"  }",
													"  return x;",
													"}",
													"",
													"function GetCurrentDate() {",
													"    // Online Javascript Editor for free",
													"    // Write, Edit and Run your Javascript code using JS Online Compiler",
													"    var today = new Date();",
													"    var dd = String(today.getDate()).padStart(2, '0');",
													"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
													"    var yyyy = today.getFullYear();",
													"    var h = addZero(today.getHours(), 2);",
													"    var m = addZero(today.getMinutes(), 2);",
													"    var s = addZero(today.getSeconds(), 2);",
													"    var ms = addZero(today.getMilliseconds(), 6);",
													"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
													"    ",
													"    today = yyyy + '-' + mm + '-' + dd + 'T' + m + ':' + s + ':00.000Z';",
													"    //console.log(today)",
													"    return today;   // The function returns the product of p1 and p2",
													"}",
													"",
													"",
													"var date = GetCurrentDate()",
													"console.log(\"Notification Date is: \" + date);",
													"pm.globals.set(\"NotificationDate\", date);"
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "PRIP Check ProductionOrder Notification",
									"item": [
										{
											"name": "PRIP Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "PRIP Get ProductId Id from Server logs for ProductionOrder",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(product_id));\r",
															"pm.globals.set(\"NotificationProductId\", \"false\");\r",
															"console.log(notification);\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(product_id);\r",
															"            console.log(\"Found Product id: \" + product_id);\r",
															"        });\r",
															"        pm.globals.set(\"NotificationProductId\", \"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "PRIP Remove ProductionOrder (with notification)",
									"item": [
										{
											"name": "PRIP ProductionOrder Cancel (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{ProductionOrdersId_withNotification}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{ProductionOrdersId_withNotification}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"function addZero(x, n) {",
											"  while (x.toString().length < n) {",
											"    x = \"0\" + x;",
											"  }",
											"  return x;",
											"}",
											"",
											"function GetCurrentDate() {",
											"    // Online Javascript Editor for free",
											"    // Write, Edit and Run your Javascript code using JS Online Compiler",
											"    var today = new Date();",
											"    var dd = String(today.getDate()).padStart(2, '0');",
											"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
											"    var yyyy = today.getFullYear();",
											"    var h = addZero(today.getHours(), 2);",
											"    var m = addZero(today.getMinutes(), 2);",
											"    var s = addZero(today.getSeconds(), 2);",
											"    var ms = addZero(today.getMilliseconds(), 6);",
											"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
											"    ",
											"    today = yyyy + '-' + mm + '-' + dd + 'T' + m + ':' + s + ':00.000Z';",
											"    //console.log(today)",
											"    return today;   // The function returns the product of p1 and p2",
											"}",
											"",
											"",
											"var date = GetCurrentDate()",
											"console.log(\"Notification Date is: \" + date);",
											"pm.globals.set(\"NotificationDate\", date);",
											"",
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }   ",
											"",
											"if(!pm.iterationData.get('NotificationEndpoint')){",
											"       postman.setNextRequest(null); ",
											"   }   ",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						}
					]
				}
			],
			"description": "The purpose of \"**Production Interface Delivery Point_ICD_v1.9\"** is to specify an https RESTful Application Programming Interface (API) through which Sentinel (or Auxiliary) data products may be discovered and downloaded by authorised users from a Production Interface delivery Point (PRIP).",
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "AUXIP Extended Compliance",
			"item": [
				{
					"name": "AUXIP Products",
					"item": [
						{
							"name": "AUXIP Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"    \r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Products Listing Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonData = pm.response.json();",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"",
											"    // set global variable for the length of the result array",
											"    pm.globals.set(\"ProductListLength\", jsonDataElements.length);",
											"    var n = pm.globals.get(\"ProductListLength\") - 1;",
											"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"",
											"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
											"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
											"    pm.test(\"Products name: \" + randomItems[\"Name\"], function (){",
											"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ProductName\",randomItems[\"Name\"])",
											"    });",
											"",
											"    pm.test(\"Products Id: \" + randomItems[\"Id\"], function (){",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); ",
											"        pm.globals.set(\"ProductId\",randomItems[\"Id\"])",
											"    });",
											"",
											"    pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function (){",
											"        pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ContentType\",randomItems[\"ContentType\"])",
											"    });",
											"",
											"    pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function (){",
											"        pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"           pm.globals.set(\"ContentLength\",randomItems[\"ContentLength\"])",
											"    });",
											"",
											"    pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function (){",
											"        pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"OriginDate\",randomItems[\"OriginDate\"])",
											"    });",
											"",
											"    pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function (){",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"PublicationDate\",randomItems[\"PublicationDate\"])",
											"    });",
											"",
											"    pm.test(\"Eviction Date: \" + randomItems[\"EvictionDate\"], function (){",
											"        pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"EvictionDate\",randomItems[\"EvictionDate\"])",
											"    });",
											"",
											"    pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function (){",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumAlgorithm\",randomItems[\"Checksum\"][0][\"Algorithm\"])",
											"    });",
											"    ",
											"    pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function (){",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumValue\",randomItems[\"Checksum\"][0][\"Value\"])",
											"           //console.log(\"Checksum value of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"Value\"]);",
											"    });",
											"    ",
											"    pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function (){",
											"           pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"           pm.globals.set(\"ChecksumDate\",randomItems[\"Checksum\"][0][\"ChecksumDate\"])",
											"           //console.log(\"ChecksumDate of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"ChecksumDate\"]);",
											"    });",
											"",
											"    pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function (){",
											"        pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"Start\",randomItems[\"ContentDate\"][\"Start\"])",
											"    });",
											"",
											"    pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function (){",
											"        pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"End\",randomItems[\"ContentDate\"][\"End\"])",
											"    });",
											"",
											"    var len_array = randomItems[\"Name\"].split('.').length",
											"    pm.globals.set(\"StartStringName\",randomItems[\"Name\"].split('_')[0] + '_' + randomItems[\"Name\"].split('_')[1])",
											"    pm.globals.set(\"EndStringName\",randomItems[\"Name\"].split('.')[len_array-1])",
											"    pm.globals.set(\"StringName\",randomItems[\"Name\"].split('_')[2])",
											"    pm.globals.set(\"StringName2\",randomItems[\"Name\"].split('_')[3])",
											"           ",
											"    if(randomItems[\"Name\"].split('_')[0].includes('2')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('2','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('2','1'));",
											"    }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('1')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('1','2'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('1','2'));",
											"    }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('3')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('3','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('3','1'));",
											"    }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('5')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('5','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('5','1'));",
											"    }",
											"",
											"    var randomItems1 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems2 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems3 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"",
											"    pm.globals.set(\"product1\",randomItems1[\"Name\"])",
											"    pm.globals.set(\"product2\",randomItems2[\"Name\"])",
											"    pm.globals.set(\"product3\",randomItems3[\"Name\"])",
											"    ",
											"",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Product Listing Test\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Name",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											" ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        //var name = pm.globals.get(\"ProductName\");",
											"        //pm.expect(pm.response.text()).to.includes(name); ",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const product_name = pm.globals.get(\"ProductName\");\r",
											"const name = \"Name eq '\" + product_name + \"'\";\r",
											"const contains_string = \"contains(Name,'_\" + product_name.split('_')[1] + '_' +product_name.split('_')[2] + \"_\" + product_name.split('_')[3] + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + product_name.split('_')[0] + \"_\" + product_name.split('_')[1] + \"')\";\r",
											"\r",
											"var len_array = product_name.split('.').length;\r",
											"const end_string = \"endswith(Name,'\" + product_name.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"let StringObjects = [name,contains_string,start_string,end_string];\r",
											"var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",itemStringObjects);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{QueryByNameString}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Validity Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"Start\");",
											"    var prop_name = \"ContentDate\";",
											"    pm.test(\"Sensing Date: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name][\"Start\"])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
											"description": "Complex Property ContentDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Publication Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    ",
											"    //test property",
											"    var date = pm.globals.get(\"StartPublicationDate\");",
											"    var prop_name = \"PublicationDate\";",
											"    pm.test(\"PublicationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"",
											"    if(pm.globals.get(\"OriginDate\") == undefined){",
											"    postman.setNextRequest(\"Product Query By EvictionDate\");",
											"}",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"  date.setDate(date.getDate() + days);\r",
											"\r",
											"  return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"\r",
											"const start_date = new Date(publication_date);\r",
											"const StartNewDate =  addDays(start_date, -5);\r",
											"\r",
											"\r",
											"pm.globals.set(\"StartPublicationDate\",StartNewDate);;"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=PublicationDate gt {{StartPublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate gt {{StartPublicationDate}}",
											"description": "Simple Property PublicationDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By OriginDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"OriginDate\");",
											"    var prop_name = \"OriginDate\";",
											"    pm.test(\"OriginDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OriginDate ge {{OriginDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OriginDate ge {{OriginDate}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By EvictionDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    ",
											"    //test property",
											"    var date = pm.globals.get(\"EvictionDate\");",
											"    var prop_name = \"EvictionDate\";",
											"    pm.test(\"EvictionDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    }); ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=EvictionDate ge {{EvictionDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "EvictionDate ge {{EvictionDate}}",
											"description": "Complex Property EvictionDate"
										},
										{
											"key": "$top",
											"value": "10",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Size",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"        //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    //test property",
											"    var prop_name = \"ContentLength\";",
											"    pm.test(\"ContentLength: \" + jsonDataElements[0][prop_name], function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(parseInt(pm.globals.get(prop_name))).to.equal(item[prop_name]);",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentLength eq {{ContentLength}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentLength eq {{ContentLength}}",
											"description": "Size property"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json();",
											"    var id = pm.globals.get(\"ProductId\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Test product id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"        //check the product status",
											"        console.log(\"Product: \" + jsonDataElements.Name);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
											"       postman.setNextRequest(\"AUXIP Product Periodical Query\"); \r",
											"   }   "
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Download By ProductId",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"try {\r",
											"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    //console.log(pm.response);\r",
											"\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
											"    });\r",
											"\r",
											"    pm.test(\"Downloaded Size\", function(){\r",
											"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
											"    });\r",
											"\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"protocolProfileBehavior": {
								"followAuthorizationHeader": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/$value",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})",
										"$value"
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Periodical Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=PublicationDate ge {{PublicationDate}}&$orderby=PublicationDate asc&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate ge {{PublicationDate}}",
											"description": "Simple Property PublicationDate"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate asc"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Attributes Expand Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function propertySpecific(key, attr, items) {",
											"    const ProductObject = items.Attributes.find(m => m.Name === attr[key]);",
											"    //console.log(ProductObject);",
											"    if (ProductObject !== undefined) {",
											"        pm.test(\"Response body contains \" + attr[key], function() {",
											"            pm.expect(ProductObject).not.eq(undefined);",
											"            pm.expect(ProductObject.Name).to.be.a(\"string\");",
											"            pm.expect(ProductObject.ValueType).to.be.a(\"string\");",
											"            pm.expect(ProductObject.Value).not.eq(undefined)",
											"            pm.globals.set(ProductObject.Name, ProductObject.Value);",
											"            pm.globals.set(\"flag_\" + ProductObject.Name, \"true\");",
											"        });",
											"    } else {",
											"        console.warn(\"Skipped \" + attr[key] + \" attribute test\");",
											"    }",
											"}",
											"// attributes",
											"const elements_s1 = [\"processingDate\", \"processingCenter\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"beginningDateTime\"];",
											"",
											"const elements_s1_aux = [\"processingDate\", \"processingCenter\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"beginningDateTime\"];",
											"",
											"const elements_s2 = [\"processorVersion\", \"processingDate\", \"beginningDateTime\", \"endingDateTime\", \"productType\", \"processingCenter\", \"platformSerialIdentifier\", \"platformShortName\"]",
											"",
											"const elements_s2_aux = [\"platformShortName\", \"platformSerialIdentifier\", \"productType\", \"beginningDateTime\", \"endingDateTime\", \"processingCenter\", \"processorVersion\", \"processingDate\"];",
											"",
											"const elements_s3 = [\"beginningDateTime\", \"endingDateTime\", \"instrumentShortName\", \"productType\", \"timeliness\", \"orbitNumber\", \"lastOrbitNumber\", \"relativeOrbitNumber\", \"processorName\"];",
											"",
											"const elements_s3_aux = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"const elements_pod = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        if (pm.response.code !== 200) {",
											"            postman.setNextRequest(\"AUXIP Additional Options (orderby asc)\");",
											"        }",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    pm.globals.set('headers-format', pm.response.headers.get('Content-Type'));",
											"    const header_format = pm.globals.get('headers-format');",
											"    const format = \"application/json\"",
											"    const zip_format = \"application/zip\"",
											"",
											"    pm.test(\"Content-Type header is correct\", function() {",
											"        if (header_format.includes(zip_format)) {",
											"            pm.expect(header_format).to.includes(zip_format);",
											"            console.warn(\"The Content-Type header is \" + header_format);",
											"            console.warn(\"The Attributes requests are skipped. \");",
											"            postman.setNextRequest(\"AUXIP Additional Options (orderby asc)\");",
											"        } else {",
											"",
											"            if (!header_format.includes(format)) {",
											"                console.warn(\"The Content-Type header is \" + header_format);",
											"                console.warn(\"The Attributes requests are skipped. \");",
											"                postman.setNextRequest(\"AUXIP Additional Options (orderby asc)\")",
											"            }",
											"",
											"            pm.expect(header_format).to.includes(format);",
											"        }",
											"    });",
											"",
											"    if (header_format.includes(format)) {",
											"        var jsonDataElements = pm.response.json().value;",
											"        // extract the attributes for the next subsequent tests",
											"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems1 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems2 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        let productTypeObject1 = randomItems1.Attributes.find(m => m.Name === \"productType\");",
											"        let productTypeObject2 = randomItems2.Attributes.find(m => m.Name === \"productType\");",
											"",
											"        if (productTypeObject1) {",
											"            pm.globals.set(\"productType2\", productTypeObject1[\"Value\"]);",
											"        }",
											"        if (productTypeObject2) {",
											"            pm.globals.set(\"productType3\", productTypeObject2[\"Value\"]);",
											"        }",
											"",
											"        var found_element;",
											"        var name = randomItems.Name",
											"        if (name.startsWith('S1') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s1;",
											"        } else if (name.startsWith('S1') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s1_aux;",
											"        } else if (name.startsWith('S2') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s2;",
											"        } else if (name.startsWith('S2') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s2_aux;",
											"        } else if (name.startsWith('S3') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s3;",
											"        } else if (name.startsWith('S3') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s3_aux;",
											"        } else {",
											"            found_element = elements_pod;",
											"        }",
											"",
											"        // check properties",
											"        pm.test(\"Products name: \" + randomItems[\"Name\"], function() {",
											"            pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Products Id: \" + randomItems[\"Id\"], function() {",
											"            pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        });",
											"",
											"        pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function() {",
											"            pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function() {",
											"            pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"        });",
											"",
											"        pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function() {",
											"            pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function() {",
											"            pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Eviction Date: \" + randomItems[\"EvictionDate\"], function() {",
											"            pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        // Test that the correct odata context is returned",
											"        console.log(\"Test that the correct attributes are returned for product: \" + name);",
											"        for (var key in found_element) {",
											"            propertySpecific(key, found_element, randomItems);",
											"        }",
											"",
											"        const processor_version = randomItems.Attributes.find(m => m.Name === \"processorVersion\");",
											"        if (processor_version !== undefined) {",
											"            //console.log(processor_version);",
											"            pm.globals.set(processor_version.Name, processor_version.Value);",
											"            pm.globals.set(\"flag_processorVersion\", \"true\");",
											"        }",
											"    }",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}&$expand=Attributes&$format=json&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}"
										},
										{
											"key": "$expand",
											"value": "Attributes"
										},
										{
											"key": "$format",
											"value": "json"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (InstrumentShortName)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_InstrumentShortName\") === \"true\"){",
											"    try {",
											"        //check if the response code is 200",
											"        pm.test(\"Test Response Status Code\", function(){",
											"           pm.expect(pm.response.code).to.be.oneOf([200]);",
											"        });",
											"        ",
											"        var jsonDataElements = pm.response.json().value;",
											"",
											"        //MIN number of Records Test",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (orbitNumber)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_orbitNumber\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (processingDate)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_processingDate\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (timeliness)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_timeliness\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (platformShortName)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_platformShortName\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (platformSerialIdentifier)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_platformSerialIdentifier\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (productType)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productType\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (beginningDateTime)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_beginningDateTime\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'beginningDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{beginningDateTime}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'beginningDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{beginningDateTime}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (endingDateTime)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_endingDateTime\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"       //MIN number of Records Test",
											"       var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"       pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"       });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'endingDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{endingDateTime}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'endingDateTime' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{endingDateTime}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (processingCenter)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_processingCenter\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processingCenter' and att/OData.CSC.StringAttribute/Value eq '{{processingCenter}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processingCenter' and att/OData.CSC.StringAttribute/Value eq '{{processingCenter}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (combining productType and processorVersion)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productType\") === \"true\" && pm.globals.get(\"flag_processorVersion\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Product Query By Attributes (combining platformShortName & platformSerialIdentifier)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_platformShortName\") === \"true\" && pm.globals.get(\"flag_platformSerialIdentifier\") === \"true\"){",
											"    try {",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (orderby asc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyAsc}} asc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyAsc}} asc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (orderby desc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyDesc}} desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}} desc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (top)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$top={{top}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$top",
											"value": "{{top}}",
											"description": "Specify the maximum (non-negative integer) number of items returned"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (skip)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$skip={{skip}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$skip",
											"value": "{{skip}}",
											"description": "Specify a (non-negative integer) number of items excluded from the start"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (count)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    // verify that the number of the matching resources is returned as result.",
											"    var data_counter = pm.response.json()[\"@odata.count\"];",
											"    pm.test(\"The number of the matching resources is returned: \" + data_counter, function(){",
											"        pm.expect(data_counter).to.be.a(\"number\");",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$count=true&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$count",
											"value": "true",
											"description": "Request a count of the matching resources"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (Operator \"and\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    //check if the response code is 200\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"    \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator AND returns at least the expected minimum number of products: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=startswith(Name,'{{StartStringName}}') and endswith(Name,'{{EndStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}') and endswith(Name,'{{EndStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (Operator \"or\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    //check if the response code is 200\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator OR returns at least the expected minimum number of products: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=contains(Name,'{{StringName}}') or contains(Name,'{{StringName2}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "contains(Name,'{{StringName}}') or contains(Name,'{{StringName2}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (Operator \"not\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											" \r",
											"    //check if the response code is 200\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"    \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator NOT returns at least the expected minimum number of products: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=startswith(Name,'{{StartStringName}}')  and not contains(Name,'{{StringNameNot}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')  and not contains(Name,'{{StringNameNot}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "AUXIP Additional Options (Operator \"in\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if (pm.globals.get(\"flag_productType\") === \"true\") {\r",
											"    try {\r",
											"\r",
											"        //check if the response code is 200\r",
											"        pm.test(\"Test Response Status Code\", function () {\r",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"        });\r",
											"\r",
											"        var jsonDataElements = pm.response.json().value;\r",
											"\r",
											"        //MIN number of Records Test\r",
											"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"        pm.test(\"Test operator IN returns at least the expected minimum number of products: \" + minimumExpRecords, function () {\r",
											"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"        });\r",
											"    } catch (err) {\r",
											"        pm.test(request.name, function () {\r",
											"            pm.expect.fail(err.toString());\r",
											"        });\r",
											"    }\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value in ('{{productType}}','{{productType2}}','{{productType3}}'))",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value in ('{{productType}}','{{productType2}}','{{productType3}}'))"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "AUXIP Subscriptions",
					"item": [
						{
							"name": "AUXIP Create Subscriptions",
							"item": [
								{
									"name": "AUXIP Get Token",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const jsonData = pm.response.json();\r",
													"    const access_token = jsonData.access_token;\r",
													"    pm.test(\"A token is returned\", function() {\r",
													"    pm.expect(pm.response.text()).to.include('access_token');\r",
													"   });\r",
													"   pm.globals.set(\"access_token\", access_token);\r",
													"}else{\r",
													"    console.log('Skip token verification');\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
													"    \r",
													"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"username\");\r",
													"        pm.request.body.urlencoded.remove(\"password\"); \r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"\r",
													"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
													"    }\r",
													"\r",
													"    pm.request.headers.upsert({\r",
													"        'key': \"Authorization\",\r",
													"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
													"    });\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [
											{
												"key": "Authorization",
												"value": "Basic {{encoded_credential}}"
											},
											{
												"key": "Content-Type",
												"value": "application/x-www-form-urlencoded"
											}
										],
										"body": {
											"mode": "urlencoded",
											"urlencoded": [
												{
													"key": "grant_type",
													"value": "{{grant_type}}",
													"type": "text"
												},
												{
													"key": "username",
													"value": "{{username}}",
													"type": "text"
												},
												{
													"key": "password",
													"value": "{{password}}",
													"type": "text"
												},
												{
													"key": "scope",
													"value": "{{scope}}",
													"type": "text"
												},
												{
													"key": "client_id",
													"value": "{{client_id}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												}
											]
										},
										"url": {
											"raw": "{{access_token_url}}",
											"host": [
												"{{access_token_url}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription Create",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"properties_map = {};\r",
													"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
													"\r",
													"properties_map.Status=function (element) {\r",
													"    pm.expect(element.Status).to.be.a(\"string\");\r",
													"    pm.expect(element.Status).to.be.oneOf([\"running\"]);\r",
													"};\r",
													"\r",
													"properties_map.FilterParam=function (element) {\r",
													"    pm.expect(element.FilterParam).to.be.a(\"string\");\r",
													"    pm.expect(element.FilterParam).to.be.not.equal(null);\r",
													"};\r",
													"\r",
													"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
													"\r",
													"properties_map.NotificationEndpoint=function (element) {\r",
													"    pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
													"};\r",
													"\r",
													"function propertySpecific(key, order){\r",
													"    if (properties_map[key]) {\r",
													"        pm.test(\"Test Property \"+key+\" for Subscription: \" + order[key], function(){\r",
													"            properties_map[key](order);\r",
													"            pm.expect(pm.response.text()).to.include(key);});\r",
													"    }\r",
													"    else {\r",
													"        console.warn(\"Test Property \"+key+\" is skipped for Subscription: \" + order[key]);\r",
													"    }\r",
													"};\r",
													"\r",
													"try {\r",
													"    \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json();\r",
													"\r",
													"    for (const[key, value] of Object.entries(properties_map)){\r",
													"        propertySpecific(key, jsonDataElements);\r",
													"        //pm.globals.set('Subscription' + key, jsonDataElements.key);\r",
													"    }\r",
													"    \r",
													"    pm.globals.set('SubscriptionId', jsonDataElements['Id']);\r",
													"    pm.globals.set('SubscriptionStatus', jsonDataElements['Status']);\r",
													"    //pm.globals.set('FilterParam', jsonDataElements['FilterParam']);\r",
													"    pm.globals.set('SubmissionDate', jsonDataElements['SubmissionDate']);\r",
													"    //pm.globals.set('NotificationEndpoint', jsonDataElements['NotificationEndpoint']);\r",
													"    \r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"@odata.context\": \"$metadata#Subscription/entity\",\r\n    \"FilterParam\": \"{{SubscriptionFilterParam}}\",\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Products Listing Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {",
													"    //check if the response code is 200",
													"    pm.test(\"Test Response Status Code\", function(){",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);",
													"    });",
													"",
													"    var jsonData = pm.response.json();",
													"    var jsonDataElements = pm.response.json().value;",
													"",
													"    //MIN number of Records Test",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
													"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
													"    });",
													"",
													"    // set global variable for the length of the result array",
													"    pm.globals.set(\"ProductListLength\", jsonDataElements.length);",
													"    var n = pm.globals.get(\"ProductListLength\") - 1;",
													"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
													"",
													"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
													"    // extract the product name, id sensing date for the last result in the array  for the next subsequent tests",
													"    pm.test(\"Products name: \" + randomItems[\"Name\"], function (){",
													"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
													"        pm.globals.set(\"ProductName\",randomItems[\"Name\"])",
													"    });",
													"",
													"    pm.test(\"Products Id: \" + randomItems[\"Id\"], function (){",
													"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); ",
													"        pm.globals.set(\"ProductId\",randomItems[\"Id\"])",
													"    });",
													"",
													"}",
													"",
													"catch (err) {",
													"    pm.test(\"Product Listing Test\", function () {",
													"        pm.expect.fail(err.toString());",
													"    });",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"var filter_string = pm.globals.get(\"SubscriptionFilterParam\");\r",
													"pm.globals.set(\"FilterProductString\", filter_string.replace('Products?$filter=',''));\r",
													"console.log(filter_string.replaceAll('Products?$filter=','').replaceAll('Name','FilterParam'))"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Products"
											],
											"query": [
												{
													"key": "$filter",
													"value": "{{ProductTypeCode}}"
												},
												{
													"key": "$orderby",
													"value": "PublicationDate desc"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Product Availability Notification",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"properties_map = {};\r",
													"\r",
													"properties_map[\"@odata.context\"]=function(element){\r",
													"    pm.expect(element[\"@odata.context\"]).to.include(\"$metadata#Notification\");\r",
													"};\r",
													"\r",
													"properties_map.ProductId=function (element) {pm.expect(element.ProductId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
													"\r",
													"properties_map.ProductName=function (element) {\r",
													"    pm.expect(element.Name).to.be.a(\"string\");\r",
													"};\r",
													"\r",
													"properties_map.SubscriptionId=function (element) {pm.expect(element.SubscriptionId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
													"\r",
													"properties_map.NotificationDate=function (element) {pm.expect(element.NotificationDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
													"\r",
													"\r",
													"function propertySpecific(key, order){\r",
													"    if (properties_map[key]) {\r",
													"        pm.test(\"Test Property \"+key+\" for Subscription: \" + order[key], function(){\r",
													"            properties_map[key](order);\r",
													"            pm.expect(pm.response.text()).to.include(key);});\r",
													"    }\r",
													"    else {\r",
													"        console.warn(\"Test Property \"+key+\" is skipped for Subscription: \" + order[key]);\r",
													"    }\r",
													"};\r",
													"\r",
													"try {\r",
													"\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"// Define token access\r",
													"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
													"console.log(access_token)\r",
													"let auth_string\r",
													"if(access_token){\r",
													"   console.log('Use Token Authentication for notification');\r",
													"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
													"}else{\r",
													"   console.log('Not use Token Authentication for notification');\r",
													"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
													"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
													"   if(username){\r",
													"      console.log('Use username and password for notification');\r",
													"      var decoded_string = username + \":\" + password;\r",
													"      // Encode the String\r",
													"      var encoded_string = btoa(decoded_string);\r",
													"      auth_string = \"Basic \" + encoded_string;\r",
													"   }\r",
													"   \r",
													"}\r",
													"\r",
													"// added header\r",
													"pm.request.headers.upsert({\r",
													" 'key': \"Authorization\",\r",
													" 'value': auth_string\r",
													" });"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [],
										"body": {
											"mode": "raw",
											"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"SubscriptionId\": \"{{SubscriptionId}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\"\r\n}",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{NotificationEndpoint}}",
											"host": [
												"{{NotificationEndpoint}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscriptions Listing Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"\r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"    });\r",
													"    \r",
													"}\r",
													"\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription Id Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"    \r",
													"    var jsonDataElements = pm.response.json();\r",
													" \r",
													"    //Test subscription id property\r",
													"    var id = pm.globals.get('SubscriptionId');\r",
													"    pm.test(\"Subscription Id: \" + id, function(){\r",
													"        pm.expect(jsonDataElements.Id).to.be.eq(id);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions('{{SubscriptionId}}')",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions('{{SubscriptionId}}')"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription Status Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													" \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"     \r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"\r",
													"    var property = pm.globals.get(\"SubscriptionStatus\");\r",
													"    var key = \"Status\"\r",
													"    pm.test(\"Subscription \" + key + \": \" + jsonDataElements[0][key], function(){\r",
													"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
													"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "Status eq OData.CSC.SubscriptionStatus'{{SubscriptionStatus}}'"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription FilterParam Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"    \r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"var filter_string = pm.iterationData.get(\"FilterParam\");\r",
													"pm.globals.set(\"FilterString\", filter_string.replaceAll('Products?$filter=','').replaceAll('Name','FilterParam'));"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter={{FilterString}}",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "{{FilterString}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription  SubmissionDate Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    \r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"\r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"    //test property\r",
													"    var date = pm.globals.get(\"SubmissionDate\");\r",
													"    var prop_name = \"SubmissionDate\";\r",
													"    pm.test(\"SubmissionDate: \" + date, function(){\r",
													"        for (let item of jsonDataElements) {\r",
													"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
													"        }\r",
													"    }); \r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=SubmissionDate ge {{SubmissionDate}}",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "SubmissionDate ge {{SubmissionDate}}"
												}
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription Endpoint Query",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"    });\r",
													"\r",
													"    var jsonDataElements = pm.response.json().value;\r",
													"    \r",
													"    //MIN number of Records Test\r",
													"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
													"    pm.test(\"Expected minimum number of subscriptions Test: \" + minimumExpRecords, function(){\r",
													"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
													"        console.log(jsonDataElements.length + \" products found: \");\r",
													"    });\r",
													"\r",
													"    var property = pm.iterationData.get(\"NotificationEndpoint\");\r",
													"    var key = \"NotificationEndpoint\"\r",
													"    pm.test(\"Test \" + key + \" property for subscription: \" + jsonDataElements[0][key], function(){\r",
													"        pm.expect(jsonDataElements[0][key]).to.be.includes(property);\r",
													"        console.log(key + \" found: \" + jsonDataElements[0][key]);\r",
													"    });\r",
													"    \r",
													"} catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions"
											],
											"query": [
												{
													"key": "$filter",
													"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "AUXIP Check Subscriptions Notification",
							"item": [
								{
									"name": "AUXIP Get Token",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const jsonData = pm.response.json();\r",
													"    const access_token = jsonData.access_token;\r",
													"    pm.test(\"A token is returned\", function() {\r",
													"    pm.expect(pm.response.text()).to.include('access_token');\r",
													"   });\r",
													"   pm.globals.set(\"access_token\", access_token);\r",
													"}else{\r",
													"    console.log('Skip token verification');\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
													"    \r",
													"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"username\");\r",
													"        pm.request.body.urlencoded.remove(\"password\"); \r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"\r",
													"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
													"    }\r",
													"\r",
													"    pm.request.headers.upsert({\r",
													"        'key': \"Authorization\",\r",
													"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
													"    });\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [
											{
												"key": "Authorization",
												"value": "Basic {{encoded_credential}}"
											},
											{
												"key": "Content-Type",
												"value": "application/x-www-form-urlencoded"
											}
										],
										"body": {
											"mode": "urlencoded",
											"urlencoded": [
												{
													"key": "grant_type",
													"value": "{{grant_type}}",
													"type": "text"
												},
												{
													"key": "username",
													"value": "{{username}}",
													"type": "text"
												},
												{
													"key": "password",
													"value": "{{password}}",
													"type": "text"
												},
												{
													"key": "scope",
													"value": "{{scope}}",
													"type": "text"
												},
												{
													"key": "client_id",
													"value": "{{client_id}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												}
											]
										},
										"url": {
											"raw": "{{access_token_url}}",
											"host": [
												"{{access_token_url}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Get Subscription Id from Server logs",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
													"var subscription_id = pm.globals.get(\"SubscriptionId\");\r",
													"var notification = jsonDataElements.find(m => m.request.body.data.includes(subscription_id));\r",
													"pm.globals.set(\"NotificationSubscriptionId\", \"false\");\r",
													"console.log(notification);\r",
													"if (notification) {\r",
													"    try {\r",
													"        // test status code\r",
													"        pm.test(\"Test Response Status Code\", function () {\r",
													"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
													"        });\r",
													"\r",
													"        pm.test(\"Subscription id: \" + subscription_id, function () {\r",
													"            pm.expect(notification.request.body.data).to.be.includes(subscription_id);\r",
													"            console.log(\"Found Subscription id: \" + subscription_id);\r",
													"        });\r",
													"        pm.globals.set(\"NotificationSubscriptionId\", \"true\");\r",
													"\r",
													"    } catch (err) {\r",
													"        pm.test(request.name, function () {\r",
													"            pm.expect.fail(err.toString());\r",
													"        });\r",
													"    }\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "apikey",
											"apikey": [
												{
													"key": "value",
													"value": "{{api_key}}",
													"type": "string"
												},
												{
													"key": "key",
													"value": "X-API-Key",
													"type": "string"
												},
												{
													"key": "in",
													"value": "header",
													"type": "string"
												}
											]
										},
										"method": "GET",
										"header": [],
										"url": {
											"raw": "{{ServerLogsUrl}}",
											"host": [
												"{{ServerLogsUrl}}"
											],
											"query": [
												{
													"key": "count",
													"value": "1",
													"disabled": true
												},
												{
													"key": "path",
													"value": "/login",
													"disabled": true
												}
											]
										}
									},
									"response": []
								}
							]
						},
						{
							"name": "AUXIP Cancel Subscriptions",
							"item": [
								{
									"name": "AUXIP Get Token",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const jsonData = pm.response.json();\r",
													"    const access_token = jsonData.access_token;\r",
													"    pm.test(\"A token is returned\", function() {\r",
													"    pm.expect(pm.response.text()).to.include('access_token');\r",
													"   });\r",
													"   pm.globals.set(\"access_token\", access_token);\r",
													"}else{\r",
													"    console.log('Skip token verification');\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										},
										{
											"listen": "prerequest",
											"script": {
												"exec": [
													"if(pm.environment.get('auth_type') != 'basic'){\r",
													"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
													"    \r",
													"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"username\");\r",
													"        pm.request.body.urlencoded.remove(\"password\"); \r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"\r",
													"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"scope\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
													"    }\r",
													"    \r",
													"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
													"        pm.request.body.urlencoded.remove(\"client_id\");\r",
													"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
													"    }\r",
													"\r",
													"    pm.request.headers.upsert({\r",
													"        'key': \"Authorization\",\r",
													"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
													"    });\r",
													"}\r",
													""
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"auth": {
											"type": "noauth"
										},
										"method": "POST",
										"header": [
											{
												"key": "Authorization",
												"value": "Basic {{encoded_credential}}"
											},
											{
												"key": "Content-Type",
												"value": "application/x-www-form-urlencoded"
											}
										],
										"body": {
											"mode": "urlencoded",
											"urlencoded": [
												{
													"key": "grant_type",
													"value": "{{grant_type}}",
													"type": "text"
												},
												{
													"key": "username",
													"value": "{{username}}",
													"type": "text"
												},
												{
													"key": "password",
													"value": "{{password}}",
													"type": "text"
												},
												{
													"key": "scope",
													"value": "{{scope}}",
													"type": "text"
												},
												{
													"key": "client_id",
													"value": "{{client_id}}",
													"type": "default"
												},
												{
													"key": "client_secret",
													"value": "{{client_secret}}",
													"type": "default"
												}
											]
										},
										"url": {
											"raw": "{{access_token_url}}",
											"host": [
												"{{access_token_url}}"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription pause",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200,204,201,202]);\r",
													"    });\r",
													"\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [
											{
												"key": "Content-Type",
												"value": "application/json",
												"type": "text"
											}
										],
										"body": {
											"mode": "raw",
											"raw": "",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Pause",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})",
												"OData.CSC.Pause"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription resume",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200,204,201,202]);\r",
													"    });\r",
													"\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [
											{
												"key": "Content-Type",
												"value": "application/json",
												"type": "text"
											}
										],
										"body": {
											"mode": "raw",
											"raw": "",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Resume",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})",
												"OData.CSC.Resume"
											]
										}
									},
									"response": []
								},
								{
									"name": "AUXIP Subscription cancel",
									"event": [
										{
											"listen": "test",
											"script": {
												"exec": [
													"try {\r",
													"    pm.test(\"Test Response Status Code\", function(){\r",
													"        pm.expect(pm.response.code).to.be.oneOf([200,204,201,202]);\r",
													"    });\r",
													"\r",
													"}\r",
													"catch (err) {\r",
													"    pm.test(request.name, function () {\r",
													"        pm.expect.fail(err.toString());\r",
													"    });\r",
													"}"
												],
												"type": "text/javascript"
											}
										}
									],
									"request": {
										"method": "POST",
										"header": [
											{
												"key": "Content-Type",
												"value": "application/json",
												"type": "text"
											}
										],
										"body": {
											"mode": "raw",
											"raw": "",
											"options": {
												"raw": {
													"language": "json"
												}
											}
										},
										"url": {
											"raw": "{{service-root-uri}}/odata/v1/Subscriptions({{SubscriptionId}})/OData.CSC.Cancel",
											"host": [
												"{{service-root-uri}}"
											],
											"path": [
												"odata",
												"v1",
												"Subscriptions({{SubscriptionId}})",
												"OData.CSC.Cancel"
											]
										}
									},
									"response": []
								}
							]
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"function addZero(x, n) {",
									"    while (x.toString().length < n) {",
									"      x = \"0\" + x;",
									"    }",
									"    return x;",
									"};",
									"",
									"function GetCurrentDate() {",
									"    // Online Javascript Editor for free",
									"    // Write, Edit and Run your Javascript code using JS Online Compiler",
									"    var today = new Date();",
									"    var dd = String(today.getDate()).padStart(2, '0');",
									"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
									"    var yyyy = today.getFullYear();",
									"    var h = addZero(today.getHours(), 2);",
									"    var m = addZero(today.getMinutes(), 2);",
									"    var s = addZero(today.getSeconds(), 2);",
									"    var ms = addZero(today.getMilliseconds(), 3);",
									"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
									"    ",
									"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;",
									"    //console.log(today)",
									"    return today;   // The function returns the product of p1 and p2",
									"};",
									"",
									"function ConvertDate(today) {",
									"    // Online Javascript Editor for free",
									"    // Write, Edit and Run your Javascript code using JS Online Compiler",
									"    ",
									"    var dd = String(today.getDate()).padStart(2, '0');",
									"    var mm = String(today.getMonth()).padStart(2, '0'); //January is 0!",
									"    var yyyy = today.getFullYear();",
									"    var h = addZero(today.getHours(), 2);",
									"    var m = addZero(today.getMinutes(), 2);",
									"    var s = addZero(today.getSeconds(), 2);",
									"    var ms = addZero(today.getMilliseconds(), 3);",
									"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
									"    var time = \"00:00:00.000000\"",
									"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':' + m +':' + s +'.' + ms + 'Z';;",
									"    //console.log(today)",
									"    return today;   // The function returns the product of p1 and p2",
									"};",
									"",
									"Date.prototype.addDays = function (days) {",
									"    const date = new Date(this.valueOf());",
									"    date.setDate(date.getDate() + days);",
									"    return date;",
									"};",
									"  ",
									"",
									"var current_date = GetCurrentDate();",
									"const date = new Date(current_date);",
									"    ",
									"// add days to current date",
									"const new_date_formatYmd = new_date_Object => date.addDays(2).toISOString();",
									"new_date = new_date_formatYmd(new Date());",
									"console.log(new_date_formatYmd(new Date()));",
									"",
									"var filter_string = pm.iterationData.get(\"FilterParam\");",
									"var filter_string_completed = filter_string +  \" and PublicationDate gt \" + current_date + \" and \"  +  \"PublicationDate lt \" + new_date;",
									"  ",
									"console.log(\"FilterParam is: \" + filter_string_completed);",
									"//pm.globals.set(\"FilterParam\", pm.iterationData.get(\"FilterParamString\") + \" PublicationDate gt \" + yesterday_converted + time + \" and \"  +  \"PublicationDate lt \" + date + time)",
									"pm.globals.set(\"SubscriptionFilterParam\", filter_string_completed);",
									"//pm.globals.set(\"FilterString\", filter_string_completed.replace('Products?$filter=',''));",
									"",
									"console.log(\"Notification Date is: \" + current_date);",
									"pm.globals.set(\"NotificationDate\", current_date);",
									"",
									"if(pm.environment.get('execute_admin_requests') == \"true\"){",
									"       console.warn(\"Unable to send request as administrator!\");",
									"       postman.setNextRequest(null); ",
									"   }   ",
									"",
									"if(!pm.iterationData.get('NotificationEndpoint')){",
									"       postman.setNextRequest(null); ",
									"   }   "
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				}
			],
			"description": "The purpose of \"**Auxiliary Data Interface Delivery Point Specification_v1.4\"** is to specify https RESTful Application Programming Interfaces (APIs) through which Auxiliary data may be discovered and downloaded by authorised users from Auxiliary Interface delivery Points (AUXIP).",
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "DD Extended Compliance",
			"item": [
				{
					"name": "DD Products",
					"item": [
						{
							"name": "DD Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
											"    \r",
											"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"username\");\r",
											"        pm.request.body.urlencoded.remove(\"password\"); \r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"\r",
											"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"scope\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
											"    }\r",
											"    \r",
											"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
											"        pm.request.body.urlencoded.remove(\"client_id\");\r",
											"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
											"    }\r",
											"\r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Products Listing Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonData = pm.response.json();",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    //console.log(randomItems);",
											"",
											"    // extract the product name, id sensing date for the random result in the array for the next subsequent tests",
											"    pm.test(\"Products Name: \" + randomItems[\"Name\"], function (){",
											"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ProductName\",randomItems[\"Name\"])",
											"    });",
											"",
											"    pm.test(\"Products Id: \" + randomItems[\"Id\"], function (){",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); ",
											"        pm.globals.set(\"ProductId\",randomItems[\"Id\"])",
											"    });",
											"",
											"    pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function (){",
											"        pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ContentType\",randomItems[\"ContentType\"])",
											"    });",
											"",
											"    pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function (){",
											"        pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"           pm.globals.set(\"ContentLength\",randomItems[\"ContentLength\"])",
											"    });",
											"",
											"    pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function (){",
											"        pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"OriginDate\",randomItems[\"OriginDate\"])",
											"    });",
											"",
											"    pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function (){",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"PublicationDate\",randomItems[\"PublicationDate\"])",
											"    });",
											"",
											"    pm.test(\"Modification date: \" + randomItems[\"ModificationDate\"], function (){",
											"        pm.expect(randomItems[\"ModificationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"ModificationDate\",randomItems[\"ModificationDate\"])",
											"           //console.log(\"ModificationDate of the last product: \" + jsonDataElements[n][\"ModificationDate\"]);",
											"    });",
											"",
											"    pm.test(\"Test Online status property: \" + randomItems[\"Online\"], function () {",
											"        pm.expect(randomItems[\"Online\"]).to.be.a(\"boolean\");",
											"        pm.globals.set(\"OnlineStatus\", randomItems[\"Online\"].toString());",
											"    });",
											"",
											"    pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function (){",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumAlgorithm\",randomItems[\"Checksum\"][0][\"Algorithm\"])",
											"    });",
											"    ",
											"    pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function (){",
											"        pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"ChecksumValue\",randomItems[\"Checksum\"][0][\"Value\"])",
											"           //console.log(\"Checksum value of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"Value\"]);",
											"    });",
											"    ",
											"    pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function (){",
											"           pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"           pm.globals.set(\"ChecksumDate\",randomItems[\"Checksum\"][0][\"ChecksumDate\"])",
											"           //console.log(\"ChecksumDate of the last product: \" + jsonDataElements[n][\"Checksum\"][0][\"ChecksumDate\"]);",
											"    });",
											"",
											"    pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function (){",
											"        pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"Start\",randomItems[\"ContentDate\"][\"Start\"])",
											"    });",
											"",
											"    pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function (){",
											"        pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"End\",randomItems[\"ContentDate\"][\"End\"])",
											"    });",
											"",
											"    if (randomItems[\"GeoFootprint\"]) {",
											"        let geofootprint_coordinates_array = randomItems[\"GeoFootprint\"][\"coordinates\"];",
											"        let geofootprint_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"        let geofootprint_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"        pm.test('GeoFootprint:{\"type\": ' + geofootprint_type + ', \"coordinates\": [' + geofootprint_coordinates_array + ']}', function (){",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"           pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"           pm.globals.set(\"GeoFootprintCoordinates\",geofootprint_coordinates);",
											"           pm.globals.set(\"GeoFootprintType\",geofootprint_type);",
											"        }); ",
											"    }",
											"    else {",
											"        console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"        pm.globals.set(\"GeoFootprint\", undefined);",
											"    }",
											"",
											"    var len_array = randomItems[\"Name\"].split('.').length;",
											"    pm.globals.set(\"StartStringName\",randomItems[\"Name\"].split('_')[0] + '_' + randomItems[\"Name\"].split('_')[1])",
											"    pm.globals.set(\"EndStringName\",randomItems[\"Name\"].split('.')[len_array-1])",
											"    pm.globals.set(\"StringName\",randomItems[\"Name\"].split('_')[2])",
											"    pm.globals.set(\"StringName2\",randomItems[\"Name\"].split('_')[3])",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('2')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('2','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('2','1'));",
											"        }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('1')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('1','2'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('1','2'));",
											"        }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('3')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('3','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('3','1'));",
											"        }",
											"",
											"    if(randomItems[\"Name\"].split('_')[0].includes('5')){",
											"        pm.globals.set(\"StringNameNot\",(randomItems[\"Name\"].split('_')[0]).replace('5','1'))",
											"               //console.log((jsonDataElements[n][\"Name\"].split('_')[0]).replace('5','1'));",
											"",
											"        }",
											"",
											"    var randomItems1 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems2 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var randomItems3 = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"",
											"    pm.globals.set(\"product1\",randomItems1[\"Name\"])",
											"    pm.globals.set(\"product2\",randomItems2[\"Name\"])",
											"    pm.globals.set(\"product3\",randomItems3[\"Name\"])",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test Product Listing\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Name",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        //var name = pm.globals.get(\"ProductName\");",
											"        //pm.expect(pm.response.text()).to.includes(name); ",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const product_name = pm.globals.get(\"ProductName\");\r",
											"const name = \"Name eq '\" + product_name + \"'\";\r",
											"const contains_string = \"contains(Name,'_\" + product_name.split('_')[1] + '_' +product_name.split('_')[2] + \"_\" + product_name.split('_')[3] + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + product_name.split('_')[0] + \"_\" + product_name.split('_')[1] + \"')\";\r",
											"    \r",
											"var len_array = product_name.split('.').length;\r",
											"const end_string = \"endswith(Name,'\" + product_name.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"let StringObjects = [name,contains_string,start_string,end_string];\r",
											"var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",itemStringObjects);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{QueryByNameString}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Size",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        var prop_name = \"ContentLength\";",
											"        pm.expect(pm.globals.get(prop_name)).to.equal(jsonDataElements[0][prop_name]);",
											"    });",
											"    //test property",
											"    var prop_name = \"ContentLength\";",
											"    pm.test(\"ContentLength: \" + jsonDataElements[0][prop_name], function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(parseInt(pm.globals.get(prop_name))).to.equal(item[prop_name]);",
											"        }",
											"    });",
											"     ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name , function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('execute_admin_requests') != \"true\"){\r",
											"       postman.setNextRequest(\"DD Product Query By Publication Date\"); \r",
											"   }   "
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentLength eq {{ContentLength}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentLength eq {{ContentLength}}",
											"description": "Size property"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By OriginDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    var date = pm.globals.get(\"OriginDate\");",
											"    var prop_name = \"OriginDate\";",
											"    pm.test(\"OriginDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OriginDate gt {{OriginDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OriginDate gt {{OriginDate}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Publication Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"StartPublicationDate\");",
											"    var prop_name = \"PublicationDate\";",
											"    pm.test(\"PublicationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"  date.setDate(date.getDate() + days);\r",
											"\r",
											"  return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"\r",
											"const start_date = new Date(publication_date);\r",
											"const StartNewDate =  addDays(start_date, -5);\r",
											"const end_date = new Date(publication_date);\r",
											"const EndNewDate = addDays(end_date, 5);\r",
											"\r",
											"pm.globals.set(\"StartPublicationDate\",StartNewDate);\r",
											"pm.globals.set(\"EndPublicationDate\",EndNewDate);\r",
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=PublicationDate gt {{StartPublicationDate}} and PublicationDate lt {{EndPublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate gt {{StartPublicationDate}} and PublicationDate lt {{EndPublicationDate}}",
											"description": "Simple Property PublicationDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Modification",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"ModificationDate\");",
											"    var prop_name = \"ModificationDate\";",
											"    pm.test(\"ModificationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ModificationDate gt {{ModificationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ModificationDate gt {{ModificationDate}}",
											"description": "Complex Property ContentDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Get Online Product",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"    console.log()",
											"    if(jsonDataElements.length){",
											"         ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
											"    var product = randomItems;",
											"    console.log(\"Processing Product: \"+product.Name+\" - \"+product.Id);",
											"",
											"    pm.test(\"Test Properties for product: \" + product.Id, function(){",
											"        pm.expect(product).to.have.property(\"Id\");",
											"        pm.expect(product.Id).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"Name\");",
											"        pm.expect(product.Name).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"ContentType\");",
											"        pm.expect(product.ContentType).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"ContentLength\");",
											"        pm.expect(product.ContentLength).to.be.a(\"number\");",
											"        pm.expect(product).to.have.property(\"OriginDate\");",
											"        pm.expect(product.OriginDate).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"PublicationDate\");",
											"        pm.expect(product.PublicationDate).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"ModificationDate\");",
											"        pm.expect(product.ModificationDate).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"EvictionDate\");",
											"        pm.expect(product.OriginDate).to.be.a(\"string\");",
											"        pm.expect(product).to.have.property(\"Online\");",
											"        pm.expect(product.Online).to.be.a(\"boolean\");",
											"        pm.expect(product).to.have.property(\"Checksum\");",
											"        pm.expect(product.Checksum).to.be.an(\"array\");",
											"        pm.expect(product).to.have.property(\"ContentDate\");",
											"        pm.expect(product.ContentDate).to.be.an(\"object\");",
											"    }); ",
											"",
											"    pm.test(\"Test Eviction Date property: \" + randomItems[\"EvictionDate\"], function (){",
											"        pm.expect(randomItems[\"EvictionDate\"])",
											"        pm.globals.set(\"EvictionDate\",randomItems[\"EvictionDate\"])",
											"    });",
											"    pm.globals.set('OnlineProductId', randomItems[\"Id\"]);",
											"    }",
											"",
											"     ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name , function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq true) and {{ProductTypeCode}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										},
										{
											"key": "$filter",
											"value": "(Online eq true) and {{ProductTypeCode}}",
											"description": "Complex Property ContentDate"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By EvictionDate",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"",
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"EvictionDate\");",
											"    var prop_name = \"EvictionDate\";",
											"    pm.test(\"EvictionDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=EvictionDate ge {{EvictionDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "EvictionDate ge {{EvictionDate}}",
											"description": "Complex Property EvictionDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Sensing Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"    //test property",
											"    var date = pm.globals.get(\"Start\");",
											"    var prop_name = \"ContentDate\";",
											"    pm.test(\"Sensing Date: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"           pm.expect(Date.parse(item[prop_name][\"Start\"])).to.be.gte(Date.parse(date));",
											"        }",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(!pm.globals.get(\"GeoFootprintCoordinates\")){\r",
											"        postman.setNextRequest(\"DD Product Details\");\r",
											"    }"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}",
											"description": "Complex Property ContentDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Geographic Criteria (GeoFootPrint)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    //test property",
											"    var id = pm.globals.get(\"ProductId\");",
											"    const result = jsonDataElements.find(m => m.Id === id);",
											"",
											"    pm.test(\"GeoFootprint\", function(){",
											"        pm.expect(id).to.equal(result.Id);",
											"    });",
											"               ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"var geofoot_coordinates = pm.globals.get(\"GeoFootprintCoordinates\");\r",
											"// provide geofootprint string\r",
											"if (geofoot_coordinates) { \r",
											"    var geofoot_type = pm.globals.get(\"GeoFootprintType\");\r",
											"    let geofoot = '';\r",
											"    for (let i = 0; i < geofoot_coordinates.length; i++) {\r",
											"        if(i !== geofoot_coordinates.length-1){\r",
											"            geofoot += String(geofoot_coordinates[i]).replace(',', ' ') + ',';\r",
											"        }else{\r",
											"            geofoot += String(geofoot_coordinates[i]).replace(',', ' ');\r",
											"        }  \r",
											"    } \r",
											"    let geofoot_string = [\"geography'SRID=4326;\", String(geofoot_type), \"((\", String(geofoot), \"))'\"].join('');\r",
											"    pm.globals.set(\"GeoFootprintSearchString\",geofoot_string);\r",
											"    \r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=OData.CSC.Intersects(area={{Footprint}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "OData.CSC.Intersects(area={{Footprint}}) and {{ProductTypeCode}} and PublicationDate ge {{PublicationDate}}"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json();",
											"    var id = pm.globals.get(\"ProductId\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Test product id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"        //check the product status",
											"        console.log(\"Product: \" + jsonDataElements.Name + \" Online=\" + jsonDataElements.Online);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(\"Test Product Details\", function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
											"       postman.setNextRequest(\"DD Product Attributes Expand Query\"); \r",
											"   }   "
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products({{ProductId}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Query by List",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\"FilterProducts\":[\r\n\t{\"Name\": \"{{product1}}\"},\r\n    {\"Name\": \"{{product2}}\"},\r\n    {\"Name\": \"{{product3}}\"}\r\n]}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products/OData.CSC.FilterList",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products",
										"OData.CSC.FilterList"
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Attributes Expand Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function propertySpecific(key, attr, items) {",
											"    const ProductObject = items.Attributes.find(m => m.Name === attr[key]);",
											"    //console.log(ProductObject);",
											"    if (ProductObject !== undefined) {",
											"        pm.test(\"Response body contains \" + attr[key], function() {",
											"            pm.expect(ProductObject).not.eq(undefined);",
											"            pm.expect(ProductObject.Name).to.be.a(\"string\");",
											"            pm.expect(ProductObject.ValueType).to.be.a(\"string\");",
											"            pm.expect(ProductObject.Value).not.eq(undefined)",
											"            pm.globals.set(ProductObject.Name, ProductObject.Value);",
											"            pm.globals.set(\"flag_\" + ProductObject.Name, \"true\");",
											"        });",
											"    } else {",
											"        console.warn(\"Skipped \" + attr[key] + \" attribute test\");",
											"    }",
											"}",
											"",
											"// attributes",
											"const elements_s1 = [\"beginningDateTime\", \"endingDateTime\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"operationalMode\", \"polarisationChannels\", \"orbitNumber\", \"relativeOrbitNumber\", \"cycleNumber\", \"orbitDirection\", \"coordinates\", \"productType\", \"productClass\"];",
											"",
											"const elements_s1_aux = [\"processingDate\", \"processingCenter\", \"platformShortName\", \"platformSerialIdentifier\", \"instrumentShortName\", \"beginningDateTime\", \"productGeneration\"];",
											"",
											"const elements_s2 = [\"productGroupId\", \"processorVersion\", \"processingDate\", \"beginningDateTime\", \"endingDateTime\", \"orbitNumber\", \"coordinates\", \"qualityStatus\", \"productType\", \"instrumentShortName\", \"processingCenter\", \"platformSerialIdentifier\", \"platformShortName\", \"operationalMode\", \"relativeOrbitNumber\"]",
											"",
											"const elements_s2_aux = [\"platformShortName\", \"platformSerialIdentifier\", \"productType\", \"beginningDateTime\", \"endingDateTime\", \"processingCenter\", \"processorVersion\", \"processingDate\"];",
											"",
											"const elements_s3 = [\"beginningDateTime\", \"endingDateTime\", \"instrumentShortName\", \"productType\", \"timeliness\", \"orbitNumber\", \"lastOrbitNumber\", \"relativeOrbitNumber\", \"cycleNumber\", \"processorName\"];",
											"",
											"const elements_s3_aux = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"const elements_pod = [\"productType\", \"timeliness\", \"platformShortName\", \"platformSerialIdentifier\", \"processorName\", \"beginningDateTime\", \"endingDateTime\"];",
											"",
											"try {",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        if (pm.response.code !== 200) {",
											"            postman.setNextRequest(\"DD Additional Options (orderby asc)\");",
											"        }",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    pm.globals.set('headers-format', pm.response.headers.get('Content-Type'));",
											"    const header_format = pm.globals.get('headers-format');",
											"    const format = \"application/json\"",
											"    const zip_format = \"application/zip\"",
											"",
											"    pm.test(\"Content-Type header is correct\", function() {",
											"        if (header_format.includes(zip_format)) {",
											"            pm.expect(header_format).to.includes(zip_format);",
											"            console.warn(\"The Content-Type header is \" + header_format);",
											"            console.warn(\"The Attributes requests are skipped. \");",
											"            postman.setNextRequest(\"DD Additional Options (orderby asc)\");",
											"        } else {",
											"",
											"            if (!header_format.includes(format)) {",
											"                console.warn(\"The Content-Type header is \" + header_format);",
											"                console.warn(\"The Attributes requests are skipped. \");",
											"                postman.setNextRequest(\"DD Additional Options (orderby asc)\")",
											"            }",
											"",
											"            pm.expect(header_format).to.includes(format);",
											"        }",
											"    });",
											"",
											"",
											"    if (header_format.includes(format)) {",
											"        var jsonDataElements = pm.response.json().value;",
											"",
											"        // extract the attributes for the next subsequent tests",
											"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems1 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        var randomItems2 = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"        let productTypeObject1 = randomItems1.Attributes.find(m => m.Name === \"productType\");",
											"        let productTypeObject2 = randomItems2.Attributes.find(m => m.Name === \"productType\");",
											"",
											"        if (productTypeObject1) {",
											"            pm.globals.set(\"productType2\", productTypeObject1[\"Value\"]);",
											"        }",
											"        if (productTypeObject2) {",
											"            pm.globals.set(\"productType3\", productTypeObject2[\"Value\"]);",
											"        }",
											"",
											"        var found_element;",
											"        var name = randomItems.Name",
											"        if (name.startsWith('S1') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s1;",
											"        } else if (name.startsWith('S1') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s1_aux;",
											"        } else if (name.startsWith('S2') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s2;",
											"        } else if (name.startsWith('S2') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s2_aux;",
											"        } else if (name.startsWith('S3') && !name.includes('AUX') && !name.includes('AX')) {",
											"            found_element = elements_s3;",
											"        } else if (name.startsWith('S3') && name.includes('AUX') && name.includes('AX')) {",
											"            found_element = elements_s3_aux;",
											"        } else {",
											"            found_element = elements_pod;",
											"        }",
											"",
											"        // check properties",
											"        pm.test(\"Products Name: \" + randomItems[\"Name\"], function() {",
											"            pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Products Id: \" + randomItems[\"Id\"], function() {",
											"            pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        });",
											"",
											"        pm.test(\"ContentType: \" + randomItems[\"ContentType\"], function() {",
											"            pm.expect(randomItems[\"ContentType\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"ContentLength: \" + randomItems[\"ContentLength\"], function() {",
											"            pm.expect(randomItems[\"ContentLength\"]).to.be.a(\"number\");",
											"        });",
											"",
											"        pm.test(\"Origin date: \" + randomItems[\"OriginDate\"], function() {",
											"            pm.expect(randomItems[\"OriginDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Publication date: \" + randomItems[\"PublicationDate\"], function() {",
											"            pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Modification date: \" + randomItems[\"ModificationDate\"], function() {",
											"            pm.expect(randomItems[\"ModificationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"Test Online status property: \" + randomItems[\"Online\"], function() {",
											"            pm.expect(randomItems[\"Online\"]).to.be.a(\"boolean\");",
											"        });",
											"",
											"        pm.test(\"Checksum algorithm: \" + randomItems[\"Checksum\"][0][\"Algorithm\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Algorithm\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum value: \" + randomItems[\"Checksum\"][0][\"Value\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"Value\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Checksum date: \" + randomItems[\"Checksum\"][0][\"ChecksumDate\"], function() {",
											"            pm.expect(randomItems[\"Checksum\"][0][\"ChecksumDate\"]).to.be.a(\"string\");",
											"        });",
											"",
											"        pm.test(\"Start sensing date: \" + randomItems[\"ContentDate\"][\"Start\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"Start\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        pm.test(\"End sensing date: \" + randomItems[\"ContentDate\"][\"End\"], function() {",
											"            pm.expect(randomItems[\"ContentDate\"][\"End\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        });",
											"",
											"        if (randomItems[\"GeoFootprint\"]) {",
											"            let geofootprint_coordinates_array = randomItems[\"GeoFootprint\"][\"coordinates\"];",
											"            let geofootprint_coordinates = randomItems[\"GeoFootprint\"][\"coordinates\"][0];",
											"            let geofootprint_type = randomItems[\"GeoFootprint\"][\"type\"];",
											"            pm.test('GeoFootprint:{\"type\": ' + geofootprint_type + ', \"coordinates\": [' + geofootprint_coordinates_array + ']}', function() {",
											"                pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('type');",
											"                pm.expect(randomItems[\"GeoFootprint\"]).to.have.property('coordinates');",
											"            });",
											"        } else {",
											"            console.warn(\"Not found GeoFootprint: \" + randomItems.Name);",
											"        }",
											"",
											"        // Test that the correct odata context is returned",
											"        console.log(\"Test that the correct attributes are returned for product: \" + name);",
											"        for (var key in found_element) {",
											"            propertySpecific(key, found_element, randomItems);",
											"        }",
											"",
											"        const processor_version = randomItems.Attributes.find(m => m.Name === \"processorVersion\");",
											"        if (processor_version !== undefined) {",
											"            //console.log(processor_version);",
											"            pm.globals.set(processor_version.Name, processor_version.Value);",
											"            pm.globals.set(\"flag_processorVersion\", \"true\");",
											"        }",
											"    }",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}&$expand=Attributes&$format=json&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}} and ContentDate/Start ge {{Start}} and ContentDate/End le {{End}}"
										},
										{
											"key": "$expand",
											"value": "Attributes"
										},
										{
											"key": "$format",
											"value": "json"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (InstrumentShortName)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_instrumentShortName\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'instrumentShortName' and att/OData.CSC.StringAttribute/Value eq '{{instrumentShortName}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (operationalMode)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_operationalMode\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'operationalMode' and att/OData.CSC.StringAttribute/Value eq '{{operationalMode}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'operationalMode' and att/OData.CSC.StringAttribute/Value eq '{{operationalMode}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (orbitNumber)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_orbitNumber\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"       ",
											"       var jsonDataElements = pm.response.json().value;",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.IntegerAttribute/any(att:att/Name eq 'orbitNumber' and att/OData.CSC.IntegerAttribute/Value eq {{orbitNumber}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (processingDate)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_processingDate\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DateTimeOffsetAttribute/any(att:att/Name eq 'processingDate' and att/OData.CSC.DateTimeOffsetAttribute/Value eq {{processingDate}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (productGroupId)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productGroupId\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productGroupId' and att/OData.CSC.StringAttribute/Value eq '{{productGroupId}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productGroupId' and att/OData.CSC.StringAttribute/Value eq '{{productGroupId}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (qualityStatus)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_qualityStatus\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'qualityStatus' and att/OData.CSC.StringAttribute/Value eq '{{qualityStatus}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'qualityStatus' and att/OData.CSC.StringAttribute/Value eq '{{qualityStatus}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (cloudCover)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_cloudCover\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"   console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.DoubleAttribute/any(att:att/Name eq 'cloudCover' and att/OData.CSC.DoubleAttribute/Value eq {{cloudCover}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.DoubleAttribute/any(att:att/Name eq 'cloudCover' and att/OData.CSC.DoubleAttribute/Value eq {{cloudCover}})",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (productClass)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productClass\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productClass' and att/OData.CSC.StringAttribute/Value eq '{{productClass}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productClass' and att/OData.CSC.StringAttribute/Value eq '{{productClass}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (timeliness)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_timeliness\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'timeliness' and att/OData.CSC.StringAttribute/Value eq '{{timeliness}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (combining productType and processorVersion)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_productType\") === \"true\" && pm.globals.get(\"flag_processorVersion\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"",
											"       var jsonDataElements = pm.response.json().value;",
											"       ",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{productType}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'processorVersion' and att/OData.CSC.StringAttribute/Value eq '{{processorVersion}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Product Query By Attributes (combining platformShortName & platformSerialIdentifier)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.globals.get(\"flag_platformShortName\") === \"true\" && pm.globals.get(\"flag_platformSerialIdentifier\") === \"true\"){",
											"    try {",
											"       ",
											"       //check if the response code is 200",
											"       pm.test(\"Test Response Status Code\", function(){",
											"          pm.expect(pm.response.code).to.be.oneOf([200]);",
											"       });",
											"       ",
											"       var jsonDataElements = pm.response.json().value;",
											"",
											"      //MIN number of Records Test",
											"      var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"      pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
											"         pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"      });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}",
											"}else{",
											"    console.warn(\"Skipped \" + request.name);",
											"}",
											" "
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformShortName' and att/OData.CSC.StringAttribute/Value eq '{{platformShortName}}') and Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'platformSerialIdentifier' and att/OData.CSC.StringAttribute/Value eq '{{platformSerialIdentifier}}')",
											"description": "Query by Attributes"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Additional Options (orderby asc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											" ",
											"     //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyAsc}} asc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyAsc}} asc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Additional Options (orderby desc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" try {",
											"    ",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$filter={{ProductTypeCode}}&$orderby={{PropertyDesc}} desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{ProductTypeCode}}"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}} desc",
											"description": "ORDERBY"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Additional Options (top)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											" ",
											"try {",
											"",
											"    //check if the response code is 200",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											" ",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"\r",
											"\r",
											"\r",
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$top={{top}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$top",
											"value": "{{top}}",
											"description": "Specify the maximum (non-negative integer) number of items returned"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Additional Options (skip)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"  ",
											"try {",
											"    ",
											"    //check if the response code is 200",
											"     pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											" ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$skip={{skip}}&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$skip",
											"value": "{{skip}}",
											"description": "Specify a (non-negative integer) number of items excluded from the start"
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "DD Additional Options (count)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //check if the response code is 200",
											"    ",
											"    pm.test(\"Test Response Status Code\", function(){",
											"       pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    // verify that the number of the matching resources is returned as result.",
											"    var data_counter = pm.response.json()[\"@odata.count\"];",
											"    pm.test(\"The number of the matching resources is returned: \" + data_counter, function(){",
											"        pm.expect(data_counter).to.be.a(\"number\");",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Products?$count=true&$filter=startswith(Name,'{{StartStringName}}')",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Products"
									],
									"query": [
										{
											"key": "$count",
											"value": "true",
											"description": "Request a count of the matching resources"
										},
										{
											"key": "$top",
											"value": "100",
											"disabled": true
										},
										{
											"key": "$filter",
											"value": "startswith(Name,'{{StartStringName}}')"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "DD Orders (all cases)",
					"item": [
						{
							"name": "DD Orders",
							"item": [
								{
									"name": "DD Create Order",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Offline Products",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"    while (x.toString().length < n) {\r",
															"        x = \"0\" + x;\r",
															"    }\r",
															"    return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today; // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        if(pm.response.code !== 200){\r",
															"            //Not found offline products and array is empty.\r",
															"            postman.setNextRequest(\"DD Get Online Products\");\r",
															"            console.log(\"Set next request to: 'DD Get Online Products' .\");\r",
															"        } \r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]); \r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    // find online product\r",
															"    const online_product = jsonDataElements.find(m => m.Online === true);\r",
															"\r",
															"    if (!jsonDataElements.length || online_product) {\r",
															"        //Not found offline products and array is empty.\r",
															"        postman.setNextRequest(\"DD Get Online Products\");\r",
															"        console.log(\"Set next request to: 'DD Get Online Products' .\")\r",
															"    } else {\r",
															"        //MIN number of Records Test\r",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"        pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
															"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"        });\r",
															"\r",
															"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
															"        const sizeLimit = 80000000;\r",
															"\r",
															"        for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"            //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"            if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {\r",
															"                randomItems = jsonDataElements[i];\r",
															"                console.log(\"Product found! \");\r",
															"                break;\r",
															"            }\r",
															"        }\r",
															"\r",
															"        console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
															"        console.log(randomItems);\r",
															"\r",
															"        pm.test(\"Test Properties for product: \" + randomItems['Id'], function () {\r",
															"            pm.expect(randomItems).to.have.property(\"Id\");\r",
															"            pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"Name\");\r",
															"            pm.expect(randomItems.Name).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"ContentType\");\r",
															"            pm.expect(randomItems.ContentType).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"ContentLength\");\r",
															"            pm.expect(randomItems.ContentLength).to.be.a(\"number\");\r",
															"            pm.expect(randomItems).to.have.property(\"OriginDate\");\r",
															"            pm.expect(randomItems.OriginDate).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"PublicationDate\");\r",
															"            pm.expect(randomItems.PublicationDate).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"ModificationDate\");\r",
															"            pm.expect(randomItems.ModificationDate).to.be.a(\"string\");\r",
															"            pm.expect(randomItems).to.have.property(\"Online\");\r",
															"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(randomItems).to.have.property(\"Checksum\");\r",
															"            pm.expect(randomItems.Checksum).to.be.an(\"array\");\r",
															"            pm.expect(randomItems).to.have.property(\"ContentDate\");\r",
															"            pm.expect(randomItems.ContentDate).to.be.an(\"object\");\r",
															"        });\r",
															"        \r",
															"        // verify online status\r",
															"        pm.test(\"Test online status: \" + randomItems.Online, function () {\r",
															"            pm.expect(randomItems).to.have.property(\"Online\");\r",
															"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(randomItems.Online).to.eq(false);\r",
															"        });\r",
															"\r",
															"        console.log(\"Product online status is: \" + randomItems.Online);\r",
															"        pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
															"        pm.globals.set('ProductId', randomItems.Id);\r",
															"        pm.globals.set('ProductName', randomItems.Name);\r",
															"        pm.globals.set('ContentLength', randomItems.ContentLength);\r",
															"        \r",
															"    }\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"//pm.globals.unset(\"download_counter\");"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{ProductTypeCode}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq false) and {{ProductTypeCode}}"
														},
														{
															"key": "$top",
															"value": "100",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Order Request",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    // Test that an order is returned with an Id\r",
															"    pm.test(\"Test product order submitted \", function () {\r",
															"        pm.expect(jsonDataElements.Id);\r",
															"    });\r",
															"\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"\r",
															"    for (const [key, value] of Object.entries(properties_map)) {\r",
															"        propertySpecific(key, order);\r",
															"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{OrderPriority}}\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{ProductId}})",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function() {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of records Test: \" + minimumExpRecords, function() {\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    for (var counter = 0; counter < jsonDataElements.length; counter++) {\r",
															"        var current_order = jsonDataElements[counter];\r",
															"        console.log(\"Processing Order: \" + current_order.Id);\r",
															"\r",
															"        pm.test(\"Test Properties for Order: \" + current_order.Id, function() {\r",
															"            pm.expect(current_order).to.have.property(\"Id\");\r",
															"            pm.expect(current_order.Id).to.be.a(\"string\");\r",
															"            pm.expect(current_order).to.have.property(\"Status\");\r",
															"            pm.expect(current_order.Status).to.be.a(\"string\");\r",
															"            pm.expect(current_order).to.have.property(\"StatusMessage\");\r",
															"            pm.expect(current_order.StatusMessage).to.be.a(\"string\");\r",
															"            pm.expect(current_order).to.have.property(\"SubmissionDate\");\r",
															"            pm.expect(current_order.SubmissionDate).to.be.a(\"string\");\r",
															"            pm.expect(current_order).to.have.property(\"EstimatedDate\");\r",
															"            pm.expect(current_order.EstimatedDate).to.be.a(\"string\");\r",
															"            pm.expect(current_order.Priority).to.be.a(\"number\");\r",
															"        });\r",
															"    }\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function() {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$top",
															"value": "10",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Id Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"        \r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    //test id order\r",
															"    var id = pm.globals.get(\"OrderId\");\r",
															"    console.log(\"Order Id is: \" + id);\r",
															"    pm.test(\"Order Id: \" + id, function(){\r",
															"        pm.expect(jsonDataElements.Id).to.be.eql(id);\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order SubmissionDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var date = pm.globals.get(\"OrderSubmissionDate\");\r",
															"    var prop_name = \"SubmissionDate\";\r",
															"    pm.test(\"SubmissionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });  \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=SubmissionDate ge {{OrderSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate ge {{OrderSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Listing Query (orderby asc)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    \r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of records Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$orderby={{PropertyAsc}} asc",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "{{PropertyAsc}} asc"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Listing Query (orderby desc)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of records Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$orderby={{PropertyAsc}} desc",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "{{PropertyAsc}} desc"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Listing Query (top)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    \r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of records Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$top=10",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$top",
															"value": "10"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Listing Query (skip)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"   \r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of records Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    postman.setNextRequest(null);\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$skip=10",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$skip",
															"value": "10"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Online Products",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"    while (x.toString().length < n) {\r",
															"        x = \"0\" + x;\r",
															"    }\r",
															"    return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"        today = yyyy + '-' + mm + '-' + dd; //  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today; // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
															"    const sizeLimit = 80000000;\r",
															"\r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"        if (jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()) {\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found! \");\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"\r",
															"    pm.test(\"Test Id for product: \" + randomItems.Id, function () {\r",
															"        pm.expect(randomItems).to.have.property(\"Id\");\r",
															"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test Online status for product: \" + randomItems.Online, function () {\r",
															"        pm.expect(randomItems).to.have.property(\"Online\");\r",
															"        pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"        pm.expect(randomItems.Online).to.eq(true);\r",
															"    });\r",
															"\r",
															"    console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
															"    console.log(randomItems);\r",
															"\r",
															"    console.log(\"Product online status is: \" + randomItems.Online);\r",
															"    pm.globals.set('ProductId', randomItems.Id);\r",
															"    pm.globals.set('ProductName', randomItems.Name);\r",
															"    pm.globals.set('ContentLength', randomItems.ContentLength);\r",
															"    pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
															"    \r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq true) and {{ProductTypeCode}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq true) and {{ProductTypeCode}}"
														},
														{
															"key": "$top",
															"value": "100",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Product Retrieval",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															"\r",
															"\r",
															"if(pm.globals.get(\"OnlineStatus\") == \"true\"){\r",
															"       postman.setNextRequest(\"DD Product Download By ProductId\"); \r",
															"   }   "
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Completed Order Properties",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"\r",
															"properties_map.Id = function (element) {\r",
															"    pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);\r",
															"};\r",
															"\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"\r",
															"properties_map.StatusMessage = function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority = function (element) {\r",
															"    pm.expect(element.Priority).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) {\r",
															"    pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EstimatedDate = function (element) {\r",
															"    pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"\r",
															"properties_map.OrderSize = function (element) {\r",
															"    pm.expect(element.OrderSize).to.be.a(\"number\");\r",
															"};\r",
															"properties_map.CompletedDate = function (element) {\r",
															"    pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.EvictionDate = function (element) {\r",
															"    if (element.EvictionDate) {\r",
															"        pm.expect(element.EvictionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    }\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order) {\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \" + key + \" for Order: \" + order[key], function () {\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);\r",
															"        });\r",
															"    } else {\r",
															"        console.warn(\"Test Property \" + key + \" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value[0];\r",
															"\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"    pm.globals.set(\"OrderStatus\", order.Status);\r",
															"    console.log(\"Order status is: \" + order.Status);\r",
															"    if (order.Status == \"completed\") {\r",
															"        for (const[key, value]of Object.entries(properties_map)) {\r",
															"            propertySpecific(key, order);\r",
															"            pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"        }\r",
															"        pm.globals.set('CompletedOrderId', order.Id);\r",
															"        console.log(\"The product download can be requested ...\");\r",
															"    } else {\r",
															"        postman.setNextRequest(null);\r",
															"        console.warn(\"Skipped Test Property for Order in status: \" + order.Status);\r",
															"    }\r",
															"    pm.globals.set(\"DownloadStatus\", order.Status);\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "basic",
													"basic": [
														{
															"key": "password",
															"value": "{{password}}",
															"type": "string"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Id eq {{OrderId}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Id eq {{OrderId}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Orders Listing Query (status Completed)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function() {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function() {\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var current_order = jsonDataElements.find(m => m.Id === pm.globals.get(\"OrderId\"));\r",
															"    console.log(\"Processing Order: \" + current_order.Id);\r",
															"\r",
															"    pm.test(\"Test Properties for Order: \" + current_order.Id, function() {\r",
															"        pm.expect(current_order).to.have.property(\"Id\");\r",
															"        pm.expect(current_order.Id).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"Status\");\r",
															"        pm.expect(current_order.Status).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"StatusMessage\");\r",
															"        pm.expect(current_order.StatusMessage).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"SubmissionDate\");\r",
															"        pm.expect(current_order.SubmissionDate).to.be.a(\"string\");\r",
															"        pm.expect(current_order).to.have.property(\"EstimatedDate\");\r",
															"        pm.expect(current_order.EstimatedDate).to.be.a(\"string\");\r",
															"        pm.expect(current_order.Priority).to.be.a(\"number\");\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function() {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Status eq OData.CSC.JobStatus'completed'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'completed'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order Status Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var status = pm.globals.get(\"OrderStatus\");\r",
															"    var prop_name = \"Status\";\r",
															"    pm.test(\"Status: \" + status, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            console.log(item[prop_name])\r",
															"            pm.expect(status).to.equal(item[prop_name]);\r",
															"        }\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Status eq OData.CSC.JobStatus'{{OrderStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'{{OrderStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order StatusMessage Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    //test property\r",
															"    var status_mess = pm.globals.get(\"OrderStatusMessage\");\r",
															"    var prop_name = \"StatusMessage\";\r",
															"    pm.test(\"StatusMessage: \" + status_mess, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(status_mess).to.equal(item[prop_name]);\r",
															"        }\r",
															"    });    \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=StatusMessage eq '{{OrderStatusMessage}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "StatusMessage eq '{{OrderStatusMessage}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order OrderSize Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){ \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var size = pm.globals.get(\"OrderOrderSize\");\r",
															"    var prop_name = \"OrderSize\";\r",
															"    pm.test(\"OrderSize: \" + size, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"            pm.expect(parseInt(size)).to.equal(item[prop_name]); \r",
															"        }\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=OrderSize eq {{OrderOrderSize}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "OrderSize eq {{OrderOrderSize}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order CompletedDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"     \r",
															"    var date = pm.globals.get(\"OrderCompletedDate\");\r",
															"    var prop_name = \"CompletedDate\";\r",
															"    pm.test(\"CompletedDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });  \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=CompletedDate ge {{OrderCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "CompletedDate ge {{OrderCompletedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order EvictionDate Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var date = pm.globals.get(\"OrderEvictionDate\");\r",
															"    var prop_name = \"EvictionDate\";\r",
															"    pm.test(\"EvictionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });  \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=EvictionDate ge {{OrderEvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate ge {{OrderEvictionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Online Product By Order",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    console.log(jsonDataElements[\"Online\"]);\r",
															"\r",
															"    pm.test(\"Product Property Online\", function(){\r",
															"        pm.expect(jsonDataElements[\"Online\"]).be.equal(true);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Eviction date: \" + jsonDataElements[\"EvictionDate\"], function (){\r",
															"        pm.expect(jsonDataElements[\"EvictionDate\"])\r",
															"        pm.globals.set(\"EvictionDate\",jsonDataElements[\"EvictionDate\"])\r",
															"    });\r",
															"\r",
															"    pm.globals.set('ProductId', jsonDataElements.Id);\r",
															"    pm.globals.set('ProductName', jsonDataElements.Name);\r",
															"    pm.globals.set(\"OnlineStatus\",jsonDataElements.Online.toString());\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{CompletedOrderId}})/Product",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{CompletedOrderId}})",
														"Product"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Query By EvictionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"",
															"try {",
															"    // test status code",
															"    pm.test(\"Test Response Status Code\", function(){",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);",
															"    });",
															"",
															"    var jsonDataElements = pm.response.json().value;",
															"",
															"    //MIN number of Records Test",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"        console.log(jsonDataElements.length + \" products found: \");",
															"    });",
															"",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$filter=EvictionDate ge {{EvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate ge {{EvictionDate}}",
															"description": "Complex Property EvictionDate"
														},
														{
															"key": "$top",
															"value": "10",
															"disabled": true
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Download By OrderId",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"try {\r",
															"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //console.log(pm.response);\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Downloaded Size\", function(){\r",
															"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"followAuthorizationHeader": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{CompletedOrderId}})/Product/$value",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{CompletedOrderId}})",
														"Product",
														"$value"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Download By ProductId",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"try {\r",
															"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //console.log(pm.response);\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Downloaded Size\", function(){\r",
															"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
															"    });\r",
															"\r",
															"    pm.globals.set(\"DownloadStatus\", \"completed\");\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"protocolProfileBehavior": {
												"followAuthorizationHeader": true
											},
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/$value",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{ProductId}})",
														"$value"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"if(!pm.globals.get('OnlineStatus')){",
													"       postman.setNextRequest(null); ",
													"   }  "
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "DD Cancel Order By Id",
									"item": [
										{
											"name": "DD Order Cancel",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority=function (element) {pm.expect(element.Priority).to.be.a(\"number\");}; \r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"properties_map.EstimatedDate=function (element) {pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"// comment out OrderSize check\r",
															"// properties_map.OrderSize=function (element) {pm.expect(element.OrderSize).to.be.equal(0);};\r",
															"properties_map.CompletedDate=function (element) {pm.expect(element.CompletedDate).to.be.equal(null);};\r",
															"properties_map.EvictionDate=function (element) {if(element.EvictionDate){ pm.expect(element.EvictionDate).to.be.equal(null); }};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       postman.setNextRequest(null); ",
											"   }   "
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						},
						{
							"name": "DD Orders (Product Staging Notification)",
							"item": [
								{
									"name": "DD Create Order (Product Staging Notification)",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Offline Products (staging notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    var time = \"00:00:00.000000\"\r",
															"    today = yyyy + '-' + mm + '-' + dd;//  + 'T' + time + 'Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        if(pm.response.code !== 200){\r",
															"            //Not found offline products and array is empty.\r",
															"            postman.setNextRequest(null);\r",
															"            console.log(\"Set next request to: 'DD Get Online Products' .\");\r",
															"        } \r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]); \r",
															"    }); \r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    const sizeLimit = 80000000;\r",
															"    \r",
															"    for (let i = 0; i < jsonDataElements.length; i++) {\r",
															"        //console.log(jsonDataElements[i][\"PublicationDate\"].split('T')[0]);\r",
															"        if(jsonDataElements[i][\"ContentLength\"] <= sizeLimit && jsonDataElements[i][\"PublicationDate\"].split('T')[0] == GetCurrentDate()){\r",
															"            randomItems = jsonDataElements[i];\r",
															"            console.log(\"Product found! \");\r",
															"            break;\r",
															"        }\r",
															"    }\r",
															"    \r",
															"    console.log(\"Processing product: \"+randomItems['Name']+\" (\"+randomItems['Id'] + \")\");\r",
															"    console.log(randomItems);\r",
															"    console.log(\"Product online status is: \" + randomItems.Online);\r",
															"    pm.globals.set('ProductId', randomItems.Id);\r",
															"    pm.globals.set('ProductName', randomItems.Name);\r",
															"    pm.globals.set(\"OnlineStatus\",randomItems.Online.toString());\r",
															"\r",
															"    pm.test(\"Test Properties for product: \" + randomItems['Id'], function(){\r",
															"        pm.expect(randomItems).to.have.property(\"Id\");\r",
															"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"Name\");\r",
															"        pm.expect(randomItems.Name).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"ContentType\");\r",
															"        pm.expect(randomItems.ContentType).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"ContentLength\");\r",
															"        pm.expect(randomItems.ContentLength).to.be.a(\"number\");\r",
															"        pm.expect(randomItems).to.have.property(\"OriginDate\");\r",
															"        pm.expect(randomItems.OriginDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"PublicationDate\");\r",
															"        pm.expect(randomItems.PublicationDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"ModificationDate\");\r",
															"        pm.expect(randomItems.ModificationDate).to.be.a(\"string\");\r",
															"        pm.expect(randomItems).to.have.property(\"Online\");\r",
															"        pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"        pm.expect(randomItems).to.have.property(\"Checksum\");\r",
															"        pm.expect(randomItems.Checksum).to.be.an(\"array\");\r",
															"        pm.expect(randomItems).to.have.property(\"ContentDate\");\r",
															"        pm.expect(randomItems.ContentDate).to.be.an(\"object\");\r",
															"        });\r",
															"\r",
															"        // verify online status\r",
															"        pm.test(\"Test online status: \" + randomItems.Online, function () {\r",
															"            pm.expect(randomItems).to.have.property(\"Online\");\r",
															"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
															"            pm.expect(randomItems.Online).to.eq(false);\r",
															"        });\r",
															"        \r",
															"        const online_product = jsonDataElements.find(m => m.Online === true);\r",
															"        if (!jsonDataElements.length || online_product) {\r",
															"              //Not found offline products and array is empty.\r",
															"             postman.setNextRequest(null);\r",
															"             console.warn(\"Not found offline product!\")\r",
															"        }\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{ProductTypeCode}}&$top=100",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														},
														{
															"key": "$filter",
															"value": "(Online eq false) and {{ProductTypeCode}}"
														},
														{
															"key": "$top",
															"value": "100"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Order (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"function addZero(x, n) {\r",
															"  while (x.toString().length < n) {\r",
															"    x = \"0\" + x;\r",
															"  }\r",
															"  return x;\r",
															"}\r",
															"\r",
															"function GetCurrentDate() {\r",
															"    // Online Javascript Editor for free\r",
															"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
															"    var today = new Date();\r",
															"    var dd = String(today.getDate()).padStart(2, '0');\r",
															"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!\r",
															"    var yyyy = today.getFullYear();\r",
															"    var h = addZero(today.getHours(), 2);\r",
															"    var m = addZero(today.getMinutes(), 2);\r",
															"    var s = addZero(today.getSeconds(), 2);\r",
															"    var ms = addZero(today.getMilliseconds(), 6);\r",
															"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
															"    \r",
															"    today = yyyy + '-' + mm + '-' + dd + 'T' + h + ':'+ m + ':' + s + '.000Z';\r",
															"    //console.log(today)\r",
															"    return today;   // The function returns the product of p1 and p2\r",
															"}\r",
															"\r",
															"\r",
															"//var date = GetCurrentDate()\r",
															"//console.log(\"Notification Date is: \" + date);\r",
															"//pm.globals.set(\"NotificationDate\", date);"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Skipped Test Property \" + key + \" for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function () {\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json();\r",
															"\r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"\r",
															"    for (const [key, value] of Object.entries(properties_map)) {\r",
															"        propertySpecific(key, order);\r",
															"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"    }\r",
															"\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"Priority\": {{OrderPriority}},\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products({{ProductId}})/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products({{ProductId}})",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "DD Monitor Order Notification",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Product Id from Server logs for Order",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(product_id));\r",
															"console.log(notification);\r",
															"pm.globals.set(\"NotificationProductId\",\"false\");\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code \r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(product_id);\r",
															"            console.log(\"Found product id: \" + product_id);\r",
															"        });\r",
															"\r",
															"        var date = JSON.parse(notification.request.body.data).NotificationDate\r",
															"        \r",
															"        console.log(\"Notification Date is: \" + date);\r",
															"        pm.globals.set(\"NotificationDate\", date);\r",
															"        pm.globals.set(\"NotificationProductId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Send Product Staging Notification",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Completed Order Properties (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"\r",
															"properties_map.Id=function (element) {pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);};\r",
															"\r",
															"properties_map.Status=function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\",\"queued\",\"failed\",\"completed\", \"cancelled\"]);\r",
															"};\r",
															"\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"}; \r",
															"properties_map.Priority=function (element) {pm.expect(element.Priority).to.be.a(\"number\");}; \r",
															"properties_map.SubmissionDate=function (element) {pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"properties_map.EstimatedDate=function (element) {pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"\r",
															"properties_map.OrderSize=function (element) {pm.expect(element.OrderSize).to.be.a(\"number\");};\r",
															"properties_map.CompletedDate=function (element) {pm.expect(element.CompletedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);};\r",
															"properties_map.EvictionDate=function (element) {if(element.EvictionDate){ pm.expect(element.EvictionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); }};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for Order: \" + order[key]);\r",
															"    }\r",
															"}\r",
															"\r",
															"try {\r",
															"    // test stattus code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value[0];\r",
															" \r",
															"    //test property for order\r",
															"    var order = jsonDataElements;\r",
															"    \r",
															"    console.log(\"Order status is: \" + order.Status);\r",
															"    if(order.Status == \"completed\"){\r",
															"       for (const[key, value] of Object.entries(properties_map)){\r",
															"         propertySpecific(key, order);\r",
															"         pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
															"       }\r",
															"       pm.globals.set('CompletedOrderId', order.Id);\r",
															"       console.log(\"The product download can be requested ...\");\r",
															"    } else{\r",
															"         console.warn(\"Skipped Test Property for Order in status: \" + order.Status);\r",
															"         postman.setNextRequest(null);\r",
															"    }\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "basic",
													"basic": [
														{
															"key": "password",
															"value": "{{password}}",
															"type": "string"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=Id eq {{OrderId}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Id eq {{OrderId}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Order Notification (Product Staging)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"console.log(access_token)\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "{{subscription_auth_token}}",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"OrderId\": \"{{OrderId}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\" \r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order EvictionDate Query (Product Staging)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){ \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var date = pm.globals.get(\"OrderEvictionDate\");\r",
															"    var prop_name = \"EvictionDate\";\r",
															"    pm.test(\"EvictionDate: \" + date, function(){\r",
															"        for (let item of jsonDataElements) {\r",
															"           pm.expect(Date.parse(item[prop_name])).to.be.gte(Date.parse(date));\r",
															"        }\r",
															"    });  \r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=EvictionDate ge {{OrderEvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate ge {{OrderEvictionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Order NotificationEndpoint Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"    current_order = jsonDataElements[0];\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of orders Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var endpoint = pm.iterationData.get(\"NotificationEndpoint\");\r",
															"    pm.test(\"NotificationEndpoint: \" + endpoint, function(){\r",
															"       pm.expect(current_order.NotificationEndpoint).to.eq(endpoint);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Check Product Staging Notification",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get Product Id from Server logs for Order",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"var notification = jsonDataElements.filter(m => m.request.body.data.includes(product_id));\r",
															"console.log(notification);\r",
															"\r",
															"pm.globals.set(\"NotificationProductId\",\"false\");\r",
															"if (notification && notification.length === 2) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification[1].request.body.data).to.be.includes(product_id);\r",
															"            console.log(\"Found product id: \" + product_id);\r",
															"        });\r",
															"        \r",
															"        pm.globals.set(\"NotificationProductId\",\"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Cancel Order by Id (Product Staging Notification)",
									"item": [
										{
											"name": "DD Order Cancel (staging notification)",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    // test status code\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,204]);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Orders({{OrderId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Orders({{OrderId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"  "
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }  ",
											"",
											"if(!pm.iterationData.get('NotificationEndpoint')){",
											"       postman.setNextRequest(null); ",
											"   }   ",
											"",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						}
					]
				},
				{
					"name": "DD Workflow and ProductionOrder (all cases)",
					"item": [
						{
							"name": "DD Workflow and ProductionOrder",
							"item": [
								{
									"name": "DD Workflow Query",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Listing Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test workflows Id: \" + randomItems[\"Id\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Id\"]);\r",
															"           pm.globals.set(\"WorkflowId\",randomItems[\"Id\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Name: \" + randomItems[\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Name\"])\r",
															"           pm.globals.set(\"WorkflowName\",randomItems[\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Description: \" + randomItems[\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Description\"])\r",
															"           pm.globals.set(\"WorkflowDescription\",randomItems[\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows InputProductType: \" + randomItems[\"InputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"InputProductType\"])\r",
															"           pm.globals.set(\"InputProductType\",randomItems[\"InputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows OutputProductType: \" + randomItems[\"OutputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"OutputProductType\"])\r",
															"           pm.globals.set(\"OutputProductType\",randomItems[\"OutputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows WorkflowVersion: \" + randomItems[\"WorkflowVersion\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowVersion\"])\r",
															"           pm.globals.set(\"WorkflowVersion\",randomItems[\"WorkflowVersion\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflow Options Name: \" + randomItems[\"WorkflowOptions\"][0][\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Description: \" + randomItems[\"WorkflowOptions\"][0][\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Description\",randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Type: \" + randomItems[\"WorkflowOptions\"][0][\"Type\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Type\",randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options value: \" + randomItems[\"WorkflowOptions\"][0][\"Value\"][0], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"           pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?expand=WorkflowOptions&$filter={{ProductTypeCodeForWorkflow}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "expand",
															"value": "WorkflowOptions"
														},
														{
															"key": "$filter",
															"value": "{{ProductTypeCodeForWorkflow}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Listing Query Copy",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test workflows Id: \" + randomItems[\"Id\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Id\"]);\r",
															"           pm.globals.set(\"WorkflowId\",randomItems[\"Id\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Name: \" + randomItems[\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Name\"])\r",
															"           pm.globals.set(\"WorkflowName\",randomItems[\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Description: \" + randomItems[\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Description\"])\r",
															"           pm.globals.set(\"WorkflowDescription\",randomItems[\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows InputProductType: \" + randomItems[\"InputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"InputProductType\"])\r",
															"           pm.globals.set(\"InputProductType\",randomItems[\"InputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows OutputProductType: \" + randomItems[\"OutputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"OutputProductType\"])\r",
															"           pm.globals.set(\"OutputProductType\",randomItems[\"OutputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows WorkflowVersion: \" + randomItems[\"WorkflowVersion\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowVersion\"])\r",
															"           pm.globals.set(\"WorkflowVersion\",randomItems[\"WorkflowVersion\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflow Options Name: \" + randomItems[\"WorkflowOptions\"][0][\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Description: \" + randomItems[\"WorkflowOptions\"][0][\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Description\",randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Type: \" + randomItems[\"WorkflowOptions\"][0][\"Type\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Type\",randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options value: \" + randomItems[\"WorkflowOptions\"][0][\"Value\"][0], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"           pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?expand=WorkflowOptions&$filter={{ProductTypeCodeForWorkflow}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "expand",
															"value": "WorkflowOptions"
														},
														{
															"key": "$filter",
															"value": "{{ProductTypeCodeForWorkflow}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Id Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowId\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=Id eq '{{WorkflowId}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "Id eq '{{WorkflowId}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Name Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowName\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=Name eq '{{WorkflowName}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "Name eq '{{WorkflowName}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Description Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowDescription\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=Description eq '{{WorkflowDescription}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "Description eq '{{WorkflowDescription}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow InputProductType Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"InputProductType\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=InputProductType eq '{{InputProductType}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "InputProductType eq '{{InputProductType}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow OutputProductType Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"OutputProductType\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=OutputProductType eq '{{OutputProductType}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "OutputProductType eq '{{OutputProductType}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Version Query",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        var property = pm.globals.get(\"WorkflowVersion\");\r",
															"        pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?filter=WorkflowVersion eq '{{WorkflowVersion}}'&expand=WorkflowOptions",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "filter",
															"value": "WorkflowVersion eq '{{WorkflowVersion}}'"
														},
														{
															"key": "expand",
															"value": "WorkflowOptions"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD ProductionOrder Submission (no notification)",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Query By Attributes (productType)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.globals.get(\"flag_productType\") == \"true\"){",
															"    try {",
															"        // test status code",
															"        pm.test(\"Test Response Status Code\", function(){",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);",
															"        }); ",
															"        ",
															"        var jsonDataElements = pm.response.json().value;",
															"        //MIN number of Records Test",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
															"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"        });",
															"        //extract prodiuct properties (product name, id, sensing date)",
															"        const sizeLimit = 150000000;",
															"        var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
															"        ",
															"        let i = 0;",
															"        console.log(jsonDataElements[i].ContentLength)",
															"        while(i < jsonDataElements.length){",
															"           if(jsonDataElements[i].ContentLength < sizeLimit){",
															"               randomItems = jsonDataElements[i];",
															"               ",
															"               console.log(randomItems)",
															"               break;",
															"           }",
															"           i++;",
															"           //console.log(i)",
															"        }",
															"      ",
															"        pm.globals.set(\"ProductName\", randomItems.Name);",
															"        pm.globals.set(\"ProductId\", randomItems.Id);",
															"        pm.globals.set(\"Start\", randomItems.ContentDate.Start);",
															"        pm.globals.set(\"End\", randomItems.ContentDate.End);",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}",
															"}",
															" "
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')&$orderby=PublicationDate desc",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')",
															"description": "Query by Attributes"
														},
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Request",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    //checki if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, randomItems);\r",
															"    }\r",
															"\r",
															"    pm.globals.set(\"ProductionOrdersId\",randomItems[\"Id\"]);\r",
															"    pm.globals.set(\"ProductionOrdersStatus\",randomItems[\"Status\"])\r",
															"    pm.globals.set(\"ProductionOrdersStatusMessage\",randomItems[\"StatusMessage\"])\r",
															"    pm.globals.set(\"ProductionOrdersSubmissionDate\",randomItems[\"SubmissionDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersEstimatedDate\",randomItems[\"EstimatedDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersPriority\",randomItems[\"Priority\"])\r",
															"    pm.globals.set(\"ProductName\",randomItems[\"InputProductReference\"][0][\"Reference\"])\r",
															"    pm.globals.set(\"Start\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"Start\"])\r",
															"    pm.globals.set(\"End\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"End\"])\r",
															"    pm.globals.set(\"WorkflowId\",randomItems[\"WorkflowId\"])\r",
															"    pm.globals.set(\"WorkflowName\",randomItems[\"WorkflowName\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0])\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"//pm.globals.unset(\"download_counter\");"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"InputProductReference\": {\r\n        \"Reference\": \"{{ProductName}}\",\r\n        \"ContentDate\": {\r\n            \"Start\": \"{{Start}}\",\r\n            \"End\": \"{{End}}\"\r\n        }\r\n    }, \r\n    \"Priority\": {{ProductionOrderPriority}},\r\n    \"WorkflowId\": \"{{WorkflowId}}\",\r\n    \"WorkflowName\": \"{{WorkflowName}}\",\r\n    \"WorkflowOptions\": [\r\n        {\r\n            \"Name\": \"{{WorkflowOptions_Name}}\",\r\n            \"Value\": \"{{WorkflowOptions_Value}}\"\r\n        }\r\n    ]\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder List",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By Id",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersId\");\r",
															"        //pm.expect(pm.response.text()).to.includes(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"    var production_order = jsonDataElements;\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, production_order);\r",
															"        pm.globals.set(\"ProductionOrder\" + key, production_order[key])\r",
															"    }\r",
															"    \r",
															"    if(production_order.Status == \"completed\"){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\", production_order.Id);\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\", production_order.CompletedDate);\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",production_order.EvictionDate);\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",production_order.OrderOutputSize);\r",
															"    }\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders('{{ProductionOrdersId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders('{{ProductionOrdersId}}')"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By Status",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															" \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersStatus\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Status eq '{{ProductionOrdersStatus}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq '{{ProductionOrdersStatus}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By StatusMessage",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersStatusMessage\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Status eq '{{ProductionOrdersStatusMessage}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq '{{ProductionOrdersStatusMessage}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By SubmissionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersSubmissionDate\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=SubmissionDate eq {{ProductionOrdersSubmissionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "SubmissionDate eq {{ProductionOrdersSubmissionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By EstimatedDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersEstimatedDate\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=EstimatedDate eq {{ProductionOrdersEstimatedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EstimatedDate eq {{ProductionOrdersEstimatedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By Priority",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersPriority\");\r",
															"        //pm.expect(pm.response.text()).to.include(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Priority eq {{ProductionOrdersPriority}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Priority eq {{ProductionOrdersPriority}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By InputProductReference (Name)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=InputProductReference/any(att:att/Reference eq '{{ProductName}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "InputProductReference/any(att:att/Reference eq '{{ProductName}}')"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By InputProductReference (ContentDate)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=InputProductReference/any(att:att/ContentDate gt {{Start}})",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "InputProductReference/any(att:att/ContentDate gt {{Start}})"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By WorkflowId",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=WorkflowId eq '{{WorkflowId}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "WorkflowId eq '{{WorkflowId}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By WorkflowName",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=WorkflowName eq '{{WorkflowName}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "WorkflowName eq '{{WorkflowName}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By WorkflowOptions",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															" try {",
															"    ",
															"    //check if the response code is 200",
															"    pm.test(\"Test Response Status Code\", function(){",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);",
															"    });",
															"    ",
															"    var jsonDataElements = pm.response.json().value;",
															"",
															"    //MIN number of Records Test",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"    pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"    });",
															"",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=WorkflowOptions/any(att:att/Name eq '{{WorkflowOptions_Name}}' and att/OData.CSC.StringAttribute/Value eq '{{WorkflowOptions_Value}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "WorkflowOptions/any(att:att/Name eq '{{WorkflowOptions_Name}}' and att/OData.CSC.StringAttribute/Value eq '{{WorkflowOptions_Value}}')",
															"description": "Query by Attributes"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Retrieve Completed ProductionOrder",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By Id",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersId\");\r",
															"        //pm.expect(pm.response.text()).to.includes(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var production_order = jsonDataElements;\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, production_order);\r",
															"        pm.globals.set(\"ProductionOrder\" + key, production_order[key])\r",
															"    }\r",
															"    \r",
															"    if(production_order.Status == \"completed\"){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\", production_order.Id);\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\", production_order.CompletedDate);\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",production_order.EvictionDate);\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",production_order.OrderOutputSize);\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders('{{ProductionOrdersId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders('{{ProductionOrdersId}}')"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD ProductionOrder Retrieval Request for Download Product",
									"item": [
										{
											"name": "DD ProductionOrder Retrieval Request By CompletedDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"          pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=CompletedDate eq {{ProductionOrdersCompletedDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "CompletedDate eq {{ProductionOrdersCompletedDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By Completed Status",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test odata products context\", function (){\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"CompletedDate\"])\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"EvictionDate\"])\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"Id\"])\r",
															"        pm.expect(pm.response.text()).to.include(randomItems[\"OrderOutputSize\"])\r",
															"    });\r",
															"    \r",
															"    \r",
															"    const object = jsonDataElements.find(m => m.Id === pm.globals.get(\"ProductionOrdersId\"))\r",
															"    if(object){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\",object[\"Id\"])\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\",object[\"CompletedDate\"])\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",object[\"EvictionDate\"])\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",object[\"OrderOutputSize\"])\r",
															"    }\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=Status eq OData.CSC.JobStatus'completed'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Status eq OData.CSC.JobStatus'completed'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By OrderOutputSize",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=OrderOutputSize eq '{{ProductionOrdersOrderOutputSize}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "OrderOutputSize eq '{{ProductionOrdersOrderOutputSize}}'"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By EvictionDate",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=EvictionDate eq {{ProductionOrdersEvictionDate}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "EvictionDate eq {{ProductionOrdersEvictionDate}}"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Triggered Download",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"\r",
															"    console.log(pm.response);\r",
															"\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,206,202]);\r",
															"    });\r",
															"\r",
															"    pm.test(\"Downloaded Size\", function(){\r",
															"        pm.expect(pm.response.responseSize).be.equal(1024);\r",
															"    });\r",
															"\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"try {\r",
															"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
															"} catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{CompletedProductionOrdersId}})/Product/$value",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{CompletedProductionOrdersId}})",
														"Product",
														"$value"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Product Details",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{CompletedProductionOrdersId}})/Product",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{CompletedProductionOrdersId}})",
														"Product"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Remove ProductionOrder",
									"item": [
										{
											"name": "DD ProductionOrder Cancel",
											"event": [
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,201,202]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{ProductionOrdersId}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{ProductionOrdersId}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }   "
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						},
						{
							"name": "DD Workflow and ProductionOrder (with notification)",
							"item": [
								{
									"name": "DD Workflow Query (with notification)",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Workflow Listing Query (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    \r",
															"    //check if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"    \r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"     \r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"    pm.test(\"Test workflows Id: \" + randomItems[\"Id\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Id\"]);\r",
															"           pm.globals.set(\"WorkflowId\",randomItems[\"Id\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Name: \" + randomItems[\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Name\"])\r",
															"           pm.globals.set(\"WorkflowName\",randomItems[\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Description: \" + randomItems[\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"Description\"])\r",
															"           pm.globals.set(\"WorkflowDescription\",randomItems[\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows InputProductType: \" + randomItems[\"InputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"InputProductType\"])\r",
															"           pm.globals.set(\"InputProductType\",randomItems[\"InputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows OutputProductType: \" + randomItems[\"OutputProductType\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"OutputProductType\"])\r",
															"           pm.globals.set(\"OutputProductType\",randomItems[\"OutputProductType\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows WorkflowVersion: \" + randomItems[\"WorkflowVersion\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowVersion\"])\r",
															"           pm.globals.set(\"WorkflowVersion\",randomItems[\"WorkflowVersion\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflow Options Name: \" + randomItems[\"WorkflowOptions\"][0][\"Name\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Description: \" + randomItems[\"WorkflowOptions\"][0][\"Description\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Description\",randomItems[\"WorkflowOptions\"][0][\"Description\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options Type: \" + randomItems[\"WorkflowOptions\"][0][\"Type\"], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"           pm.globals.set(\"WorkflowOptions_Type\",randomItems[\"WorkflowOptions\"][0][\"Type\"])\r",
															"    });\r",
															"\r",
															"    pm.test(\"Test workflows Options value: \" + randomItems[\"WorkflowOptions\"][0][\"Value\"][0], function (){\r",
															"           pm.expect(pm.response.text()).to.include(randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"           pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0]);\r",
															"    });\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"Workflow Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Workflows?expand=WorkflowOptions&$filter={{ProductTypeCodeForWorkflow}}",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Workflows"
													],
													"query": [
														{
															"key": "expand",
															"value": "WorkflowOptions"
														},
														{
															"key": "$filter",
															"value": "{{ProductTypeCodeForWorkflow}}"
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD ProductionOrder Submission (with notification)",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Product Query By Attributes (productType - with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.globals.get(\"flag_productType\") == \"true\"){",
															"    try {",
															"       // test status code",
															"        pm.test(\"Test Response Status Code\", function(){",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);",
															"        });",
															"        ",
															"        var jsonDataElements = pm.response.json().value;",
															"        //MIN number of Records Test",
															"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
															"        pm.test(\"Test Attribute Query returns at least the expected minimum number of products: \" + minimumExpRecords, function(){",
															"           pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
															"        });",
															"        //extract prodiuct properties (product name, id, sensing date)",
															"        const sizeLimit = 150000000;",
															"        var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];",
															"      ",
															"        let i = 0;",
															"        console.log(jsonDataElements[i].ContentLength)",
															"        while(i < jsonDataElements.length){",
															"           if(jsonDataElements[i].ContentLength < sizeLimit){",
															"               randomItems = jsonDataElements[i];",
															"               ",
															"               console.log(randomItems)",
															"               break;",
															"           }",
															"           i++;",
															"           //console.log(i)",
															"        }",
															"      ",
															"        pm.globals.set(\"ProductName\", randomItems.Name);",
															"        pm.globals.set(\"ProductId\", randomItems.Id);",
															"        pm.globals.set(\"Start\", randomItems.ContentDate.Start);",
															"        pm.globals.set(\"End\", randomItems.ContentDate.End);",
															"}",
															"",
															"catch (err) {",
															"    pm.test(request.name, function () {",
															"        pm.expect.fail(err.toString());",
															"    });",
															"}",
															"}",
															" "
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/Products?$filter=Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')&$orderby=PublicationDate desc",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"Products"
													],
													"query": [
														{
															"key": "$filter",
															"value": "Attributes/OData.CSC.StringAttribute/any(att:att/Name eq 'productType' and att/OData.CSC.StringAttribute/Value eq '{{InputProductType}}')",
															"description": "Query by Attributes"
														},
														{
															"key": "$orderby",
															"value": "PublicationDate desc"
														}
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Request (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"properties_map.NotificationEndpoint = function (element) {\r",
															"    pm.expect(element.NotificationEndpoint).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"\r",
															"try {\r",
															"    \r",
															"    //checki if the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([201,202]);\r",
															"    });\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															" \r",
															"    // Test that the correct properties are returned\r",
															"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];\r",
															"\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, randomItems);\r",
															"    }\r",
															"\r",
															"    pm.globals.set(\"ProductionOrdersId_withNotification\",randomItems[\"Id\"]);\r",
															"    pm.globals.set(\"ProductionOrdersStatus\",randomItems[\"Status\"])\r",
															"    pm.globals.set(\"ProductionOrdersStatusMessage\",randomItems[\"StatusMessage\"])\r",
															"    pm.globals.set(\"ProductionOrdersSubmissionDate\",randomItems[\"SubmissionDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersEstimatedDate\",randomItems[\"EstimatedDate\"])\r",
															"    pm.globals.set(\"ProductionOrdersPriority\",randomItems[\"Priority\"])\r",
															"    pm.globals.set(\"ProductName\",randomItems[\"InputProductReference\"][0][\"Reference\"])\r",
															"    pm.globals.set(\"Start\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"Start\"])\r",
															"    pm.globals.set(\"End\",randomItems[\"InputProductReference\"][0][\"ContentDate\"][0][\"End\"])\r",
															"    pm.globals.set(\"WorkflowId\",randomItems[\"WorkflowId\"])\r",
															"    pm.globals.set(\"WorkflowName\",randomItems[\"WorkflowName\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Name\",randomItems[\"WorkflowOptions\"][0][\"Name\"])\r",
															"    pm.globals.set(\"WorkflowOptions_Value\",randomItems[\"WorkflowOptions\"][0][\"Value\"][0])\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"InputProductReference\": {\r\n        \"Reference\": \"{{ProductName}}\",\r\n        \"ContentDate\": {\r\n            \"Start\": \"{{Start}}\",\r\n            \"End\": \"{{End}}\"\r\n        }\r\n    }, \r\n    \"Priority\": {{ProductionOrderPriority}},\r\n    \"WorkflowId\": \"{{WorkflowId}}\",\r\n    \"WorkflowName\": \"{{WorkflowName}}\",\r\n    \"WorkflowOptions\": [\r\n        {\r\n            \"Name\": \"{{WorkflowOptions_Name}}\",\r\n            \"Value\": \"{{WorkflowOptions_Value}}\"\r\n        }\r\n    ],\r\n    \"NotificationEndpoint\": \"{{NotificationEndpoint}}\",\r\n    \"NotificationEpUsername\": \"{{NotificationEpUsername}}\",\r\n    \"NotificationEpPassword\": \"{{NotificationEpPassword}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder/OData.CSC.Order",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder",
														"OData.CSC.Order"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Retrieve Completed ProductionOrder (with notification)",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By Id (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"properties_map = {};\r",
															"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"properties_map.Status = function (element) {\r",
															"    pm.expect(element.Status).to.be.a(\"string\");\r",
															"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
															"};\r",
															"properties_map.StatusMessage=function (element) {\r",
															"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
															"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
															"properties_map.InputProductReference = function (element) {\r",
															"    pm.expect(element.InputProductReference.Reference).to.be.a(\"string\");\r",
															"    pm.expect(element.InputProductReference.ContentDate.Start).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"    pm.expect(element.InputProductReference.ContentDate.End).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);\r",
															"};\r",
															"properties_map.WorkflowId = function (element) { pm.expect(element.WorkflowId).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
															"\r",
															"properties_map.WorkflowName = function (element) {\r",
															"    pm.expect(element.WorkflowName).to.be.a(\"string\");\r",
															"};\r",
															"properties_map.WorkflowOptions = function (element) {\r",
															"    pm.expect(element.WorkflowOptions[0].Name).to.be.a(\"string\");\r",
															"    pm.expect(element.WorkflowOptions[0].Value).to.be.a(\"string\");\r",
															"};\r",
															"\r",
															"function propertySpecific(key, order){\r",
															"    if (properties_map[key]) {\r",
															"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
															"            properties_map[key](order);\r",
															"            pm.expect(pm.response.text()).to.include(key);});\r",
															"    }\r",
															"    else {\r",
															"        console.warn(\"Test Property \"+key+\" is skipped for ProductionOrder: \" + order[key]);\r",
															"    }\r",
															"};\r",
															"try {\r",
															"\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"    var jsonDataElements = pm.response.json().value;\r",
															"\r",
															"    //MIN number of Records Test\r",
															"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
															"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function(){\r",
															"        //var property = pm.globals.get(\"ProductionOrdersId\");\r",
															"        //pm.expect(pm.response.text()).to.includes(property); \r",
															"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
															"    });\r",
															"    \r",
															"    var production_order = jsonDataElements;\r",
															"    for (const[key, value] of Object.entries(properties_map)){\r",
															"        propertySpecific(key, production_order);\r",
															"        pm.globals.set(\"ProductionOrder\" + key, production_order[key])\r",
															"    }\r",
															"    \r",
															"    if(production_order.Status == \"completed\"){\r",
															"        pm.globals.set(\"CompletedProductionOrdersId\", production_order.Id);\r",
															"        pm.globals.set(\"ProductionOrdersCompletedDate\", production_order.CompletedDate);\r",
															"        pm.globals.set(\"ProductionOrdersEvictionDate\",production_order.EvictionDate);\r",
															"        pm.globals.set(\"ProductionOrdersOrderOutputSize\",production_order.OrderOutputSize);\r",
															"    }\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders('{{ProductionOrdersId}}')",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders('{{ProductionOrdersId}}')"
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD ProductionOrder Retrieval Request for Download Product (with notification)",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Output Product Notification",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"// Define token access\r",
															"let access_token = pm.iterationData.get(\"subscription_auth_token\");\r",
															"console.log(access_token)\r",
															"let auth_string\r",
															"if(access_token){\r",
															"   console.log('Use Token Authentication for notification');\r",
															"   auth_string = \"Bearer \" + pm.iterationData.get(\"subscription_auth_token\");\r",
															"}else{\r",
															"   console.log('Not use Token Authentication for notification');\r",
															"   let username = pm.iterationData.get(\"NotificationEpUsername\");\r",
															"   let password = pm.iterationData.get(\"NotificationEpPassword\");\r",
															"   if(username){\r",
															"      console.log('Use username and password for notification');\r",
															"      var decoded_string = username + \":\" + password;\r",
															"      // Encode the String\r",
															"      var encoded_string = btoa(decoded_string);\r",
															"      auth_string = \"Basic \" + encoded_string;\r",
															"   }\r",
															"   \r",
															"}\r",
															"\r",
															"// added header\r",
															"pm.request.headers.upsert({\r",
															" 'key': \"Authorization\",\r",
															" 'value': auth_string\r",
															" });"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [],
												"body": {
													"mode": "raw",
													"raw": "{\r\n    \"@odata.context\": \"$metadata#Notification/$entity\",\r\n    \"ProductId\": \"{{ProductId}}\",\r\n    \"ProductName\": \"{{ProductName}}\",\r\n    \"ProductionOrderId\": \"{{ProductionOrdersId_withNotification}}\",\r\n    \"NotificationDate\": \"{{NotificationDate}}\"\r\n}",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{NotificationEndpoint}}",
													"host": [
														"{{NotificationEndpoint}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD ProductionOrder Retrieval Request By NotificationEndpoint",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    //checki f the response code is 200\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"    });\r",
															"\r",
															"}\r",
															"\r",
															"catch (err) {\r",
															"    pm.test(\"ProductionOrder Test\", function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrders?$filter=NotificationEndpoint eq '{{NotificationEndpoint}}'",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrders"
													],
													"query": [
														{
															"key": "$filter",
															"value": "NotificationEndpoint eq '{{NotificationEndpoint}}'"
														}
													]
												}
											},
											"response": []
										}
									],
									"event": [
										{
											"listen": "prerequest",
											"script": {
												"type": "text/javascript",
												"exec": [
													"function addZero(x, n) {",
													"  while (x.toString().length < n) {",
													"    x = \"0\" + x;",
													"  }",
													"  return x;",
													"}",
													"",
													"function GetCurrentDate() {",
													"    // Online Javascript Editor for free",
													"    // Write, Edit and Run your Javascript code using JS Online Compiler",
													"    var today = new Date();",
													"    var dd = String(today.getDate()).padStart(2, '0');",
													"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
													"    var yyyy = today.getFullYear();",
													"    var h = addZero(today.getHours(), 2);",
													"    var m = addZero(today.getMinutes(), 2);",
													"    var s = addZero(today.getSeconds(), 2);",
													"    var ms = addZero(today.getMilliseconds(), 6);",
													"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
													"    ",
													"    today = yyyy + '-' + mm + '-' + dd + 'T' + m + ':' + s + ':00.000Z';",
													"    //console.log(today)",
													"    return today;   // The function returns the product of p1 and p2",
													"}",
													"",
													"",
													"var date = GetCurrentDate()",
													"console.log(\"Notification Date is: \" + date);",
													"pm.globals.set(\"NotificationDate\", date);"
												]
											}
										},
										{
											"listen": "test",
											"script": {
												"type": "text/javascript",
												"exec": [
													""
												]
											}
										}
									]
								},
								{
									"name": "DD Check ProductionOrder Notification",
									"item": [
										{
											"name": "DD Get Token",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const jsonData = pm.response.json();\r",
															"    const access_token = jsonData.access_token;\r",
															"    pm.test(\"A token is returned\", function() {\r",
															"    pm.expect(pm.response.text()).to.include('access_token');\r",
															"   });\r",
															"   pm.globals.set(\"access_token\", access_token);\r",
															"}else{\r",
															"    console.log('Skip token verification');\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												},
												{
													"listen": "prerequest",
													"script": {
														"exec": [
															"if(pm.environment.get('auth_type') != 'basic'){\r",
															"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
															"    \r",
															"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"username\");\r",
															"        pm.request.body.urlencoded.remove(\"password\"); \r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"\r",
															"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"scope\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
															"    }\r",
															"    \r",
															"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
															"        pm.request.body.urlencoded.remove(\"client_id\");\r",
															"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
															"    }\r",
															"\r",
															"    pm.request.headers.upsert({\r",
															"        'key': \"Authorization\",\r",
															"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
															"    });\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "noauth"
												},
												"method": "POST",
												"header": [
													{
														"key": "Authorization",
														"value": "Basic {{encoded_credential}}"
													},
													{
														"key": "Content-Type",
														"value": "application/x-www-form-urlencoded"
													}
												],
												"body": {
													"mode": "urlencoded",
													"urlencoded": [
														{
															"key": "grant_type",
															"value": "{{grant_type}}",
															"type": "text"
														},
														{
															"key": "username",
															"value": "{{username}}",
															"type": "text"
														},
														{
															"key": "password",
															"value": "{{password}}",
															"type": "text"
														},
														{
															"key": "scope",
															"value": "{{scope}}",
															"type": "text"
														},
														{
															"key": "client_id",
															"value": "{{client_id}}",
															"type": "default"
														},
														{
															"key": "client_secret",
															"value": "{{client_secret}}",
															"type": "default"
														}
													]
												},
												"url": {
													"raw": "{{access_token_url}}",
													"host": [
														"{{access_token_url}}"
													]
												}
											},
											"response": []
										},
										{
											"name": "DD Get ProductId Id from Server logs for ProductionOrder",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"var jsonDataElements = pm.response.json()[\"call-logs\"];\r",
															"var product_id = pm.globals.get(\"ProductId\");\r",
															"var notification = jsonDataElements.find(m => m.request.body.data.includes(product_id));\r",
															"pm.globals.set(\"NotificationProductId\", \"false\");\r",
															"console.log(notification);\r",
															"if (notification) {\r",
															"    try {\r",
															"        // test status code\r",
															"        pm.test(\"Test Response Status Code\", function () {\r",
															"            pm.expect(pm.response.code).to.be.oneOf([200]);\r",
															"        });\r",
															"\r",
															"        pm.test(\"Test Product id: \" + product_id, function () {\r",
															"            pm.expect(notification.request.body.data).to.be.includes(product_id);\r",
															"            console.log(\"Found Product id: \" + product_id);\r",
															"        });\r",
															"        pm.globals.set(\"NotificationProductId\", \"true\");\r",
															"\r",
															"    } catch (err) {\r",
															"        pm.test(request.name, function () {\r",
															"            pm.expect.fail(err.toString());\r",
															"        });\r",
															"    }\r",
															"}\r",
															""
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"auth": {
													"type": "apikey",
													"apikey": [
														{
															"key": "value",
															"value": "{{api_key}}",
															"type": "string"
														},
														{
															"key": "key",
															"value": "X-API-Key",
															"type": "string"
														},
														{
															"key": "in",
															"value": "header",
															"type": "string"
														}
													]
												},
												"method": "GET",
												"header": [],
												"url": {
													"raw": "{{ServerLogsUrl}}",
													"host": [
														"{{ServerLogsUrl}}"
													],
													"query": [
														{
															"key": "count",
															"value": "1",
															"disabled": true
														},
														{
															"key": "path",
															"value": "/login",
															"disabled": true
														}
													]
												}
											},
											"response": []
										}
									]
								},
								{
									"name": "DD Remove ProductionOrder (with notification)",
									"item": [
										{
											"name": "DD ProductionOrder Cancel (with notification)",
											"event": [
												{
													"listen": "test",
													"script": {
														"exec": [
															"try {\r",
															"    pm.test(\"Test Response Status Code\", function(){\r",
															"        pm.expect(pm.response.code).to.be.oneOf([200,201,202]);\r",
															"    });\r",
															"\r",
															"}\r",
															"catch (err) {\r",
															"    pm.test(request.name, function () {\r",
															"        pm.expect.fail(err.toString());\r",
															"    });\r",
															"}"
														],
														"type": "text/javascript"
													}
												}
											],
											"request": {
												"method": "POST",
												"header": [
													{
														"key": "Content-Type",
														"value": "application/json",
														"type": "text"
													}
												],
												"body": {
													"mode": "raw",
													"raw": "",
													"options": {
														"raw": {
															"language": "json"
														}
													}
												},
												"url": {
													"raw": "{{service-root-uri}}/odata/v1/ProductionOrder({{ProductionOrdersId_withNotification}})/OData.CSC.Cancel",
													"host": [
														"{{service-root-uri}}"
													],
													"path": [
														"odata",
														"v1",
														"ProductionOrder({{ProductionOrdersId_withNotification}})",
														"OData.CSC.Cancel"
													]
												}
											},
											"response": []
										}
									]
								}
							],
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"function addZero(x, n) {",
											"  while (x.toString().length < n) {",
											"    x = \"0\" + x;",
											"  }",
											"  return x;",
											"}",
											"",
											"function GetCurrentDate() {",
											"    // Online Javascript Editor for free",
											"    // Write, Edit and Run your Javascript code using JS Online Compiler",
											"    var today = new Date();",
											"    var dd = String(today.getDate()).padStart(2, '0');",
											"    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!",
											"    var yyyy = today.getFullYear();",
											"    var h = addZero(today.getHours(), 2);",
											"    var m = addZero(today.getMinutes(), 2);",
											"    var s = addZero(today.getSeconds(), 2);",
											"    var ms = addZero(today.getMilliseconds(), 6);",
											"    //var time = h + \":\" + m + \":\" + s + \".\" + ms;",
											"    ",
											"    today = yyyy + '-' + mm + '-' + dd + 'T' + m + ':' + s + ':00.000Z';",
											"    //console.log(today)",
											"    return today;   // The function returns the product of p1 and p2",
											"}",
											"",
											"",
											"var date = GetCurrentDate()",
											"console.log(\"Notification Date is: \" + date);",
											"pm.globals.set(\"NotificationDate\", date);",
											"",
											"if(pm.environment.get('execute_admin_requests') == \"true\"){",
											"       console.warn(\"Unable to send request as administrator!\");",
											"       postman.setNextRequest(null); ",
											"   }   ",
											"",
											"if(!pm.iterationData.get('NotificationEndpoint')){",
											"       postman.setNextRequest(null); ",
											"   }   ",
											""
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											""
										]
									}
								}
							]
						}
					]
				}
			],
			"description": "The purpose of \"**CSC_ESA_Data_Distribution_ICD_v1.2_20210115\"** is to specify an https RESTful Application Programming Interface (API) of the Data Distribution element through which Copernicus Sentinel data products may be queried and downloaded by its users.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "CADIP Extended Compliance",
			"item": [
				{
					"name": "CADIP Query Sessions",
					"item": [
						{
							"name": "CADIP Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){  \r",
											"    //pm.request.body.urlencoded.remove(\"scope\"); \r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Satellite",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function() {",
											"        console.log(\"Found elements: \" + jsonDataElements.length);",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"    ",
											"    if(jsonDataElements.length<1){",
											"        postman.setNextRequest(null);",
											"    };",
											"",
											"    //select a random item and extract the session properties for the next subsequent tests",
											"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"    console.log(randomItems);",
											"    ",
											"    pm.test(\"Id : \" + randomItems[\"Id\"], function() {",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        pm.globals.set(\"Id\", randomItems[\"Id\"])",
											"    });",
											"",
											"    var sat_dir = pm.iterationData.get(\"Satellite\")",
											"    pm.test(\"SessionId : \" + randomItems[\"SessionId\"], function() {",
											"        pm.expect(randomItems[\"SessionId\"]).to.be.a(\"string\");",
											"        pm.expect(randomItems[\"SessionId\"]).to.include(sat_dir);",
											"        pm.globals.set(\"SessionId\", randomItems[\"SessionId\"])",
											"    });",
											"",
											"    // To be confirmed by the stations that this info is available at the beginning of the session (see CADIP ICD ver. 1.1, table 1)",
											"    if (randomItems[\"NumChannels\"]) {",
											"        pm.test(\"NumChannels : \" + randomItems[\"NumChannels\"], function() {",
											"            pm.expect(randomItems[\"NumChannels\"]).to.be.a(\"number\");",
											"            pm.globals.set(\"NumChannels\", randomItems[\"NumChannels\"])",
											"        });",
											"    }",
											"    pm.test(\"Publication date : \" + randomItems[\"PublicationDate\"], function() {",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"PublicationDate\", randomItems[\"PublicationDate\"])",
											"    });",
											"",
											"    pm.test(\"Satellite : \" + randomItems[\"Satellite\"], function() {",
											"        pm.expect(randomItems[\"Satellite\"]).to.be.a(\"string\");",
											"        pm.expect(randomItems[\"Satellite\"]).to.be.oneOf([\"S1A\", \"S1B\", \"S1C\", \"S1D\", \"S2A\", \"S2B\", \"S2C\", \"S2D\", \"S3A\", \"S3B\", \"S3C\", \"S3D\", \"S5P\", \"CO1\", \"CO2\", \"CO3\"]);",
											"        pm.expect(randomItems[\"Satellite\"]).to.eql(sat_dir);",
											"        pm.globals.set(\"Satellite\", randomItems[\"Satellite\"])",
											"    });",
											"",
											"    pm.test(\"StationUnitId : \" + randomItems[\"StationUnitId\"], function() {",
											"        pm.expect(randomItems[\"StationUnitId\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"StationUnitId\", randomItems[\"StationUnitId\"])",
											"    });",
											"",
											"    pm.test(\"DownlinkOrbit : \" + randomItems[\"DownlinkOrbit\"], function() {",
											"        pm.expect(randomItems[\"DownlinkOrbit\"]).to.be.a(\"number\");",
											"        pm.globals.set(\"DownlinkOrbit\", randomItems[\"DownlinkOrbit\"])",
											"    });",
											"",
											"    pm.test(\"AcquisitionId : \" + randomItems[\"AcquisitionId\"], function() {",
											"        pm.expect(randomItems[\"AcquisitionId\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"AcquisitionId\", randomItems[\"AcquisitionId\"])",
											"    });",
											"",
											"    pm.test(\"AntennaId : \" + randomItems[\"AntennaId\"], function() {",
											"        pm.expect(randomItems[\"AntennaId\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"AntennaId\", randomItems[\"AntennaId\"])",
											"    });",
											"",
											"    pm.test(\"FrontEndId : \" + randomItems[\"FrontEndId\"], function() {",
											"        pm.expect(randomItems[\"FrontEndId\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"FrontEndId\", randomItems[\"FrontEndId\"])",
											"    });",
											"",
											"    pm.test(\"Retransfer : \" + randomItems[\"Retransfer\"], function() {",
											"        pm.expect(randomItems[\"Retransfer\"]).to.be.a(\"boolean\");",
											"        pm.globals.set(\"Retransfer\", randomItems[\"Retransfer\"])",
											"    });",
											"",
											"    // verify if a session is completed",
											"    const bool = [true,false]",
											"    var downlink = randomItems[\"DownlinkStatusOK\"];",
											"    var delivery_push = randomItems[\"DeliveryPushOK\"];",
											"    // The session is completed when the fields DownlinkStatusOK and DeliveryPushOK are no more set to NULL",
											"    if (bool.includes(downlink) && bool.includes(delivery_push)) {",
											"        pm.test(\"AntennaStatusOK : \" + randomItems[\"AntennaStatusOK\"], function() {",
											"            pm.expect(randomItems[\"AntennaStatusOK\"]).to.be.a(\"boolean\");",
											"            pm.globals.set(\"AntennaStatusOK\", randomItems[\"AntennaStatusOK\"])",
											"        });",
											"",
											"        pm.test(\"FrontEndStatusOK : \" + randomItems[\"FrontEndStatusOK\"], function() {",
											"            pm.expect(randomItems[\"FrontEndStatusOK\"]).to.be.a(\"boolean\");",
											"            pm.globals.set(\"FrontEndStatusOK\", randomItems[\"FrontEndStatusOK\"])",
											"        });",
											"",
											"        pm.test(\"PlannedDataStart : \" + randomItems[\"PlannedDataStart\"], function() {",
											"            pm.expect(randomItems[\"PlannedDataStart\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.globals.set(\"PlannedDataStart\", randomItems[\"PlannedDataStart\"])",
											"        });",
											"",
											"        pm.test(\"PlannedDataStop : \" + randomItems[\"PlannedDataStop\"], function() {",
											"            pm.expect(randomItems[\"PlannedDataStop\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.globals.set(\"PlannedDataStop\", randomItems[\"PlannedDataStop\"])",
											"        });",
											"",
											"        pm.test(\"DownlinkStart : \" + randomItems[\"DownlinkStart\"], function() {",
											"            pm.expect(randomItems[\"DownlinkStart\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.globals.set(\"DownlinkStart\", randomItems[\"DownlinkStart\"])",
											"        });",
											"",
											"        pm.test(\"DownlinkStop : \" + randomItems[\"DownlinkStop\"], function() {",
											"            pm.expect(randomItems[\"DownlinkStop\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.globals.set(\"DownlinkStop\", randomItems[\"DownlinkStop\"])",
											"        });",
											"",
											"        pm.test(\"DownlinkStatusOK : \" + downlink, function() {",
											"            pm.expect(downlink).to.be.a(\"boolean\");",
											"            pm.globals.set(\"DownlinkStatusOK\", downlink)",
											"        });",
											"",
											"        pm.test(\"DeliveryPushOK : \" + delivery_push, function() {",
											"            pm.expect(delivery_push).to.be.a(\"boolean\");",
											"            pm.globals.set(\"DeliveryPushOK\", delivery_push)",
											"        });",
											"    }",
											"",
											"} catch (err) {",
											"    pm.test(\"Test Session Listing\", function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Satellite eq '{{Satellite}}'&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}'"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by SessionId",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    console.log(jsonDataElements);",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function() {",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        pm.expect(jsonDataElements.length).to.be.oneOf([1, 2]);",
											"        console.log(\"Found items: \" + jsonDataElements.length);",
											"    });",
											"",
											"    var session_id = pm.globals.get(\"SessionId\");",
											"    let id1_retrasfer = jsonDataElements[0][\"Retransfer\"];",
											"    let id1_antenna_status_ok = jsonDataElements[0][\"AntennaStatusOK\"];",
											"    let id1_frontend_status_ok = jsonDataElements[0][\"FrontEndStatusOK\"];",
											"    let id1_downlink_status_ok = jsonDataElements[0][\"DownlinkStatusOK\"];",
											"    let id1_delivery_push_ok = jsonDataElements[0][\"DeliveryPushOK\"];",
											"",
											"    // check session id for id #1",
											"    pm.test(\"SessionId for Id #1: \" + session_id, function() {",
											"        pm.expect(jsonDataElements[0].SessionId).to.eq(session_id);",
											"        console.log(\"SessionId: \" + jsonDataElements[0].SessionId);",
											"    });",
											"",
											"    // verify if only one id for a specific SessionId is generated",
											"    if (jsonDataElements.length == 1) {",
											"        // check use cases #1 or #4 ",
											"        if (id1_downlink_status_ok != null && id1_delivery_push_ok != null) {",
											"            if (id1_downlink_status_ok === false && id1_delivery_push_ok === false) {",
											"                // Use Case #4: No data received during the pass",
											"                pm.test(\"Retransfer for Id #1: \" + id1_retrasfer, function() {",
											"                    pm.expect(id1_retrasfer).to.be.eq(false);",
											"                });",
											"                pm.test(\"AntennaStatusOK for Id #1: \" + id1_antenna_status_ok, function() {",
											"                    pm.expect(id1_antenna_status_ok).to.be.eq(false);",
											"                });",
											"",
											"                pm.test(\"FrontEndStatusOK for Id #1: \" + id1_frontend_status_ok, function() {",
											"                    pm.expect(id1_frontend_status_ok).to.be.eq(false);",
											"                });",
											"            } else {",
											"                // Use Case #1: Nominal Case ",
											"                pm.test(\"Retransfer for Id #1: \" + jsonDataElements[0][\"Retransfer\"], function() {",
											"                    pm.expect(id1_retrasfer).to.be.eq(false);",
											"                });",
											"",
											"                pm.test(\"AntennaStatusOK for Id #1: \" + id1_antenna_status_ok, function() {",
											"                    pm.expect(id1_antenna_status_ok).to.be.oneOf([true, false]);",
											"                });",
											"",
											"                pm.test(\"FrontEndStatusOK for Id #1: \" + id1_frontend_status_ok, function() {",
											"                    pm.expect(id1_frontend_status_ok).to.be.oneOf([true, false]);",
											"                });",
											"",
											"                pm.test(\"DownlinkStatusOK for Id #1: \" + id1_downlink_status_ok, function() {",
											"                    pm.expect(id1_downlink_status_ok).to.be.eq(true);",
											"                });",
											"",
											"                pm.test(\"DeliveryPushOK for Id #1: \" + id1_delivery_push_ok, function() {",
											"                    pm.expect(id1_delivery_push_ok).to.be.eq(true);",
											"                });",
											"            }",
											"",
											"        }",
											"    // verify if two id for a specific SessionId are generated",
											"    } else if (jsonDataElements.length >= 2) {",
											"        let id2_retrasfer = jsonDataElements[1][\"Retransfer\"];",
											"        let id2_antenna_status_ok = jsonDataElements[1][\"AntennaStatusOK\"];",
											"        let id2_frontend_status_ok = jsonDataElements[1][\"FrontEndStatusOK\"];",
											"        let id2_downlink_status_ok = jsonDataElements[1][\"DownlinkStatusOK\"];",
											"        let id2_delivery_push_ok = jsonDataElements[1][\"DeliveryPushOK\"];",
											"        // check session id for second item (id #2)",
											"        pm.test(\"SessionId for Id #2: \" + session_id, function() {",
											"            pm.expect(jsonDataElements[1].SessionId).to.eq(session_id);",
											"            console.log(\"SessionId for Id #2: \" + jsonDataElements[1].SessionId);",
											"        });",
											"",
											"        // check use cases 2,3 and 5",
											"        if (id1_downlink_status_ok != null && id1_delivery_push_ok != null) {",
											"            // check use cases for id #1",
											"            pm.test(\"Retransfer for Id #1: \" + id1_retrasfer, function() {",
											"                pm.expect(id1_retrasfer).to.be.eq(false);",
											"            });",
											"",
											"            pm.test(\"AntennaStatusOK for Id #1: \" + id1_antenna_status_ok, function() {",
											"                pm.expect(id1_antenna_status_ok).to.be.oneOf([true, false]);",
											"            });",
											"",
											"            pm.test(\"FrontEndStatusOK for Id #1: \" + id1_frontend_status_ok, function() {",
											"                pm.expect(id1_frontend_status_ok).to.be.oneOf([true, false]);",
											"            });",
											"",
											"            pm.test(\"DownlinkStatusOK for Id #1: \" + jsonDataElements[0][\"DownlinkStatusOK\"], function() {",
											"                pm.expect(jsonDataElements[0][\"DownlinkStatusOK\"]).to.be.oneOf([true, false]);",
											"            });",
											"",
											"            if(id1_downlink_status_ok === false){",
											"                // Use Case #2",
											"                pm.test(\"DeliveryPushOK for Id #1: \" + id1_delivery_push_ok, function() {",
											"                   pm.expect(id1_delivery_push_ok).to.be.eq(true);",
											"                });",
											"            } else {",
											"                // Use Case #3 or #5",
											"                pm.test(\"DeliveryPushOK for Id #1: \" + id1_delivery_push_ok, function() {",
											"                   pm.expect(id1_delivery_push_ok).to.be.oneOf([true, false]);",
											"                });",
											"            }",
											"",
											"",
											"        }",
											"        if (id2_downlink_status_ok != null && id2_delivery_push_ok != null) {",
											"            // check use cases for id #2",
											"            pm.test(\"Retransfer for Id #2: \" + id2_retrasfer, function() {",
											"                pm.expect(id2_retrasfer).to.be.eq(true);",
											"            });",
											"",
											"            pm.test(\"AntennaStatusOK for Id #2: \" + id2_antenna_status_ok, function() {",
											"                pm.expect(id2_antenna_status_ok).to.be.oneOf([true, false]);",
											"            });",
											"",
											"            pm.test(\"FrontEndStatusOK for Id #2: \" + id2_frontend_status_ok, function() {",
											"                pm.expect(id2_frontend_status_ok).to.be.oneOf([true, false]);",
											"            });",
											"",
											"            pm.test(\"DownlinkStatusOK for Id #2: \" + id2_downlink_status_ok, function() {",
											"                pm.expect(id2_downlink_status_ok).to.be.oneOf([true, false]);",
											"            });",
											"",
											"            pm.test(\"DeliveryPushOK for Id #2: \" + id2_delivery_push_ok, function() {",
											"                pm.expect(id2_delivery_push_ok).to.be.eq(true);",
											"            });",
											"        }",
											"    }",
											"",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=SessionId eq '{{SessionId}}'",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "SessionId eq '{{SessionId}}'",
											"description": "Complex Property OriginDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Id",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json();",
											"",
											"    //test correct property is returned",
											"    var id = pm.globals.get(\"Id\");",
											"    pm.test(\"Id: \" + id, function(){",
											"        pm.expect(jsonDataElements.Id).to.eq(id);",
											"        //check the product status",
											"        console.log(\"Id: \" + jsonDataElements.Id);",
											"    });",
											"",
											"    /*if (!pm.globals.get(\"NumChannels\")) {",
											"        postman.setNExRequest(\"CADIP Query Sessions by Publication Date\");",
											"    };*/",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions({{Id}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions({{Id}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Publication Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" sessions found: \");",
											"    });",
											"    // test correct property is returned",
											"    var date = pm.globals.get(\"StartPublicationDate\");",
											"    pm.test(\"PublicationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"            pm.expect(Date.parse(item.PublicationDate)).to.be.above(Date.parse(date));",
											"            //console.log(\"PublicationDate: \" + item.PublicationDate);",
											"        }",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"date.setDate(date.getDate() + days);\r",
											"return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"const start_date = new Date(publication_date);\r",
											"const start_publication_date =  addDays(start_date, -5);\r",
											"pm.globals.set(\"StartPublicationDate\", start_publication_date);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=PublicationDate gt {{StartPublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate gt {{StartPublicationDate}}",
											"description": "Complex Property OriginDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Orbit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" sessions found: \");",
											"    });",
											"    // test correct property is returned",
											"    var orbit = pm.globals.get(\"DownlinkOrbit\");",
											"    pm.test(\"DownlinkOrbit: \" + orbit, function(){",
											"        for (let item of jsonDataElements) {",
											"            pm.expect(item.DownlinkOrbit).to.eq(orbit);",
											"            //console.log(\"DownlinkOrbit: \" + item.DownlinkOrbit);",
											"        }",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=DownlinkOrbit eq {{DownlinkOrbit}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "DownlinkOrbit eq {{DownlinkOrbit}}",
											"description": "Complex Property OriginDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Retransfer",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" sessions found: \");",
											"    });",
											"    // test correct property is returned",
											"    var retr = pm.globals.get(\"Retransfer\");",
											"    pm.test(\"Retransfer: \" + retr, function(){",
											"        for (let item of jsonDataElements) {        ",
											"           pm.expect(item.Retransfer).to.eq(retr);",
											"           //console.log(\"Retransfer: \" + item.Retransfer);",
											"        }",
											"    });",
											"    // stop test if the session is not completed",
											"    /*const bool = [true,false]",
											"    var downlink = pm.globals.get(\"DownlinkStatusOK\");",
											"    var delivery_push = pm.globals.get(\"DeliveryPushOK\");",
											"    // The session is completed when the fields DownlinkStatusOK and DeliveryPushOK are no more set to NULL",
											"    if (!bool.includes(downlink) && !bool.includes(delivery_push)) {",
											"        postman.setNextRequest(\"CADIP Query Sessions Additional Options (orderby asc)\");",
											"    };*/",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Retransfer eq {{Retransfer}}&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Retransfer eq {{Retransfer}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (orderby asc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$orderby={{PropertyAsc}} asc&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "{{PropertyAsc}} asc",
											"description": "ORDERBY"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (orderby desc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$orderby={{PropertyDesc}} desc&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}} desc",
											"description": "ORDERBY"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (top)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$top={{top}}&$filter=Satellite eq '{{Satellite}}'",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$top",
											"value": "{{top}}",
											"description": "Specify the maximum (non-negative integer) number of items returned"
										},
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}'"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (skip)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$skip={{skip}}&$filter=Satellite eq '{{Satellite}}'",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$skip",
											"value": "{{skip}}",
											"description": "Specify a (non-negative integer) number of items excluded from the start"
										},
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}'"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (count)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    // verify that the number of the matching resources is returned as result.",
											"    var data_counter = pm.response.json()[\"@odata.count\"];",
											"    pm.test(\"The number of the matching resources is returned: \" + data_counter, function(){",
											"        pm.expect(data_counter).to.be.a(\"number\");",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$count=true&$filter=Satellite eq '{{Satellite}}'&$top=100",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$count",
											"value": "true",
											"description": "Request a count of the matching resources"
										},
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}'"
										},
										{
											"key": "$top",
											"value": "100"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (Operators \"and\", \"in\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    //parse the response JSON\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"\r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operators AND and IN return at least the expected minimum number of sessions: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"//return orbit numbers\r",
											"var orbit = pm.globals.get('DownlinkOrbit')\r",
											"pm.globals.set('DownlinkOrbit1', parseInt(orbit + 1))\r",
											"pm.globals.set('DownlinkOrbit2', parseInt(orbit + 2))\r",
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Satellite eq '{{Satellite}}' and DownlinkOrbit in ({{DownlinkOrbit}}, {{DownlinkOrbit1}}, {{DownlinkOrbit2}})&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}' and DownlinkOrbit in ({{DownlinkOrbit}}, {{DownlinkOrbit1}}, {{DownlinkOrbit2}})"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (Operator \"or\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    //parse the response JSON\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator OR returns at least the expected minimum number of sessions: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"//return orbit numbers\r",
											"var orbit = pm.globals.get('DownlinkOrbit')\r",
											"pm.globals.set('DownlinkOrbit1', parseInt(orbit + 1))\r",
											"pm.globals.set('DownlinkOrbit2', parseInt(orbit + 2))\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Satellite eq '{{Satellite}}' or DownlinkOrbit in ({{DownlinkOrbit}}, {{DownlinkOrbit1}}, {{DownlinkOrbit2}})&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}' or DownlinkOrbit in ({{DownlinkOrbit}}, {{DownlinkOrbit1}}, {{DownlinkOrbit2}})"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions Additional Options (Operator \"not\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"    \r",
											"    //parse the response JSON\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator NOT returns at least the expected minimum number of sessions: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"var number = 1000;\r",
											"pm.globals.set(\"StringNameNot\",\"S\" + number);\r",
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Satellite eq '{{Satellite}}' and not startswith(SessionId,'{{StringNameNot}}')&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}' and not startswith(SessionId,'{{StringNameNot}}')"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "CADIP Query Files",
					"item": [
						{
							"name": "CADIP Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){  \r",
											"    //pm.request.body.urlencoded.remove(\"scope\"); \r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Satellite",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function() {",
											"        console.log(\"Found elements: \" + jsonDataElements.length);",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    if(jsonDataElements.length<1){",
											"        postman.setNextRequest(null);",
											"    };",
											"",
											"    var flag = false",
											"    //search a completed session",
											"    var elm = jsonDataElements.find(m => m.DeliveryPushOK === true && typeof m.DownlinkStatusOK === \"boolean\");",
											"    pm.globals.set(\"DownlinkStatusOK\", elm[\"DownlinkStatusOK\"]);",
											"    pm.globals.set(\"DeliveryPushOK\", elm[\"DeliveryPushOK\"]);",
											"",
											"    if (elm) {",
											"        pm.test(\"Id : \" + elm[\"Id\"], function() {",
											"            pm.expect(elm[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"            pm.globals.set(\"Id\", elm[\"Id\"]);",
											"        });",
											"",
											"        var sat_dir = pm.iterationData.get(\"Satellite\")",
											"        pm.test(\"SessionId : \" + elm[\"SessionId\"], function() {",
											"            pm.expect(elm[\"SessionId\"]).to.be.a(\"string\");",
											"            pm.expect(elm[\"SessionId\"]).to.include(sat_dir);",
											"            pm.globals.set(\"SessionId\", elm[\"SessionId\"]);",
											"        });",
											"        flag = true",
											"        pm.globals.set(\"FinalFlag\", true);",
											"    }",
											"    console.log(elm);",
											"    // stop test if the session is not completed",
											"    if (flag == false) {",
											"        pm.globals.set(\"FinalFlag\", false);",
											"        postman.setNextRequest(null);",
											"    };",
											"",
											"} catch (err) {",
											"    pm.test(\"Test Session Listing\", function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Satellite eq '{{Satellite}}'&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}'"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by SessionId",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function() {",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" products found: \");",
											"    });",
											"",
											"    // the test checks the properties of a random item if a completed session is not found.  ",
											"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];",
											"    var flag = false;",
											"    var downlink_status = pm.globals.get(\"DownlinkStatusOK\");",
											"    // check the BlockNumber is not zero and DownlinkStatusOK is true",
											"    for (const elm of jsonDataElements) {",
											"        if (elm.BlockNumber > 0 && downlink_status === true) {",
											"            randomItems = elm;",
											"            flag = true;",
											"            break;",
											"        }",
											"    }",
											"    // FinalFlag is saved in the globals file.",
											"    console.log(randomItems)",
											"    pm.globals.set(\"FinalFlag\", flag);",
											"    // check files properties for each channels",
											"    let num_channel = randomItems[\"Channel\"];",
											"    pm.test(\"Id for channel \" + num_channel + \": \" + randomItems[\"Id\"], function() {",
											"        pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"        pm.globals.set(\"Id\", randomItems[\"Id\"])",
											"    });",
											"",
											"    pm.test(\"Name for channel \" + num_channel + \": \" + randomItems[\"Name\"], function() {",
											"        pm.expect(randomItems[\"Name\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"Name\", randomItems[\"Name\"])",
											"    });",
											"",
											"    pm.test(\"SessionId for channel \" + num_channel + \": \" + randomItems[\"SessionId\"], function() {",
											"        pm.expect(randomItems[\"SessionId\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"SessionId\", randomItems[\"SessionId\"])",
											"    });",
											"",
											"    pm.test(\"Channel: \" + randomItems[\"Channel\"], function() {",
											"        pm.expect(randomItems[\"Channel\"]).to.be.a(\"number\");",
											"        pm.globals.set(\"Channel\", randomItems[\"Channel\"])",
											"    });",
											"",
											"    pm.test(\"BlockNumber for channel \" + num_channel + \": \" + randomItems[\"BlockNumber\"], function() {",
											"        pm.expect(randomItems[\"BlockNumber\"]).to.be.a(\"number\");",
											"        pm.globals.set(\"BlockNumber\", randomItems[\"BlockNumber\"])",
											"    });",
											"",
											"    pm.test(\"FinalBlock for channel \" + num_channel + \": \" + randomItems[\"FinalBlock\"], function() {",
											"        pm.expect(randomItems[\"FinalBlock\"]).to.be.a(\"boolean\");",
											"        pm.globals.set(\"FinalBlock\", randomItems[\"FinalBlock\"])",
											"    });",
											"",
											"    pm.test(\"Publication date for channel \" + num_channel + \": \" + randomItems[\"PublicationDate\"], function() {",
											"        pm.expect(randomItems[\"PublicationDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"        pm.globals.set(\"PublicationDate\", randomItems[\"PublicationDate\"])",
											"    });",
											"",
											"    if (randomItems[\"EvictionDate\"]) {",
											"        pm.test(\"EvictionDate date for channel \" + num_channel + \": \" + randomItems[\"EvictionDate\"], function() {",
											"            pm.expect(randomItems[\"EvictionDate\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.globals.set(\"EvictionDate\", randomItems[\"EvictionDate\"])",
											"        });",
											"    }",
											"",
											"    pm.test(\"Size for channel \" + num_channel + \": \" + randomItems[\"Size\"], function() {",
											"        pm.expect(randomItems[\"Size\"]).to.be.a(\"number\");",
											"        pm.globals.set(\"Size\", randomItems[\"Size\"])",
											"    });",
											"",
											"    pm.test(\"Retransfer for channel \" + num_channel + \": \" + randomItems[\"Retransfer\"], function() {",
											"        pm.expect(randomItems[\"Retransfer\"]).to.be.a(\"boolean\");",
											"        pm.globals.set(\"Retransfer\", randomItems[\"Retransfer\"])",
											"    });",
											"",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter=SessionId eq '{{SessionId}}'&$orderby={{PropertyDesc}}&$top=30",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "SessionId eq '{{SessionId}}'"
										},
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}}"
										},
										{
											"key": "$top",
											"value": "30"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by Id",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json(); ",
											"",
											"    pm.globals.set(\"filename\",jsonDataElements.Name);",
											"    var item = pm.globals.get(\"Id\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Id: \" + item, function(){",
											"           pm.expect(jsonDataElements.Id).to.eq(item);",
											"           console.log(\"Id: \" + jsonDataElements.Id); ",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files({{Id}})",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files({{Id}})"
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by Name (contains)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(\"Found: \" + jsonDataElements.length);",
											"    });",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const filename = pm.globals.get(\"Name\");\r",
											"const session_id = pm.globals.get(\"SessionId\");\r",
											"\r",
											"\r",
											"const contains_string = \"contains(Name,'_\" + session_id + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + filename.split('_')[0] + \"_\" + filename.split('_')[1] + \"_\" + filename.split('_')[2] + \"')\";\r",
											"\r",
											"var len_array = filename.split('.').length;\r",
											"const end_string = \"endswith(Name,'.\" + filename.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"//let StringObjects = [contains_string,start_string,end_string];\r",
											"//var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",contains_string);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter={{QueryByNameString}}&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by Name (startswith)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(\"Found: \" + jsonDataElements.length);",
											"    });",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const filename = pm.globals.get(\"Name\");\r",
											"const session_id = pm.globals.get(\"SessionId\");\r",
											"\r",
											"\r",
											"const contains_string = \"contains(Name,'_\" + session_id + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + filename.split('_')[0] + \"_\" + filename.split('_')[1] + \"_\" + filename.split('_')[2] + \"')\";\r",
											"\r",
											"var len_array = filename.split('.').length;\r",
											"const end_string = \"endswith(Name,'.\" + filename.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"//let StringObjects = [contains_string,start_string,end_string];\r",
											"//var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",start_string);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter={{QueryByNameString}}&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by Name (endswith)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(\"Found: \" + jsonDataElements.length);",
											"    });",
											"}",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const filename = pm.globals.get(\"Name\");\r",
											"const session_id = pm.globals.get(\"SessionId\");\r",
											"\r",
											"\r",
											"const contains_string = \"contains(Name,'_\" + session_id + \"_')\";\r",
											"const start_string = \"startswith(Name,'\" + filename.split('_')[0] + \"_\" + filename.split('_')[1] + \"_\" + filename.split('_')[2] + \"')\";\r",
											"\r",
											"var len_array = filename.split('.').length;\r",
											"const end_string = \"endswith(Name,'.\" + filename.split('.')[len_array-1] + \"')\";\r",
											"    \r",
											"//let StringObjects = [contains_string,start_string,end_string];\r",
											"//var itemStringObjects = StringObjects[Math.floor(Math.random()*StringObjects.length)];\r",
											"pm.globals.set(\"QueryByNameString\",end_string);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter={{QueryByNameString}}&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "{{QueryByNameString}}",
											"description": "Complex Property OriginDate"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by Publication Date",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" files found: \");",
											"    });",
											"    ",
											"    // test correct property is returned",
											"    var date = pm.globals.get(\"StartPublicationDate\");",
											"    pm.test(\"PublicationDate: \" + date, function(){",
											"        for (let item of jsonDataElements) {",
											"            pm.expect(Date.parse(item.PublicationDate)).to.be.above(Date.parse(date));",
											"            //console.log(\"PublicationDate: \" + item.PublicationDate);",
											"        }",
											"    });",
											"",
											"    if(!pm.globals.get(\"EvictionDate\")){",
											"        postman.setNExRequest(\"CADIP Query Files by Size\");",
											"    };",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"function addDays(date, days) {\r",
											"date.setDate(date.getDate() + days);\r",
											"return date;\r",
											"};\r",
											"\r",
											"const publication_date = pm.globals.get(\"PublicationDate\");\r",
											"const start_date = new Date(publication_date);\r",
											"const start_publication_date =  addDays(start_date, -5);\r",
											"pm.globals.set(\"StartPublicationDate\", start_publication_date);"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter=PublicationDate gt {{StartPublicationDate}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "PublicationDate gt {{StartPublicationDate}}",
											"description": "Complex Property OriginDate"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files by Retransfer",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"        console.log(jsonDataElements.length + \" files found: \");",
											"    });",
											"",
											"    var randomItems = jsonDataElements[Math.floor(Math.random()*jsonDataElements.length)];   ",
											"    var item = pm.globals.get(\"Retransfer\");",
											"    // test correct odata context is returned",
											"    pm.test(\"Retransfer: \" + item, function(){",
											"        for (let elm of jsonDataElements) {",
											"           pm.expect(elm.Retransfer).to.eq(item);",
											"           //console.log(\"Retransfer: \" + elm.Retransfer);",
											"        }",
											"    });",
											"",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter=Retransfer eq {{Retransfer}}&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Retransfer eq {{Retransfer}}"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (orderby asc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$orderby={{PropertyAsc}} asc&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "{{PropertyAsc}} asc",
											"description": "ORDERBY"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (orderby desc)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$orderby={{PropertyDesc}} desc&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$orderby",
											"value": "{{PropertyDesc}} desc",
											"description": "ORDERBY"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (top)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$top={{top}}&$filter=Channel eq {{Channel}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$top",
											"value": "{{top}}"
										},
										{
											"key": "$filter",
											"value": "Channel eq {{Channel}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (skip)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"            pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$skip={{skip}}&$filter=Channel eq {{Channel}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$skip",
											"value": "{{skip}}",
											"description": "Specify a (non-negative integer) number of items excluded from the start"
										},
										{
											"key": "$filter",
											"value": "Channel eq {{Channel}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (count)",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"    ",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"    ",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of files Test: \" + minimumExpRecords, function(){",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    // verify that the number of the matching resources is returned as result.",
											"    var data_counter = pm.response.json()[\"@odata.count\"];",
											"    pm.test(\"The number of the matching resources is returned: \" + data_counter, function(){",
											"        pm.expect(data_counter).to.be.a(\"number\");",
											"    });",
											"}",
											"",
											"catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$count=true&$top=100&$filter=Channel eq {{Channel}}",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$count",
											"value": "true",
											"description": "Request a count of the matching resources"
										},
										{
											"key": "$top",
											"value": "100"
										},
										{
											"key": "$filter",
											"value": "Channel eq {{Channel}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (Operators \"and\", \"in\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    //parse the response JSON\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											"\r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operators AND and IN return at least the expected minimum number of files: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"//return size\r",
											"var size = pm.globals.get('Size')\r",
											"pm.globals.set('Size2', parseInt(size + 100000))\r",
											"pm.globals.set('Size3', parseInt(size + 200000))\r",
											"pm.globals.set('Size4', parseInt(size + 300000))\r",
											"\r",
											"\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter=SessionId eq '{{SessionId}}' and Size in ({{Size}},{{Size2}},{{Size3}})&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "SessionId eq '{{SessionId}}' and Size in ({{Size}},{{Size2}},{{Size3}})"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (Operator \"or\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    //parse the response JSON\r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator OR returns at least the expected minimum number of files: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"var size = pm.globals.get('Size')\r",
											"pm.globals.set('Size2', parseInt(size + 100000))\r",
											"pm.globals.set('Size3', parseInt(size + 200000))\r",
											"pm.globals.set('Size4', parseInt(size + 300000))"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter=SessionId eq '{{SessionId}}' or Size in ({{Size}}, {{Size2}}, {{Size3}})&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "SessionId eq '{{SessionId}}' or Size in ({{Size}}, {{Size2}}, {{Size3}})"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Files Additional Options (Operator \"not\")",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {\r",
											"    // test status code\r",
											"    pm.test(\"Test Response Status Code\", function(){\r",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
											"    });\r",
											"\r",
											"    //parse the response JSON   \r",
											"    var jsonDataElements = pm.response.json().value;\r",
											" \r",
											"    //MIN number of Records Test\r",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
											"    pm.test(\"Test operator NOT returns at least the expected minimum number of files: \" + minimumExpRecords, function(){\r",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
											"    });\r",
											"        // FinalFlag is saved in globals file.\r",
											"    var flag = pm.globals.get(\"FinalFlag\");\r",
											"    // test is stopped if the flag is false.\r",
											"    if (flag === false) {\r",
											"        postman.setNextRequest(null);\r",
											"    };\r",
											"}\r",
											"\r",
											"catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"var number = pm.globals.get('Channel');\r",
											"pm.globals.set(\"StringNameNot\",\"ch\" + number);\r",
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files?$filter=SessionId eq '{{SessionId}}' and not contains(Name,'{{StringNameNot}}')&$top=1000",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files"
									],
									"query": [
										{
											"key": "$filter",
											"value": "SessionId eq '{{SessionId}}' and not contains(Name,'{{StringNameNot}}')"
										},
										{
											"key": "$top",
											"value": "1000"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP File Download Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    ",
											"    //console.log(pm.response);",
											"",
											"    pm.test(\"Test Response Status Code\", function(){",
											"        //pm.expect(pm.response.code).to.be.oneOf([200,202,206]);",
											"        pm.expect(pm.response.code).to.be.below(399);",
											"    });",
											"    ",
											"    pm.test(\"Downloaded Size\", function(){",
											"        pm.expect(pm.response.responseSize).be.equal(1024);",
											"    });",
											"",
											"} catch (err) {",
											"    pm.test(request.name, function () {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"try {\r",
											"    pm.request.headers.add({key: 'Range', value: 'bytes=0-1023' })\r",
											"} catch (err) {\r",
											"    pm.test(request.name, function () {\r",
											"        pm.expect.fail(err.toString());\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Files({{Id}})/$value",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Files({{Id}})",
										"$value"
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				},
				{
					"name": "CADIP QualityInfo",
					"item": [
						{
							"name": "CADIP Get Token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){\r",
											"    const jsonData = pm.response.json();\r",
											"    const access_token = jsonData.access_token;\r",
											"    pm.test(\"A token is returned\", function() {\r",
											"    pm.expect(pm.response.text()).to.include('access_token');\r",
											"   });\r",
											"   pm.globals.set(\"access_token\", access_token);\r",
											"}else{\r",
											"    console.log('Skip token verification');\r",
											"}\r",
											""
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"if(pm.environment.get('auth_type') != 'basic'){  \r",
											"    //pm.request.body.urlencoded.remove(\"scope\"); \r",
											"    pm.request.headers.upsert({\r",
											"        'key': \"Authorization\",\r",
											"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
											"    });\r",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Basic {{encoded_credential}}"
									},
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									}
								],
								"body": {
									"mode": "urlencoded",
									"urlencoded": [
										{
											"key": "grant_type",
											"value": "{{grant_type}}",
											"type": "text"
										},
										{
											"key": "username",
											"value": "{{username}}",
											"type": "text"
										},
										{
											"key": "password",
											"value": "{{password}}",
											"type": "text"
										},
										{
											"key": "scope",
											"value": "{{scope}}",
											"type": "text"
										},
										{
											"key": "client_id",
											"value": "{{client_id}}",
											"type": "default"
										},
										{
											"key": "client_secret",
											"value": "{{client_secret}}",
											"type": "default"
										}
									]
								},
								"url": {
									"raw": "{{access_token_url}}",
									"host": [
										"{{access_token_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Query Sessions by Satellite",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json().value;",
											"",
											"    //MIN number of Records Test",
											"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));",
											"    pm.test(\"Expected minimum number of sessions Test: \" + minimumExpRecords, function() {",
											"        console.log(\"Found elements: \" + jsonDataElements.length);",
											"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);",
											"    });",
											"",
											"    if(jsonDataElements.length<1){",
											"        postman.setNextRequest(null);",
											"    };",
											"",
											"    var sat_dir = pm.iterationData.get(\"Satellite\")",
											"    var flag = false",
											"    //select a item and extract the session properties for the next subsequent tests",
											"    var randomItems = jsonDataElements.find(m => typeof m.DeliveryPushOK === \"boolean\"  && typeof m.DownlinkStatusOK === \"boolean\");",
											"    // verify if a session is completed",
											"    console.log(randomItems)",
											"    var downlink = randomItems[\"DownlinkStatusOK\"];",
											"    var delivery_push = randomItems[\"DeliveryPushOK\"];",
											"    // The session is completed when the fields DownlinkStatusOK and DeliveryPushOK are no more set to NULL",
											"    if (jsonDataElements.length > 0 && Object.keys(randomItems) !== 0) {",
											"        flag = true",
											"        pm.test(\"Id : \" + randomItems[\"Id\"], function() {",
											"            pm.expect(randomItems[\"Id\"]).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/);",
											"            pm.globals.set(\"Id\", randomItems[\"Id\"])",
											"        });",
											"",
											"        pm.test(\"SessionId : \" + randomItems[\"SessionId\"], function() {",
											"            pm.expect(randomItems[\"SessionId\"]).to.be.a(\"string\");",
											"            pm.expect(randomItems[\"SessionId\"]).to.include(sat_dir);",
											"            pm.globals.set(\"SessionId\", randomItems[\"SessionId\"]);",
											"        });",
											"",
											"    }",
											"",
											"    // FinalFlag is saved in globals file.",
											"    pm.globals.set(\"FinalFlag\", flag);",
											"    // test is stopped if the flag is false.",
											"    if (flag === false) {",
											"        postman.setNextRequest(null);",
											"    };",
											"",
											"} catch (err) {",
											"    pm.test(\"Test Session Listing\", function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions?$filter=Satellite eq '{{Satellite}}' and DownlinkStatusOK eq true&$orderby=PublicationDate desc",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions"
									],
									"query": [
										{
											"key": "$filter",
											"value": "Satellite eq '{{Satellite}}' and DownlinkStatusOK eq true"
										},
										{
											"key": "$orderby",
											"value": "PublicationDate desc"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "CADIP Retrieve QualityInfo",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"",
											"    // test status code",
											"    pm.test(\"Test Response Status Code\", function() {",
											"        pm.expect(pm.response.code).to.be.oneOf([200]);",
											"    });",
											"",
											"    //parse the response JSON",
											"    var jsonDataElements = pm.response.json();",
											"    console.log(jsonDataElements);",
											"    // extract the Session properties for the next subsequent tests",
											"    pm.test(\"SessionId : \" + jsonDataElements[\"SessionId\"], function() {",
											"        pm.expect(jsonDataElements[\"SessionId\"]).to.be.a(\"string\");",
											"        pm.globals.set(\"SessionId\", jsonDataElements[\"SessionId\"])",
											"    });",
											"",
											"    //channel info",
											"    var num_ch = jsonDataElements[\"NumChannels\"];",
											"    pm.test(\"Number of channels\" , function() {",
											"        pm.expect(jsonDataElements[\"QualityInfo\"].length).to.eql(parseInt(num_ch));",
											"    });",
											"    // check qualityinfo",
											"    pm.test(\"QualityInfo\", function() {",
											"        //console.log(jsonDataElements[\"QualityInfo\"])",
											"        for (const elm of jsonDataElements[\"QualityInfo\"]) {",
											"            pm.expect(elm[\"Channel\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"AcquiredTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"ErrorTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"CorrectedTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"UncorrectableTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"DataTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"ErrorDataTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"CorrectedDataTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"UncorrectableDataTFs\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"DeliveryStart\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.expect(elm[\"DeliveryStop\"]).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/);",
											"            pm.expect(elm[\"TotalChunks\"]).to.be.a(\"number\");",
											"            pm.expect(elm[\"TotalVolume\"]).to.be.a(\"number\");",
											"        }",
											"    });",
											"",
											"} catch (err) {",
											"    pm.test(request.name, function() {",
											"        pm.expect.fail(err.toString());",
											"    });",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{service-root-uri}}/odata/v1/Sessions({{Id}})?$expand=QualityInfo",
									"host": [
										"{{service-root-uri}}"
									],
									"path": [
										"odata",
										"v1",
										"Sessions({{Id}})"
									],
									"query": [
										{
											"key": "$expand",
											"value": "QualityInfo"
										}
									]
								}
							},
							"response": []
						}
					],
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					]
				}
			],
			"description": "The purpose of \"**CADU Interface Delivery Point Specification_v1.2\"** is to specify https RESTful Application Programming Interfaces (APIs) through which CADU data may be discovered and downloaded by authorised users following the patterns and principles defined in the other CSC GS interface delivery points.",
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });"
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "LTA Create Order (Benchmarking)",
			"item": [
				{
					"name": "LTA Get Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if(pm.environment.get('auth_type') != 'basic'){\r",
									"    const jsonData = pm.response.json();\r",
									"    const access_token = jsonData.access_token;\r",
									"    pm.test(\"A token is returned\", function() {\r",
									"    pm.expect(pm.response.text()).to.include('access_token');\r",
									"   });\r",
									"   pm.globals.set(\"access_token\", access_token);\r",
									"}else{\r",
									"    console.log('Skip token verification');\r",
									"}\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"if(pm.environment.get('auth_type') != 'basic'){\r",
									"    const access_token_url = pm.environment.get(\"access_token_url\");\r",
									"    \r",
									"    if(access_token_url == \"https://s1a.prip.copernicus.eu/auth/realms/prip_s1a/protocol/openid-connect/token\"){\r",
									"        pm.request.body.urlencoded.remove(\"scope\");\r",
									"    }\r",
									"    \r",
									"    if(access_token_url == \"https://prip.s1b.dlr.copernicus.eu/proseo/prip/v1/token\"){\r",
									"        pm.request.body.urlencoded.remove(\"username\");\r",
									"        pm.request.body.urlencoded.remove(\"password\"); \r",
									"        pm.request.body.urlencoded.remove(\"client_id\");\r",
									"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
									"    }\r",
									"\r",
									"    if(access_token_url == \"https://S3A.prip.copernicus.eu/auth/realms/S3PS/protocol/openid-connect/token\"){\r",
									"        pm.request.body.urlencoded.remove(\"scope\");\r",
									"        pm.request.body.urlencoded.remove(\"client_secret\");        \r",
									"    }\r",
									"    \r",
									"    if(access_token_url == \"https://prip.s2a.atos.copernicus.eu/token\"){\r",
									"        pm.request.body.urlencoded.remove(\"client_id\");\r",
									"        pm.request.body.urlencoded.remove(\"client_secret\");    \r",
									"    }\r",
									"\r",
									"    pm.request.headers.upsert({\r",
									"        'key': \"Authorization\",\r",
									"        'value': \"Basic \" + pm.environment.get(\"encoded_credential\")\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Authorization",
								"value": "Basic {{encoded_credential}}"
							},
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							}
						],
						"body": {
							"mode": "urlencoded",
							"urlencoded": [
								{
									"key": "grant_type",
									"value": "{{grant_type}}",
									"type": "text"
								},
								{
									"key": "username",
									"value": "{{username}}",
									"type": "text"
								},
								{
									"key": "password",
									"value": "{{password}}",
									"type": "text"
								},
								{
									"key": "scope",
									"value": "{{scope}}",
									"type": "text"
								},
								{
									"key": "client_id",
									"value": "{{client_id}}",
									"type": "default"
								},
								{
									"key": "client_secret",
									"value": "{{client_secret}}",
									"type": "default"
								}
							]
						},
						"url": {
							"raw": "{{access_token_url}}",
							"host": [
								"{{access_token_url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "LTA Get Offline Products",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"try {\r",
									"    // verify status code\r",
									"    pm.test(\"Test Response Status Code\", function () {\r",
									"        if(pm.response.code !== 200){\r",
									"            //Not found offline products and array is empty.\r",
									"            postman.setNextRequest(\"LTA Get Online Products\");\r",
									"            console.log(\"Set next request to: 'LTA Get Online Products' .\");\r",
									"        }\r",
									"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
									"    });\r",
									"    \r",
									"    var jsonDataElements = pm.response.json().value;\r",
									"    // find online product\r",
									"    const online_product = jsonDataElements.find(m => m.Online === true);\r",
									"    \r",
									"    if (!jsonDataElements.length || online_product) {\r",
									"        //Not found offline products and array is empty.\r",
									"        postman.setNextRequest(\"LTA Get Online Products\");\r",
									"        console.log(\"Set next request to: 'LTA Get Online Products' .\");\r",
									"\t} else {\r",
									"        //MIN number of Records Test\r",
									"        var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
									"        pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
									"            pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
									"        });\r",
									"\r",
									"        var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
									"\r",
									"        console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
									"        console.log(randomItems);\r",
									"\r",
									"        pm.test(\"Test Properties for product: \" + randomItems['Id'], function () {\r",
									"            pm.expect(randomItems).to.have.property(\"Id\");\r",
									"            pm.expect(randomItems.Id).to.be.a(\"string\");\r",
									"            pm.expect(randomItems).to.have.property(\"Name\");\r",
									"            pm.expect(randomItems.Name).to.be.a(\"string\");\r",
									"            pm.expect(randomItems).to.have.property(\"ContentType\");\r",
									"            pm.expect(randomItems.ContentType).to.be.a(\"string\");\r",
									"            pm.expect(randomItems).to.have.property(\"ContentLength\");\r",
									"            pm.expect(randomItems.ContentLength).to.be.a(\"number\");\r",
									"            pm.expect(randomItems).to.have.property(\"OriginDate\");\r",
									"            pm.expect(randomItems.OriginDate).to.be.a(\"string\");\r",
									"            pm.expect(randomItems).to.have.property(\"PublicationDate\");\r",
									"            pm.expect(randomItems.PublicationDate).to.be.a(\"string\");\r",
									"            pm.expect(randomItems).to.have.property(\"ModificationDate\");\r",
									"            pm.expect(randomItems.ModificationDate).to.be.a(\"string\");\r",
									"            pm.expect(randomItems).to.have.property(\"Online\");\r",
									"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
									"            pm.expect(randomItems).to.have.property(\"Checksum\");\r",
									"            pm.expect(randomItems.Checksum).to.be.an(\"array\");\r",
									"            pm.expect(randomItems).to.have.property(\"ContentDate\");\r",
									"            pm.expect(randomItems.ContentDate).to.be.an(\"object\");\r",
									"        });\r",
									"\r",
									"        // verify online status\r",
									"        pm.test(\"Test Online status: \" + randomItems.Online , function () {\r",
									"            pm.expect(randomItems).to.have.property(\"Online\");\r",
									"            pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
									"            pm.expect(randomItems.Online).to.eq(false);\r",
									"        });\r",
									"\r",
									"        console.log(\"Product online status is: \" + randomItems.Online);\r",
									"        pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
									"        pm.globals.set('OfflineProductId', randomItems.Id);\r",
									"        pm.globals.set('OfflineProductName', randomItems.Name);\r",
									"        pm.globals.set('ContentLength', randomItems.ContentLength);\r",
									"    }\r",
									"} catch (err) {\r",
									"    pm.test(request.name, function () {\r",
									"        pm.expect.fail(err.toString());\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function addZero(x, n) {\r",
									"    while (x.toString().length < n) {\r",
									"        x = \"0\" + x;\r",
									"    }\r",
									"    return x;\r",
									"}\r",
									"\r",
									"function GetLastMonth() {\r",
									"    // Online Javascript Editor for free\r",
									"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
									"    var today = new Date();\r",
									"    var dd = String(today.getDate()).padStart(2, '0') ;\r",
									"    var mm = String(today.getMonth()).padStart(2, '0'); //January is 0!\r",
									"    var yyyy = today.getFullYear();\r",
									"    var h = addZero(today.getHours(), 2);\r",
									"    var m = addZero(today.getMinutes(), 2);\r",
									"    var s = addZero(today.getSeconds(), 2);\r",
									"    var ms = addZero(today.getMilliseconds(), 6);\r",
									"    var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
									"    \r",
									"    today = yyyy + '-' + mm + '-' + dd  + 'T' + time + 'Z';\r",
									"    //console.log(today)\r",
									"    return today;   // The function returns the product of p1 and p2\r",
									"}\r",
									"\r",
									"var last_mount = GetLastMonth();\r",
									"pm.globals.set(\"LastMonth\", last_mount);\r",
									"console.log(last_mount)"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq false) and {{ProductTypeCode}} and ContentDate/Start ge {{LastMonth}} and ContentLength le 2400000000&$top=100",
							"host": [
								"{{service-root-uri}}"
							],
							"path": [
								"odata",
								"v1",
								"Products"
							],
							"query": [
								{
									"key": "$orderby",
									"value": "PublicationDate desc"
								},
								{
									"key": "$filter",
									"value": "(Online eq false) and {{ProductTypeCode}} and ContentDate/Start ge {{LastMonth}} and ContentLength le 2400000000"
								},
								{
									"key": "$top",
									"value": "100"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "LTA Product Order (Benchmarking)",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"if(pm.environment.get('execute_admin_requests') == \"true\"){\r",
									"    console.warn(\"Sending request as administrator!\");\r",
									"    postman.setNextRequest(null);       \r",
									"}   "
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"properties_map = {};\r",
									"properties_map.Id = function (element) { pm.expect(element.Id).to.match(/[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}/); };\r",
									"properties_map.Status = function (element) {\r",
									"    pm.expect(element.Status).to.be.a(\"string\");\r",
									"    pm.expect(element.Status).to.be.oneOf([\"in_progress\", \"queued\", \"failed\", \"completed\", \"cancelled\"]);\r",
									"};\r",
									"properties_map.StatusMessage=function (element) {\r",
									"    pm.expect(element.StatusMessage).to.be.a(\"string\");\r",
									"};\r",
									"properties_map.Priority = function (element) { pm.expect(element.Priority).to.be.a(\"number\"); };\r",
									"properties_map.SubmissionDate = function (element) { pm.expect(element.SubmissionDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
									"properties_map.EstimatedDate = function (element) { pm.expect(element.EstimatedDate).to.match(/\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d|Z/); };\r",
									"\r",
									"function propertySpecific(key, order){\r",
									"    if (properties_map[key]) {\r",
									"        pm.test(\"Test Property \"+key+\" for Order: \" + order[key], function(){\r",
									"            properties_map[key](order);\r",
									"            pm.expect(pm.response.text()).to.include(key);});\r",
									"    }\r",
									"    else {\r",
									"        console.warn(\"Skipped Test Property \"+key+\" for Order: \" + order[key]);\r",
									"    }\r",
									"}\r",
									"\r",
									"try {\r",
									"\r",
									"    pm.test(\"Test Response Status Code\", function () {\r",
									"        pm.expect(pm.response.code).to.be.oneOf([201, 202]);\r",
									"    });\r",
									"\r",
									"    var jsonDataElements = pm.response.json();\r",
									"    //test property for order\r",
									"    var order = jsonDataElements;\r",
									"\r",
									"    for (const [key, value] of Object.entries(properties_map)) {\r",
									"        propertySpecific(key, order);\r",
									"        pm.globals.set(\"Order\" + key, jsonDataElements[key]);\r",
									"    }\r",
									"    \r",
									"    postman.setNextRequest(null);\r",
									"\r",
									"} catch (err) {\r",
									"    pm.test(request.name, function () {\r",
									"        pm.expect.fail(err.toString());\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"Priority\": {{OrderPriority}}\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{service-root-uri}}/odata/v1/Products({{OfflineProductId}})/OData.CSC.Order",
							"host": [
								"{{service-root-uri}}"
							],
							"path": [
								"odata",
								"v1",
								"Products({{OfflineProductId}})",
								"OData.CSC.Order"
							]
						}
					},
					"response": []
				},
				{
					"name": "LTA Get Online Products",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"try {\r",
									"\r",
									"    pm.test(\"Test Response Status Code\", function () {\r",
									"        pm.expect(pm.response.code).to.be.oneOf([200]);\r",
									"    });\r",
									"\r",
									"    var jsonDataElements = pm.response.json().value;\r",
									"\r",
									"    //MIN number of Records Test\r",
									"    var minimumExpRecords = parseInt(pm.collectionVariables.get('resp_min_records'));\r",
									"    pm.test(\"Expected minimum number of products Test: \" + minimumExpRecords, function () {\r",
									"        pm.expect(jsonDataElements.length).to.be.gte(minimumExpRecords);\r",
									"    });\r",
									"\r",
									"    var randomItems = jsonDataElements[Math.floor(Math.random() * jsonDataElements.length)];\r",
									"\r",
									"    pm.test(\"Test Id for product: \" + randomItems.Id, function () {\r",
									"        pm.expect(randomItems).to.have.property(\"Id\");\r",
									"        pm.expect(randomItems.Id).to.be.a(\"string\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Test Online status: \" + randomItems.Online, function () {\r",
									"        pm.expect(randomItems).to.have.property(\"Online\");\r",
									"        pm.expect(randomItems.Online).to.be.a(\"boolean\");\r",
									"        pm.expect(randomItems.Online).to.eq(true);\r",
									"    });\r",
									"\r",
									"    console.log(\"Processing product: \" + randomItems['Name'] + \" (\" + randomItems['Id'] + \")\");\r",
									"    console.log(randomItems);\r",
									"    console.log(\"Product online status is: \" + randomItems.Online);\r",
									"    pm.globals.set('OnlineProductId', randomItems.Id);\r",
									"    pm.globals.set(\"OnlineStatus\", randomItems.Online.toString());\r",
									"\r",
									"} catch (err) {\r",
									"    pm.test(request.name, function () {\r",
									"        pm.expect.fail(err.toString());\r",
									"    });\r",
									"}\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function addZero(x, n) {\r",
									"    while (x.toString().length < n) {\r",
									"        x = \"0\" + x;\r",
									"    }\r",
									"    return x;\r",
									"}\r",
									"\r",
									"function GetLastMonth() {\r",
									"    // Online Javascript Editor for free\r",
									"    // Write, Edit and Run your Javascript code using JS Online Compiler\r",
									"    var today = new Date();\r",
									"    var dd = String(today.getDate()).padStart(2, '0') ;\r",
									"    var mm = String(today.getMonth()).padStart(2, '0'); //January is 0!\r",
									"    var yyyy = today.getFullYear();\r",
									"    var h = addZero(today.getHours(), 2);\r",
									"    var m = addZero(today.getMinutes(), 2);\r",
									"    var s = addZero(today.getSeconds(), 2);\r",
									"    var ms = addZero(today.getMilliseconds(), 6);\r",
									"    var time = h + \":\" + m + \":\" + s + \".\" + ms;\r",
									"    \r",
									"    today = yyyy + '-' + mm + '-' + dd  + 'T' + time + 'Z';\r",
									"    //console.log(today)\r",
									"    return today;   // The function returns the product of p1 and p2\r",
									"}\r",
									"\r",
									"var last_mount = GetLastMonth();\r",
									"pm.globals.set(\"LastMonth\", last_mount);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{service-root-uri}}/odata/v1/Products?$orderby=PublicationDate desc&$filter=(Online eq true) and {{ProductTypeCode}} and ContentDate/Start ge {{LastMonth}} and ContentLength le 2400000000&$top=100",
							"host": [
								"{{service-root-uri}}"
							],
							"path": [
								"odata",
								"v1",
								"Products"
							],
							"query": [
								{
									"key": "$orderby",
									"value": "PublicationDate desc"
								},
								{
									"key": "$filter",
									"value": "(Online eq true) and {{ProductTypeCode}} and ContentDate/Start ge {{LastMonth}} and ContentLength le 2400000000"
								},
								{
									"key": "$top",
									"value": "100"
								}
							]
						}
					},
					"response": []
				}
			],
			"description": "The purpose of \"**Long Term Archive ICD_v1.9\"** is to specify the interfaces of the Long Term Archive (LTA) and describe the test suite which may be performed using the Postman collection.",
			"auth": {
				"type": "noauth"
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Define the encoded string",
							"// Default is OAuth2.0",
							"let auth_string ",
							"if(pm.environment.get(\"auth_type\") == \"basic\"){",
							"    var decoded_string = pm.environment.get(\"username\") + \":\" + pm.environment.get(\"password\");",
							"    // Encode the String",
							"    var encoded_string = btoa(decoded_string);",
							"    auth_string = \"Basic \" + encoded_string;",
							"}",
							"else{",
							"    ",
							"    // Encode the String",
							"    auth_string = \"Bearer \" + pm.globals.get(\"access_token\");",
							"}",
							"",
							"//console.log(auth_string);",
							"pm.globals.set(\"authorization\",auth_string);",
							"// added header",
							"pm.request.headers.upsert({",
							" 'key': \"Authorization\",",
							" 'value': pm.globals.get(\"authorization\") ",
							" });",
							"",
							"",
							"",
							"",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// print version",
					"const version = \"2.3.0\";",
					"if(!pm.globals.get(\"CollectionVersion\") || !pm.variables.get(\"CounterVersion\")){",
					"    pm.globals.set(\"CollectionVersion\",version);",
					"    pm.variables.set(\"CounterVersion\",'1');",
					"    console.log(\"Collection version \" + version);",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "resp_min_records",
			"value": "1"
		},
		{
			"key": "counterLimit",
			"value": "1000",
			"type": "default"
		}
	]
}